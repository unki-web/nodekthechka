{
  "version": 3,
  "sources": ["../../node_modules/cookie/dist/index.js", "../../node_modules/fast-decode-uri-component/index.js", "../../node_modules/memoirist/dist/bun/index.js", "../../src/index.ts", "../../src/type-system/index.ts", "../../src/type-system/format.ts", "../../src/type-system/utils.ts", "../../src/universal/utils.ts", "../../src/universal/file.ts", "../../src/error.ts", "../../src/utils.ts", "../../src/sucrose.ts", "../../src/cookies.ts", "../../src/adapter/utils.ts", "../../src/adapter/web-standard/handler.ts", "../../src/adapter/web-standard/index.ts", "../../src/compose.ts", "../../src/parse-query.ts", "../../src/trace.ts", "../../src/schema.ts", "../../node_modules/exact-mirror/dist/index.mjs", "../../src/adapter/bun/handler.ts", "../../src/adapter/bun/compose.ts", "../../src/adapter/bun/handler-native.ts", "../../src/ws/index.ts", "../../src/adapter/bun/index.ts", "../../src/universal/env.ts", "../../src/dynamic-handle.ts"],
  "sourcesContent": [
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse = parse;\nexports.serialize = serialize;\n/**\n * RegExp to match cookie-name in RFC 6265 sec 4.1.1\n * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2\n * which has been replaced by the token definition in RFC 7230 appendix B.\n *\n * cookie-name       = token\n * token             = 1*tchar\n * tchar             = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" /\n *                     \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" /\n *                     \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n *\n * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191\n * Allow same range as cookie value, except `=`, which delimits end of name.\n */\nconst cookieNameRegExp = /^[\\u0021-\\u003A\\u003C\\u003E-\\u007E]+$/;\n/**\n * RegExp to match cookie-value in RFC 6265 sec 4.1.1\n *\n * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n *                     ; US-ASCII characters excluding CTLs,\n *                     ; whitespace DQUOTE, comma, semicolon,\n *                     ; and backslash\n *\n * Allowing more characters: https://github.com/jshttp/cookie/issues/191\n * Comma, backslash, and DQUOTE are not part of the parsing algorithm.\n */\nconst cookieValueRegExp = /^[\\u0021-\\u003A\\u003C-\\u007E]*$/;\n/**\n * RegExp to match domain-value in RFC 6265 sec 4.1.1\n *\n * domain-value      = <subdomain>\n *                     ; defined in [RFC1034], Section 3.5, as\n *                     ; enhanced by [RFC1123], Section 2.1\n * <subdomain>       = <label> | <subdomain> \".\" <label>\n * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]\n *                     Labels must be 63 characters or less.\n *                     'let-dig' not 'letter' in the first char, per RFC1123\n * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>\n * <let-dig-hyp>     = <let-dig> | \"-\"\n * <let-dig>         = <letter> | <digit>\n * <letter>          = any one of the 52 alphabetic characters A through Z in\n *                     upper case and a through z in lower case\n * <digit>           = any one of the ten digits 0 through 9\n *\n * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173\n *\n * > (Note that a leading %x2E (\".\"), if present, is ignored even though that\n * character is not permitted, but a trailing %x2E (\".\"), if present, will\n * cause the user agent to ignore the attribute.)\n */\nconst domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;\n/**\n * RegExp to match path-value in RFC 6265 sec 4.1.1\n *\n * path-value        = <any CHAR except CTLs or \";\">\n * CHAR              = %x01-7F\n *                     ; defined in RFC 5234 appendix B.1\n */\nconst pathValueRegExp = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/;\nconst __toString = Object.prototype.toString;\nconst NullObject = /* @__PURE__ */ (() => {\n    const C = function () { };\n    C.prototype = Object.create(null);\n    return C;\n})();\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n */\nfunction parse(str, options) {\n    const obj = new NullObject();\n    const len = str.length;\n    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.\n    if (len < 2)\n        return obj;\n    const dec = options?.decode || decode;\n    let index = 0;\n    do {\n        const eqIdx = str.indexOf(\"=\", index);\n        if (eqIdx === -1)\n            break; // No more cookie pairs.\n        const colonIdx = str.indexOf(\";\", index);\n        const endIdx = colonIdx === -1 ? len : colonIdx;\n        if (eqIdx > endIdx) {\n            // backtrack on prior semicolon\n            index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n            continue;\n        }\n        const keyStartIdx = startIndex(str, index, eqIdx);\n        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);\n        const key = str.slice(keyStartIdx, keyEndIdx);\n        // only assign once\n        if (obj[key] === undefined) {\n            let valStartIdx = startIndex(str, eqIdx + 1, endIdx);\n            let valEndIdx = endIndex(str, endIdx, valStartIdx);\n            const value = dec(str.slice(valStartIdx, valEndIdx));\n            obj[key] = value;\n        }\n        index = endIdx + 1;\n    } while (index < len);\n    return obj;\n}\nfunction startIndex(str, index, max) {\n    do {\n        const code = str.charCodeAt(index);\n        if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */)\n            return index;\n    } while (++index < max);\n    return max;\n}\nfunction endIndex(str, index, min) {\n    while (index > min) {\n        const code = str.charCodeAt(--index);\n        if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */)\n            return index + 1;\n    }\n    return min;\n}\n/**\n * Serialize data into a cookie header.\n *\n * Serialize a name value pair into a cookie string suitable for\n * http headers. An optional options object specifies cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n */\nfunction serialize(name, val, options) {\n    const enc = options?.encode || encodeURIComponent;\n    if (!cookieNameRegExp.test(name)) {\n        throw new TypeError(`argument name is invalid: ${name}`);\n    }\n    const value = enc(val);\n    if (!cookieValueRegExp.test(value)) {\n        throw new TypeError(`argument val is invalid: ${val}`);\n    }\n    let str = name + \"=\" + value;\n    if (!options)\n        return str;\n    if (options.maxAge !== undefined) {\n        if (!Number.isInteger(options.maxAge)) {\n            throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);\n        }\n        str += \"; Max-Age=\" + options.maxAge;\n    }\n    if (options.domain) {\n        if (!domainValueRegExp.test(options.domain)) {\n            throw new TypeError(`option domain is invalid: ${options.domain}`);\n        }\n        str += \"; Domain=\" + options.domain;\n    }\n    if (options.path) {\n        if (!pathValueRegExp.test(options.path)) {\n            throw new TypeError(`option path is invalid: ${options.path}`);\n        }\n        str += \"; Path=\" + options.path;\n    }\n    if (options.expires) {\n        if (!isDate(options.expires) ||\n            !Number.isFinite(options.expires.valueOf())) {\n            throw new TypeError(`option expires is invalid: ${options.expires}`);\n        }\n        str += \"; Expires=\" + options.expires.toUTCString();\n    }\n    if (options.httpOnly) {\n        str += \"; HttpOnly\";\n    }\n    if (options.secure) {\n        str += \"; Secure\";\n    }\n    if (options.partitioned) {\n        str += \"; Partitioned\";\n    }\n    if (options.priority) {\n        const priority = typeof options.priority === \"string\"\n            ? options.priority.toLowerCase()\n            : undefined;\n        switch (priority) {\n            case \"low\":\n                str += \"; Priority=Low\";\n                break;\n            case \"medium\":\n                str += \"; Priority=Medium\";\n                break;\n            case \"high\":\n                str += \"; Priority=High\";\n                break;\n            default:\n                throw new TypeError(`option priority is invalid: ${options.priority}`);\n        }\n    }\n    if (options.sameSite) {\n        const sameSite = typeof options.sameSite === \"string\"\n            ? options.sameSite.toLowerCase()\n            : options.sameSite;\n        switch (sameSite) {\n            case true:\n            case \"strict\":\n                str += \"; SameSite=Strict\";\n                break;\n            case \"lax\":\n                str += \"; SameSite=Lax\";\n                break;\n            case \"none\":\n                str += \"; SameSite=None\";\n                break;\n            default:\n                throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);\n        }\n    }\n    return str;\n}\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n */\nfunction decode(str) {\n    if (str.indexOf(\"%\") === -1)\n        return str;\n    try {\n        return decodeURIComponent(str);\n    }\n    catch (e) {\n        return str;\n    }\n}\n/**\n * Determine if value is a Date.\n */\nfunction isDate(val) {\n    return __toString.call(val) === \"[object Date]\";\n}\n//# sourceMappingURL=index.js.map",
    "'use strict'\n\nvar UTF8_ACCEPT = 12\nvar UTF8_REJECT = 0\nvar UTF8_DATA = [\n  // The first part of the table maps bytes to character to a transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,\n  10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\n  // The second part of the table maps a state to a new state when adding a\n  // transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96,\n  0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\n  // The third part maps the current transition to a mask that needs to apply\n  // to the byte.\n  0x7F, 0x3F, 0x3F, 0x3F, 0x00, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07\n]\n\nfunction decodeURIComponent (uri) {\n  var percentPosition = uri.indexOf('%')\n  if (percentPosition === -1) return uri\n\n  var length = uri.length\n  var decoded = ''\n  var last = 0\n  var codepoint = 0\n  var startOfOctets = percentPosition\n  var state = UTF8_ACCEPT\n\n  while (percentPosition > -1 && percentPosition < length) {\n    var high = hexCodeToInt(uri[percentPosition + 1], 4)\n    var low = hexCodeToInt(uri[percentPosition + 2], 0)\n    var byte = high | low\n    var type = UTF8_DATA[byte]\n    state = UTF8_DATA[256 + state + type]\n    codepoint = (codepoint << 6) | (byte & UTF8_DATA[364 + type])\n\n    if (state === UTF8_ACCEPT) {\n      decoded += uri.slice(last, startOfOctets)\n\n      decoded += (codepoint <= 0xFFFF)\n        ? String.fromCharCode(codepoint)\n        : String.fromCharCode(\n          (0xD7C0 + (codepoint >> 10)),\n          (0xDC00 + (codepoint & 0x3FF))\n        )\n\n      codepoint = 0\n      last = percentPosition + 3\n      percentPosition = startOfOctets = uri.indexOf('%', last)\n    } else if (state === UTF8_REJECT) {\n      return null\n    } else {\n      percentPosition += 3\n      if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue\n      return null\n    }\n  }\n\n  return decoded + uri.slice(last)\n}\n\nvar HEX = {\n  '0': 0,\n  '1': 1,\n  '2': 2,\n  '3': 3,\n  '4': 4,\n  '5': 5,\n  '6': 6,\n  '7': 7,\n  '8': 8,\n  '9': 9,\n  'a': 10,\n  'A': 10,\n  'b': 11,\n  'B': 11,\n  'c': 12,\n  'C': 12,\n  'd': 13,\n  'D': 13,\n  'e': 14,\n  'E': 14,\n  'f': 15,\n  'F': 15\n}\n\nfunction hexCodeToInt (c, shift) {\n  var i = HEX[c]\n  return i === undefined ? 255 : i << shift\n}\n\nmodule.exports = decodeURIComponent\n",
    "// @bun\nvar Y=(A,b)=>{let v=b?.length?{}:null;if(v)for(let K of b)v[K.part.charCodeAt(0)]=K;return{part:A,store:null,inert:v,params:null,wildcardStore:null}},k=(A,b)=>({...A,part:b}),T=(A)=>({name:A,store:null,inert:null});class _{config;root={};history=[];deferred=[];constructor(A={}){this.config=A;if(A.lazy)this.find=this.lazyFind}static regex={static:/:.+?(?=\\/|$)/,params:/:.+?(?=\\/|$)/g,optionalParams:/:.+?\\?(?=\\/|$)/g};lazyFind=(A,b)=>{if(!this.config.lazy)return this.find;return this.build(),this.find(A,b)};build(){if(!this.config.lazy)return;for(let[A,b,v]of this.deferred)this.add(A,b,v,{lazy:!1,ignoreHistory:!0});this.deferred=[],this.find=(A,b)=>{let v=this.root[A];if(!v)return null;return $(b,b.length,v,0)}}add(A,b,v,{ignoreError:K=!1,ignoreHistory:V=!1,lazy:U=this.config.lazy}={}){if(U)return this.find=this.lazyFind,this.deferred.push([A,b,v]),v;if(typeof b!==\"string\")throw new TypeError(\"Route path must be a string\");if(b===\"\")b=\"/\";else if(b[0]!==\"/\")b=`/${b}`;let J=b[b.length-1]===\"*\",F=b.match(_.regex.optionalParams);if(F){let S=b.replaceAll(\"?\",\"\");this.add(A,S,v,{ignoreError:K,ignoreHistory:V,lazy:U});for(let D=0;D<F.length;D++){let B=b.replace(\"/\"+F[D],\"\");this.add(A,B,v,{ignoreError:!0,ignoreHistory:V,lazy:U})}return v}if(F)b=b.replaceAll(\"?\",\"\");if(this.history.find(([S,D,B])=>S===A&&D===b))return v;if(J||F&&b.charCodeAt(b.length-1)===63)b=b.slice(0,-1);if(!V)this.history.push([A,b,v]);let G=b.split(_.regex.static),X=b.match(_.regex.params)||[];if(G[G.length-1]===\"\")G.pop();let q;if(!this.root[A])q=this.root[A]=Y(\"/\");else q=this.root[A];let O=0;for(let S=0;S<G.length;++S){let D=G[S];if(S>0){let B=X[O++].slice(1);if(q.params===null)q.params=T(B);else if(q.params.name!==B)if(K)return v;else throw new Error(`Cannot create route \"${b}\" with parameter \"${B}\" because a route already exists with a different parameter name (\"${q.params.name}\") in the same location`);let Q=q.params;if(Q.inert===null){q=Q.inert=Y(D);continue}q=Q.inert}for(let B=0;;){if(B===D.length){if(B<q.part.length){let Q=k(q,q.part.slice(B));Object.assign(q,Y(D,[Q]))}break}if(B===q.part.length){if(q.inert===null)q.inert={};let Q=q.inert[D.charCodeAt(B)];if(Q){q=Q,D=D.slice(B),B=0;continue}let Z=Y(D.slice(B));q.inert[D.charCodeAt(B)]=Z,q=Z;break}if(D[B]!==q.part[B]){let Q=k(q,q.part.slice(B)),Z=Y(D.slice(B));Object.assign(q,Y(q.part.slice(0,B),[Q,Z])),q=Z;break}++B}}if(O<X.length){let D=X[O].slice(1);if(q.params===null)q.params=T(D);else if(q.params.name!==D)if(K)return v;else throw new Error(`Cannot create route \"${b}\" with parameter \"${D}\" because a route already exists with a different parameter name (\"${q.params.name}\") in the same location`);if(q.params.store===null)q.params.store=v;return q.params.store}if(J){if(q.wildcardStore===null)q.wildcardStore=v;return q.wildcardStore}if(q.store===null)q.store=v;return q.store}find(A,b){let v=this.root[A];if(!v)return null;return $(b,b.length,v,0)}}var $=(A,b,v,K)=>{let V=v.part,U=V.length,J=K+U;if(U>1){if(J>b)return null;if(U<15){for(let F=1,G=K+1;F<U;++F,++G)if(V.charCodeAt(F)!==A.charCodeAt(G))return null}else if(A.slice(K,J)!==V)return null}if(J===b){if(v.store!==null)return{store:v.store,params:{}};if(v.wildcardStore!==null)return{store:v.wildcardStore,params:{\"*\":\"\"}};return null}if(v.inert!==null){let F=v.inert[A.charCodeAt(J)];if(F!==void 0){let G=$(A,b,F,J);if(G!==null)return G}}if(v.params!==null){let{store:F,name:G,inert:X}=v.params,q=A.indexOf(\"/\",J);if(q!==J){if(q===-1||q>=b){if(F!==null){let O={};return O[G]=A.substring(J,b),{store:F,params:O}}}else if(X!==null){let O=$(A,b,X,q);if(O!==null)return O.params[G]=A.substring(J,q),O}}}if(v.wildcardStore!==null)return{store:v.wildcardStore,params:{\"*\":A.substring(J,b)}};return null},w=_;export{w as default,_ as Memoirist};\n\n//# debugId=AF0DA1C424179B9664756E2164756E21\n",
    "import { Memoirist } from 'memoirist'\nimport {\n\tKind,\n\ttype TObject,\n\ttype Static,\n\ttype TSchema,\n\ttype TModule,\n\ttype TRef,\n\ttype TProperties\n} from '@sinclair/typebox'\n\nimport type { Context } from './context'\n\nimport { t } from './type-system'\nimport {\n\tclearSucroseCache,\n\tmergeInference,\n\tsucrose,\n\ttype Sucrose\n} from './sucrose'\n\nimport type { WSLocalHook } from './ws/types'\n\nimport { BunAdapter } from './adapter/bun/index'\nimport { WebStandardAdapter } from './adapter/web-standard/index'\nimport type { ElysiaAdapter } from './adapter/types'\n\nimport { env } from './universal/env'\nimport type { ListenCallback, Serve, Server } from './universal/server'\n\nimport {\n\tcloneInference,\n\tdeduplicateChecksum,\n\tfnToContainer,\n\tgetLoosePath,\n\tlocalHookToLifeCycleStore,\n\tmergeDeep,\n\tmergeSchemaValidator,\n\tPromiseGroup,\n\tpromoteEvent,\n\tisNotEmpty,\n\tencodePath,\n\tlifeCycleToArray,\n\tsupportPerMethodInlineHandler\n} from './utils'\n\nimport {\n\tcoercePrimitiveRoot,\n\tstringToStructureCoercions,\n\tgetSchemaValidator,\n\tgetResponseSchemaValidator,\n\tgetCookieValidator,\n\tElysiaTypeCheck\n} from './schema'\nimport {\n\tcomposeHandler,\n\tcomposeGeneralHandler,\n\tcomposeErrorHandler\n} from './compose'\n\nimport { createTracer } from './trace'\n\nimport {\n\tmergeHook,\n\tchecksum,\n\tmergeLifeCycle,\n\tfilterGlobalHook,\n\tasHookType,\n\ttraceBackMacro,\n\treplaceUrlPath,\n\tcreateMacroManager\n} from './utils'\n\nimport {\n\tcreateDynamicErrorHandler,\n\tcreateDynamicHandler,\n\ttype DynamicHandler\n} from './dynamic-handle'\n\nimport {\n\tERROR_CODE,\n\tValidationError,\n\ttype ParseError,\n\ttype NotFoundError,\n\ttype InternalServerError,\n\tElysiaCustomStatusResponse\n} from './error'\n\nimport type { TraceHandler } from './trace'\n\nimport type {\n\tElysiaConfig,\n\tSingletonBase,\n\tDefinitionBase,\n\tHandler,\n\tComposedHandler,\n\tInputSchema,\n\tLocalHook,\n\tAnyLocalHook,\n\tMergeSchema,\n\tRouteSchema,\n\tUnwrapRoute,\n\tInternalRoute,\n\tHTTPMethod,\n\tSchemaValidator,\n\tPreHandler,\n\tBodyHandler,\n\tOptionalHandler,\n\tErrorHandler,\n\tLifeCycleStore,\n\tMaybePromise,\n\tPrettify,\n\tPrettify2,\n\tAddPrefix,\n\tAddSuffix,\n\tAddPrefixCapitalize,\n\tAddSuffixCapitalize,\n\tMaybeArray,\n\tGracefulHandler,\n\tMapResponse,\n\tChecksum,\n\tMacroManager,\n\tMacroToProperty,\n\tTransformHandler,\n\tMetadataBase,\n\tRouteBase,\n\tCreateEden,\n\tComposeElysiaResponse,\n\tInlineHandler,\n\tHookContainer,\n\tLifeCycleType,\n\tMacroQueue,\n\tEphemeralType,\n\tExcludeElysiaResponse,\n\tModelValidator,\n\tBaseMacroFn,\n\tContextAppendType,\n\tReconcile,\n\tAfterResponseHandler,\n\tHigherOrderFunction,\n\tResolvePath,\n\tJoinPath,\n\tValidatorLayer,\n\tMergeElysiaInstances,\n\tHookMacroFn,\n\tResolveHandler,\n\tResolveResolutions,\n\tUnwrapTypeModule,\n\tMacroToContext,\n\tStandaloneValidator,\n\tGuardSchemaType,\n\tOr,\n\tPrettifySchema,\n\tMergeStandaloneSchema,\n\tIsNever,\n\tDocumentDecoration,\n\tAfterHandler\n} from './types'\n\nexport type AnyElysia = Elysia<any, any, any, any, any, any, any>\n\n/**\n * ### Elysia Server\n * Main instance to create web server using Elysia\n *\n * ---\n * @example\n * ```typescript\n * import { Elysia } from 'elysia'\n *\n * new Elysia()\n *     .get(\"/\", () => \"Hello\")\n *     .listen(3000)\n * ```\n */\nexport default class Elysia<\n\tconst in out BasePath extends string = '',\n\tconst in out Singleton extends SingletonBase = {\n\t\tdecorator: {}\n\t\tstore: {}\n\t\tderive: {}\n\t\tresolve: {}\n\t},\n\tconst in out Definitions extends DefinitionBase = {\n\t\ttypebox: {}\n\t\terror: {}\n\t},\n\tconst in out Metadata extends MetadataBase = {\n\t\tschema: {}\n\t\tstandaloneSchema: {}\n\t\tmacro: {}\n\t\tmacroFn: {}\n\t\tparser: {}\n\t},\n\tconst out Routes extends RouteBase = {},\n\t// ? scoped\n\tconst in out Ephemeral extends EphemeralType = {\n\t\tderive: {}\n\t\tresolve: {}\n\t\tschema: {}\n\t\tstandaloneSchema: {}\n\t},\n\t// ? local\n\tconst in out Volatile extends EphemeralType = {\n\t\tderive: {}\n\t\tresolve: {}\n\t\tschema: {}\n\t\tstandaloneSchema: {}\n\t}\n> {\n\tconfig: ElysiaConfig<BasePath>\n\n\tserver: Server | null = null\n\tprivate dependencies: { [key in string]: Checksum[] } = {}\n\n\t'~Prefix' = '' as BasePath\n\t'~Singleton' = null as unknown as Singleton\n\t'~Definitions' = null as unknown as Definitions\n\t'~Metadata' = null as unknown as Metadata\n\t'~Ephemeral' = null as unknown as Ephemeral\n\t'~Volatile' = null as unknown as Volatile\n\t'~Routes' = null as unknown as Routes\n\n\tprotected singleton = {\n\t\tdecorator: {},\n\t\tstore: {},\n\t\tderive: {},\n\t\tresolve: {}\n\t} as SingletonBase\n\n\tget store(): Singleton['store'] {\n\t\treturn this.singleton.store\n\t}\n\n\tget decorator(): Singleton['decorator'] {\n\t\treturn this.singleton.decorator\n\t}\n\n\tprotected definitions = {\n\t\ttypebox: t.Module({}),\n\t\ttype: {} as Record<string, TSchema>,\n\t\terror: {} as Record<string, Error>\n\t}\n\n\tprotected extender = {\n\t\tmacros: <MacroQueue[]>[],\n\t\thigherOrderFunctions: <HookContainer<HigherOrderFunction>[]>[]\n\t}\n\n\tprotected validator: ValidatorLayer = {\n\t\tglobal: null,\n\t\tscoped: null,\n\t\tlocal: null,\n\t\tgetCandidate() {\n\t\t\treturn mergeSchemaValidator(\n\t\t\t\tmergeSchemaValidator(this.global, this.scoped),\n\t\t\t\tthis.local\n\t\t\t)\n\t\t}\n\t}\n\n\tprotected standaloneValidator: StandaloneValidator = {\n\t\tglobal: null,\n\t\tscoped: null,\n\t\tlocal: null\n\t}\n\n\tevent: Partial<LifeCycleStore> = {}\n\n\tprotected telemetry:\n\t\t| undefined\n\t\t| {\n\t\t\t\tstack: string | undefined\n\t\t  }\n\n\trouter = {\n\t\t'~http': undefined as\n\t\t\t| Memoirist<{\n\t\t\t\t\tcompile: Function\n\t\t\t\t\thandler?: ComposedHandler\n\t\t\t  }>\n\t\t\t| undefined,\n\t\tget http() {\n\t\t\tif (!this['~http']) this['~http'] = new Memoirist({ lazy: true })\n\n\t\t\treturn this['~http']\n\t\t},\n\t\t'~dynamic': undefined as Memoirist<DynamicHandler> | undefined,\n\t\t// Use in non-AOT mode\n\t\tget dynamic() {\n\t\t\tif (!this['~dynamic']) this['~dynamic'] = new Memoirist()\n\n\t\t\treturn this['~dynamic']\n\t\t},\n\t\t// Static Router\n\t\tstatic: {} as { [path in string]: { [method in string]: number } },\n\t\t// Native Static Response\n\t\tresponse: {} as {\n\t\t\t[path: string]:\n\t\t\t\t| MaybePromise<Response | undefined>\n\t\t\t\t| { [method: string]: MaybePromise<Response | undefined> }\n\t\t},\n\t\thistory: [] as InternalRoute[]\n\t}\n\n\tprotected routeTree: Record<string, number> = {}\n\n\tget routes(): InternalRoute[] {\n\t\treturn this.router.history\n\t}\n\n\tprotected getGlobalRoutes(): InternalRoute[] {\n\t\treturn this.router.history\n\t}\n\n\tprotected getGlobalDefinitions() {\n\t\treturn this.definitions\n\t}\n\n\tprotected inference: Sucrose.Inference = {\n\t\tbody: false,\n\t\tcookie: false,\n\t\theaders: false,\n\t\tquery: false,\n\t\tset: false,\n\t\tserver: false,\n\t\tpath: false,\n\t\troute: false,\n\t\turl: false\n\t}\n\n\tprivate getServer() {\n\t\treturn this.server\n\t}\n\n\tprivate getParent(): Elysia | null {\n\t\treturn null\n\t}\n\n\t'~parser': { [K in string]: BodyHandler<any, any> } = {}\n\n\tprivate _promisedModules: PromiseGroup | undefined\n\tprivate get promisedModules() {\n\t\tif (!this._promisedModules)\n\t\t\tthis._promisedModules = new PromiseGroup(console.error, () => {\n\t\t\t\t// this.compile()\n\t\t\t})\n\n\t\treturn this._promisedModules\n\t}\n\n\tconstructor(config: ElysiaConfig<BasePath> = {}) {\n\t\tif (config.tags) {\n\t\t\tif (!config.detail)\n\t\t\t\tconfig.detail = {\n\t\t\t\t\ttags: config.tags\n\t\t\t\t}\n\t\t\telse config.detail.tags = config.tags\n\t\t}\n\n\t\tthis.config = {\n\t\t\tprefix: '' as any,\n\t\t\taot: env.ELYSIA_AOT !== 'false',\n\t\t\tnativeStaticResponse: true,\n\t\t\tsystemRouter: true,\n\t\t\tencodeSchema: true,\n\t\t\tnormalize: true,\n\t\t\t...config,\n\t\t\tcookie: {\n\t\t\t\tpath: '/',\n\t\t\t\t...config?.cookie\n\t\t\t},\n\t\t\texperimental: config?.experimental ?? {},\n\t\t\tseed: config?.seed === undefined ? '' : config?.seed\n\t\t}\n\n\t\tthis['~adapter'] =\n\t\t\tconfig.adapter ??\n\t\t\t(typeof Bun !== 'undefined' ? BunAdapter : WebStandardAdapter)\n\n\t\tif (config?.analytic && (config?.name || config?.seed !== undefined))\n\t\t\tthis.telemetry = {\n\t\t\t\tstack: new Error().stack\n\t\t\t}\n\t}\n\n\t'~adapter': ElysiaAdapter\n\n\tenv(model: TObject<any>, _env = env) {\n\t\tconst validator = getSchemaValidator(model, {\n\t\t\tmodules: this.definitions.typebox,\n\t\t\tdynamic: true,\n\t\t\tadditionalProperties: true,\n\t\t\tcoerce: true,\n\t\t\tsanitize: () => this.config.sanitize\n\t\t})\n\n\t\tif (validator.Check(_env) === false) {\n\t\t\tconst error = new ValidationError('env', model, _env)\n\n\t\t\tthrow new Error(error.all.map((x) => x.summary).join('\\n'))\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * @private DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n\t * @version 1.1.0\n\t *\n\t * ! Do not use unless you know exactly what you are doing\n\t * ? Add Higher order function to Elysia.fetch\n\t */\n\twrap(fn: HigherOrderFunction) {\n\t\tthis.extender.higherOrderFunctions.push({\n\t\t\tchecksum: checksum(\n\t\t\t\tJSON.stringify({\n\t\t\t\t\tname: this.config.name,\n\t\t\t\t\tseed: this.config.seed,\n\t\t\t\t\tcontent: fn.toString()\n\t\t\t\t})\n\t\t\t),\n\t\t\tfn\n\t\t})\n\n\t\treturn this\n\t}\n\n\tprivate applyMacro(localHook: AnyLocalHook) {\n\t\tif (this.extender.macros.length) {\n\t\t\tconst manage = createMacroManager({\n\t\t\t\tglobalHook: this.event,\n\t\t\t\tlocalHook\n\t\t\t})\n\n\t\t\tconst manager: MacroManager = {\n\t\t\t\tevents: {\n\t\t\t\t\tglobal: this.event,\n\t\t\t\t\tlocal: localHook\n\t\t\t\t},\n\t\t\t\tget onParse() {\n\t\t\t\t\treturn manage('parse') as any\n\t\t\t\t},\n\t\t\t\tget onTransform() {\n\t\t\t\t\treturn manage('transform') as any\n\t\t\t\t},\n\t\t\t\tget onBeforeHandle() {\n\t\t\t\t\treturn manage('beforeHandle') as any\n\t\t\t\t},\n\t\t\t\tget onAfterHandle() {\n\t\t\t\t\treturn manage('afterHandle') as any\n\t\t\t\t},\n\t\t\t\tget mapResponse() {\n\t\t\t\t\treturn manage('mapResponse') as any\n\t\t\t\t},\n\t\t\t\tget onAfterResponse() {\n\t\t\t\t\treturn manage('afterResponse') as any\n\t\t\t\t},\n\t\t\t\tget onError() {\n\t\t\t\t\treturn manage('error') as any\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const macro of this.extender.macros)\n\t\t\t\ttraceBackMacro(macro.fn(manager), localHook, manage)\n\t\t}\n\t}\n\n\tget models(): {\n\t\t[K in keyof Definitions['typebox']]: ModelValidator<\n\t\t\tDefinitions['typebox'][K]\n\t\t>\n\t} & {\n\t\tmodules: TModule<Definitions['typebox']>\n\t} {\n\t\tconst models: Record<string, ElysiaTypeCheck<TSchema>> = {}\n\n\t\tfor (const name of Object.keys(this.definitions.type))\n\t\t\tmodels[name] = getSchemaValidator(\n\t\t\t\tthis.definitions.typebox.Import(name as never)\n\t\t\t)\n\n\t\t// @ts-expect-error\n\t\tmodels.modules = this.definitions.typebox\n\n\t\treturn models as any\n\t}\n\n\tprivate add(\n\t\tmethod: HTTPMethod,\n\t\tpath: string,\n\t\thandle: Handler<any, any, any> | any,\n\t\tlocalHook?: AnyLocalHook,\n\t\toptions?: {\n\t\t\tallowMeta?: boolean\n\t\t\tskipPrefix?: boolean\n\t\t},\n\t\tstandaloneValidators?: InputSchema<string>[]\n\t) {\n\t\tconst skipPrefix = options?.skipPrefix ?? false\n\t\tconst allowMeta = options?.allowMeta ?? false\n\n\t\tlocalHook ??= {}\n\n\t\tif (standaloneValidators === undefined) {\n\t\t\tstandaloneValidators = []\n\n\t\t\tif (this.standaloneValidator.local)\n\t\t\t\tstandaloneValidators = standaloneValidators.concat(\n\t\t\t\t\tthis.standaloneValidator.local\n\t\t\t\t)\n\n\t\t\tif (this.standaloneValidator.scoped)\n\t\t\t\tstandaloneValidators = standaloneValidators.concat(\n\t\t\t\t\tthis.standaloneValidator.scoped\n\t\t\t\t)\n\n\t\t\tif (this.standaloneValidator.global)\n\t\t\t\tstandaloneValidators = standaloneValidators.concat(\n\t\t\t\t\tthis.standaloneValidator.global\n\t\t\t\t)\n\t\t}\n\n\t\tif (path !== '' && path.charCodeAt(0) !== 47) path = '/' + path\n\t\tif (this.config.prefix && !skipPrefix) path = this.config.prefix + path\n\n\t\tif (localHook?.type)\n\t\t\tswitch (localHook.type) {\n\t\t\t\tcase 'text':\n\t\t\t\t\tlocalHook.type = 'text/plain'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'json':\n\t\t\t\t\tlocalHook.type = 'application/json'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'formdata':\n\t\t\t\t\tlocalHook.type = 'multipart/form-data'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'urlencoded':\n\t\t\t\t\tlocalHook.type = 'application/x-www-form-urlencoded'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\tlocalHook.type = 'application/octet-stream'\n\t\t\t\t\tbreak\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\tconst instanceValidator = this.validator.getCandidate()\n\n\t\tconst cloned = {\n\t\t\tbody: localHook?.body ?? (instanceValidator?.body as any),\n\t\t\theaders: localHook?.headers ?? (instanceValidator?.headers as any),\n\t\t\tparams: localHook?.params ?? (instanceValidator?.params as any),\n\t\t\tquery: localHook?.query ?? (instanceValidator?.query as any),\n\t\t\tcookie: localHook?.cookie ?? (instanceValidator?.cookie as any),\n\t\t\tresponse:\n\t\t\t\tlocalHook?.response ?? (instanceValidator?.response as any)\n\t\t}\n\n\t\tconst shouldPrecompile =\n\t\t\tthis.config.precompile === true ||\n\t\t\t(typeof this.config.precompile === 'object' &&\n\t\t\t\tthis.config.precompile.compose === true)\n\n\t\tconst createValidator = () => {\n\t\t\tconst models = this.definitions.type\n\t\t\tconst dynamic = !this.config.aot\n\n\t\t\tconst normalize = this.config.normalize\n\t\t\tconst modules = this.definitions.typebox\n\n\t\t\tconst sanitize = () => this.config.sanitize\n\n\t\t\tconst cookieValidator = () => {\n\t\t\t\tif (cloned.cookie || standaloneValidators.find((x) => x.cookie))\n\t\t\t\t\treturn getCookieValidator({\n\t\t\t\t\t\tmodules,\n\t\t\t\t\t\tvalidator: cloned.cookie,\n\t\t\t\t\t\tdefaultConfig: this.config.cookie,\n\t\t\t\t\t\tconfig: cloned.cookie?.config ?? {},\n\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\tmodels,\n\t\t\t\t\t\tvalidators: standaloneValidators.map((x) => x.cookie),\n\t\t\t\t\t\tsanitize\n\t\t\t\t\t})\n\t\t\t}\n\n\t\t\treturn shouldPrecompile\n\t\t\t\t? {\n\t\t\t\t\t\tbody: getSchemaValidator(cloned.body, {\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tnormalize,\n\t\t\t\t\t\t\tadditionalCoerce: coercePrimitiveRoot(),\n\t\t\t\t\t\t\tvalidators: standaloneValidators.map((x) => x.body),\n\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t}),\n\t\t\t\t\t\theaders: getSchemaValidator(cloned.headers, {\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tadditionalProperties: true,\n\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\tadditionalCoerce: stringToStructureCoercions(),\n\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t(x) => x.headers\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tparams: getSchemaValidator(cloned.params, {\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\tadditionalCoerce: stringToStructureCoercions(),\n\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t(x) => x.params\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tquery: getSchemaValidator(cloned.query, {\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tnormalize,\n\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\tadditionalCoerce: stringToStructureCoercions(),\n\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t(x) => x.query\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tcookie: cookieValidator(),\n\t\t\t\t\t\tresponse: getResponseSchemaValidator(cloned.response, {\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tnormalize,\n\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t(x) => x.response\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t: ({\n\t\t\t\t\t\tcreateBody() {\n\t\t\t\t\t\t\tif (this.body) return this.body\n\n\t\t\t\t\t\t\treturn (this.body = getSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.body,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tnormalize,\n\t\t\t\t\t\t\t\t\tadditionalCoerce: coercePrimitiveRoot(),\n\t\t\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t\t\t(x) => x.body\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateHeaders() {\n\t\t\t\t\t\t\tif (this.headers) return this.headers\n\n\t\t\t\t\t\t\treturn (this.headers = getSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.headers,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tadditionalProperties: !normalize,\n\t\t\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\t\t\tadditionalCoerce:\n\t\t\t\t\t\t\t\t\t\tstringToStructureCoercions(),\n\t\t\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t\t\t(x) => x.headers\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateParams() {\n\t\t\t\t\t\t\tif (this.params) return this.params\n\n\t\t\t\t\t\t\treturn (this.params = getSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.params,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\t\t\tadditionalCoerce:\n\t\t\t\t\t\t\t\t\t\tstringToStructureCoercions(),\n\t\t\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t\t\t(x) => x.params\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateQuery() {\n\t\t\t\t\t\t\tif (this.query) return this.query\n\n\t\t\t\t\t\t\treturn (this.query = getSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.query,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\t\t\tadditionalCoerce:\n\t\t\t\t\t\t\t\t\t\tstringToStructureCoercions(),\n\t\t\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t\t\t(x) => x.query\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateCookie() {\n\t\t\t\t\t\t\tif (this.cookie) return this.cookie\n\n\t\t\t\t\t\t\treturn (this.cookie = cookieValidator())\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateResponse() {\n\t\t\t\t\t\t\tif (this.response) return this.response\n\n\t\t\t\t\t\t\treturn (this.response = getResponseSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.response,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tnormalize,\n\t\t\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t\t\t(x) => x.response\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any)\n\t\t}\n\n\t\tif (\n\t\t\tinstanceValidator.body ||\n\t\t\tinstanceValidator.cookie ||\n\t\t\tinstanceValidator.headers ||\n\t\t\tinstanceValidator.params ||\n\t\t\tinstanceValidator.query ||\n\t\t\tinstanceValidator.response\n\t\t)\n\t\t\tlocalHook = mergeHook(localHook, instanceValidator)\n\n\t\tif (localHook.tags) {\n\t\t\tif (!localHook.detail)\n\t\t\t\tlocalHook.detail = {\n\t\t\t\t\ttags: localHook.tags\n\t\t\t\t}\n\t\t\telse localHook.detail.tags = localHook.tags\n\t\t}\n\n\t\tif (isNotEmpty(this.config.detail))\n\t\t\tlocalHook.detail = mergeDeep(\n\t\t\t\tObject.assign({}, this.config.detail!),\n\t\t\t\tlocalHook.detail\n\t\t\t)\n\n\t\tthis.applyMacro(localHook)\n\n\t\tconst hooks = isNotEmpty(this.event)\n\t\t\t? mergeHook(this.event, localHookToLifeCycleStore(localHook))\n\t\t\t: lifeCycleToArray(localHookToLifeCycleStore(localHook))\n\n\t\tif (this.config.aot === false) {\n\t\t\tconst validator = createValidator()\n\n\t\t\tthis.router.dynamic.add(method, path, {\n\t\t\t\tvalidator,\n\t\t\t\thooks,\n\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\thandle,\n\t\t\t\troute: path\n\t\t\t})\n\n\t\t\tconst encoded = encodePath(path, { dynamic: true })\n\t\t\tif (path !== encoded) {\n\t\t\t\tthis.router.dynamic.add(method, encoded, {\n\t\t\t\t\tvalidator,\n\t\t\t\t\thooks,\n\t\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\t\thandle,\n\t\t\t\t\troute: path\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (this.config.strictPath === false) {\n\t\t\t\tconst loosePath = getLoosePath(path)\n\t\t\t\tthis.router.dynamic.add(method, loosePath, {\n\t\t\t\t\tvalidator,\n\t\t\t\t\thooks,\n\t\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\t\thandle,\n\t\t\t\t\troute: path\n\t\t\t\t})\n\n\t\t\t\tconst encoded = encodePath(loosePath)\n\t\t\t\tif (loosePath !== encoded)\n\t\t\t\t\tthis.router.dynamic.add(method, loosePath, {\n\t\t\t\t\t\tvalidator,\n\t\t\t\t\t\thooks,\n\t\t\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\t\t\thandle,\n\t\t\t\t\t\troute: path\n\t\t\t\t\t})\n\t\t\t}\n\n\t\t\tthis.router.history.push({\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\tcomposed: null,\n\t\t\t\thandler: handle,\n\t\t\t\tcompile: undefined as any,\n\t\t\t\thooks,\n\t\t\t\tstandaloneValidators\n\t\t\t})\n\n\t\t\treturn\n\t\t}\n\n\t\tconst adapter = this['~adapter'].handler\n\n\t\tconst nativeStaticHandler =\n\t\t\ttypeof handle !== 'function'\n\t\t\t\t? () => {\n\t\t\t\t\t\tconst fn = adapter.createNativeStaticHandler?.(\n\t\t\t\t\t\t\thandle,\n\t\t\t\t\t\t\thooks,\n\t\t\t\t\t\t\tthis.setHeaders\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\treturn fn instanceof Promise\n\t\t\t\t\t\t\t? fn.then((fn) => {\n\t\t\t\t\t\t\t\t\tif (fn) return fn\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t: fn?.()\n\t\t\t\t\t}\n\t\t\t\t: undefined\n\n\t\tconst useNativeStaticResponse =\n\t\t\tthis.config.nativeStaticResponse === true\n\n\t\tconst addResponsePath = (path: string) => {\n\t\t\tif (!useNativeStaticResponse || !nativeStaticHandler) return\n\n\t\t\tif (supportPerMethodInlineHandler) {\n\t\t\t\tif (this.router.response[path])\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tthis.router.response[path]![method] = nativeStaticHandler()\n\t\t\t\telse\n\t\t\t\t\tthis.router.response[path] = {\n\t\t\t\t\t\t[method]: nativeStaticHandler()\n\t\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.router.response[path] = nativeStaticHandler()\n\t\t\t}\n\t\t}\n\n\t\taddResponsePath(path)\n\n\t\tlet _compiled: ComposedHandler\n\t\tconst compile = () => {\n\t\t\tif (_compiled) return _compiled\n\n\t\t\treturn (_compiled = composeHandler({\n\t\t\t\tapp: this,\n\t\t\t\tpath,\n\t\t\t\tmethod,\n\t\t\t\thooks,\n\t\t\t\tvalidator: createValidator(),\n\t\t\t\thandler:\n\t\t\t\t\ttypeof handle !== 'function' &&\n\t\t\t\t\ttypeof adapter.createStaticHandler !== 'function'\n\t\t\t\t\t\t? () => handle\n\t\t\t\t\t\t: handle,\n\t\t\t\tallowMeta,\n\t\t\t\tinference: this.inference\n\t\t\t}))\n\t\t}\n\n\t\tlet oldIndex: number | undefined\n\t\tif (`${method}_${path}` in this.routeTree)\n\t\t\tfor (let i = 0; i < this.router.history.length; i++) {\n\t\t\t\tconst route = this.router.history[i]\n\t\t\t\tif (route.path === path && route.method === method) {\n\t\t\t\t\toldIndex = i\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\telse this.routeTree[`${method}_${path}`] = this.router.history.length\n\n\t\tconst index = oldIndex ?? this.router.history.length\n\n\t\tconst mainHandler = shouldPrecompile\n\t\t\t? compile()\n\t\t\t: (ctx: Context) =>\n\t\t\t\t\t(\n\t\t\t\t\t\t(this.router.history[index].composed =\n\t\t\t\t\t\t\tcompile!()) as ComposedHandler\n\t\t\t\t\t)(ctx)\n\n\t\tif (oldIndex !== undefined)\n\t\t\tthis.router.history[oldIndex] = Object.assign(\n\t\t\t\t{\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath,\n\t\t\t\t\tcomposed: mainHandler,\n\t\t\t\t\tcompile: compile!,\n\t\t\t\t\thandler: handle,\n\t\t\t\t\thooks\n\t\t\t\t},\n\t\t\t\tstandaloneValidators.length\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tstandaloneValidators\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined,\n\t\t\t\tlocalHook.webSocket\n\t\t\t\t\t? { websocket: localHook.websocket as any }\n\t\t\t\t\t: undefined\n\t\t\t)\n\t\telse\n\t\t\tthis.router.history.push(\n\t\t\t\tObject.assign(\n\t\t\t\t\t{\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tcomposed: mainHandler,\n\t\t\t\t\t\tcompile: compile!,\n\t\t\t\t\t\thandler: handle,\n\t\t\t\t\t\thooks\n\t\t\t\t\t},\n\t\t\t\t\tstandaloneValidators.length\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tstandaloneValidators\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: undefined,\n\t\t\t\t\tlocalHook.webSocket\n\t\t\t\t\t\t? { websocket: localHook.websocket as any }\n\t\t\t\t\t\t: undefined\n\t\t\t\t)\n\t\t\t)\n\n\t\tconst handler = {\n\t\t\thandler: shouldPrecompile ? mainHandler : undefined,\n\t\t\tcompile() {\n\t\t\t\treturn (this.handler = compile!())\n\t\t\t}\n\t\t}\n\n\t\tconst staticRouter = this.router.static\n\t\tconst isStaticPath =\n\t\t\tpath.indexOf(':') === -1 && path.indexOf('*') === -1\n\n\t\tif (method === 'WS') {\n\t\t\tif (isStaticPath) {\n\t\t\t\tif (path in staticRouter) staticRouter[path][method] = index\n\t\t\t\telse\n\t\t\t\t\tstaticRouter[path] = {\n\t\t\t\t\t\t[method]: index\n\t\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthis.router.http.add('WS', path, handler)\n\n\t\t\tif (!this.config.strictPath)\n\t\t\t\tthis.router.http.add('WS', getLoosePath(path), handler)\n\n\t\t\tconst encoded = encodePath(path, { dynamic: true })\n\t\t\tif (path !== encoded) this.router.http.add('WS', encoded, handler)\n\n\t\t\t// Static path doesn't need encode as it's done in compilation process\n\n\t\t\treturn\n\t\t}\n\n\t\tif (isStaticPath) {\n\t\t\tif (path in staticRouter) staticRouter[path][method] = index\n\t\t\telse\n\t\t\t\tstaticRouter[path] = {\n\t\t\t\t\t[method]: index\n\t\t\t\t} as const\n\n\t\t\tif (!this.config.strictPath) addResponsePath(getLoosePath(path))\n\n\t\t\t// Static path doesn't need encode as it's done in compilation process\n\t\t} else {\n\t\t\tthis.router.http.add(method, path, handler)\n\n\t\t\tconst staticHandler =\n\t\t\t\ttypeof handle !== 'function' &&\n\t\t\t\ttypeof adapter.createStaticHandler === 'function'\n\t\t\t\t\t? adapter.createStaticHandler(\n\t\t\t\t\t\t\thandle,\n\t\t\t\t\t\t\thooks,\n\t\t\t\t\t\t\tthis.setHeaders\n\t\t\t\t\t\t)\n\t\t\t\t\t: undefined\n\n\t\t\tif (!this.config.strictPath) {\n\t\t\t\tconst loosePath = getLoosePath(path)\n\n\t\t\t\taddResponsePath(loosePath)\n\t\t\t\tthis.router.http.add(method, loosePath, handler)\n\t\t\t}\n\n\t\t\tconst encoded = encodePath(path, { dynamic: true })\n\t\t\tif (path !== encoded) {\n\t\t\t\tthis.router.http.add(method, encoded, handler)\n\n\t\t\t\taddResponsePath(encoded)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate setHeaders?: Context['set']['headers']\n\theaders(header: Context['set']['headers'] | undefined) {\n\t\tif (!header) return this\n\n\t\tif (!this.setHeaders) this.setHeaders = {}\n\n\t\tthis.setHeaders = mergeDeep(this.setHeaders, header)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### start | Life cycle event\n\t * Called after server is ready for serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onStart(({ server }) => {\n\t *         console.log(\"Running at ${server?.url}:${server?.port}\")\n\t *     })\n\t *     .listen(3000)\n\t * ```\n\t */\n\tonStart(handler: MaybeArray<GracefulHandler<this>>) {\n\t\tthis.on('start', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### request | Life cycle event\n\t * Called on every new request is accepted\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onRequest(({ method, url }) => {\n\t *         saveToAnalytic({ method, url })\n\t *     })\n\t * ```\n\t */\n\tonRequest<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tPreHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: {}\n\t\t\t\t\tresolve: {}\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t) {\n\t\tthis.on('request', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### parse | Life cycle event\n\t * Callback function to handle body parsing\n\t *\n\t * If truthy value is returned, will be assigned to `context.body`\n\t * Otherwise will skip the callback and look for the next one.\n\t *\n\t * Equivalent to Express's body parser\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onParse((request, contentType) => {\n\t *         if(contentType === \"application/json\")\n\t *             return request.json()\n\t *     })\n\t * ```\n\t */\n\tonParse<const Schema extends RouteSchema>(\n\t\tparser: MaybeArray<\n\t\t\tBodyHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t>,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\tresolve: {}\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### parse | Life cycle event\n\t * Callback function to handle body parsing\n\t *\n\t * If truthy value is returned, will be assigned to `context.body`\n\t * Otherwise will skip the callback and look for the next one.\n\t *\n\t * Equivalent to Express's body parser\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onParse((request, contentType) => {\n\t *         if(contentType === \"application/json\")\n\t *             return request.json()\n\t *     })\n\t * ```\n\t */\n\tonParse<const Schema extends RouteSchema, const Type extends LifeCycleType>(\n\t\toptions: { as?: Type },\n\t\tparser: MaybeArray<\n\t\t\tBodyHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\t'global' extends Type\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\tPartial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t}\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\tonParse<const Parsers extends keyof Metadata['parser']>(\n\t\tparser: Parsers\n\t): this\n\n\tonParse(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function> | string,\n\t\thandler?: MaybeArray<Function>\n\t): unknown {\n\t\tif (!handler) {\n\t\t\tif (typeof options === 'string')\n\t\t\t\treturn this.on('parse', this['~parser'][options] as any)\n\n\t\t\treturn this.on('parse', options as any)\n\t\t}\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'parse',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### parse | Life cycle event\n\t * Callback function to handle body parsing\n\t *\n\t * If truthy value is returned, will be assigned to `context.body`\n\t * Otherwise will skip the callback and look for the next one.\n\t *\n\t * Equivalent to Express's body parser\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onParse((request, contentType) => {\n\t *         if(contentType === \"application/json\")\n\t *             return request.json()\n\t *     })\n\t * ```\n\t */\n\tparser<\n\t\tconst Parser extends string,\n\t\tconst Schema extends RouteSchema,\n\t\tconst Handler extends BodyHandler<\n\t\t\tMergeSchema<\n\t\t\t\tSchema,\n\t\t\t\tMergeSchema<\n\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t>,\n\t\t\t\tBasePath\n\t\t\t>,\n\t\t\t{\n\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\tstore: Singleton['store']\n\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\tVolatile['derive']\n\t\t\t\tresolve: {}\n\t\t\t}\n\t\t>\n\t>(\n\t\tname: Parser,\n\t\tparser: Handler\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\t{\n\t\t\tschema: Metadata['schema']\n\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t\tmacro: Metadata['macro']\n\t\t\tmacroFn: Metadata['macroFn']\n\t\t\tparser: Metadata['parser'] & { [K in Parser]: Handler }\n\t\t},\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis['~parser'][name] = parser as any\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### transform | Life cycle event\n\t * Assign or transform anything related to context before validation.\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onTransform(({ params }) => {\n\t *         if(params.id)\n\t *             params.id = +params.id\n\t *     })\n\t * ```\n\t */\n\tonTransform<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tTransformHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t>,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\tresolve: {}\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### transform | Life cycle event\n\t * Assign or transform anything related to context before validation.\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onTransform(({ params }) => {\n\t *         if(params.id)\n\t *             params.id = +params.id\n\t *     })\n\t * ```\n\t */\n\tonTransform<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tTransformHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\t'global' extends Type\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t}\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tPartial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\tonTransform(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('transform', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'transform',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tresolve<\n\t\tconst Resolver extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\tresolver: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>,\n\t\t\t\t\t\tBasePath\n\t\t\t\t\t> &\n\t\t\t\t\t\t'global' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t\t: {},\n\t\t\t\t\tSingleton &\n\t\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Resolver | void>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\tSingleton['resolve'] & ExcludeElysiaResponse<Resolver>\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Ephemeral['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Resolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\tstandaloneSchema: Ephemeral['standaloneSchema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Resolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tresolve<\n\t\tconst Resolver extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>\n\t\t\t| void\n\t>(\n\t\tresolver: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>,\n\t\t\t\t\t\tBasePath\n\t\t\t\t\t>,\n\t\t\t\t\tSingleton & {\n\t\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t},\n\t\t\t\t\tBasePath\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Resolver | void>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['derive']\n\t\t\tresolve: Prettify<\n\t\t\t\tVolatile['resolve'] & ExcludeElysiaResponse<Resolver>\n\t\t\t>\n\t\t\tschema: Volatile['schema']\n\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t}\n\t>\n\n\tresolve(\n\t\toptionsOrResolve: { as?: LifeCycleType } | Function,\n\t\tresolve?: Function\n\t) {\n\t\tif (!resolve) {\n\t\t\tresolve = optionsOrResolve as any\n\t\t\toptionsOrResolve = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'resolve',\n\t\t\tfn: resolve!\n\t\t}\n\n\t\treturn this.onBeforeHandle(optionsOrResolve as any, hook as any) as any\n\t}\n\n\tmapResolve<\n\t\tconst NewResolver extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>\n\t>(\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t) => MaybePromise<NewResolver | void>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['derive']\n\t\t\tresolve: ExcludeElysiaResponse<NewResolver>\n\t\t\tschema: Volatile['schema']\n\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t}\n\t>\n\n\tmapResolve<\n\t\tconst NewResolver extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t>,\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t) => MaybePromise<NewResolver | void>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: ExcludeElysiaResponse<NewResolver>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Ephemeral['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewResolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\tstandaloneSchema: Ephemeral['standaloneSchema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewResolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\tmapResolve(\n\t\toptionsOrResolve: Function | { as?: LifeCycleType },\n\t\tmapper?: Function\n\t) {\n\t\tif (!mapper) {\n\t\t\tmapper = optionsOrResolve as any\n\t\t\toptionsOrResolve = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'mapResolve',\n\t\t\tfn: mapper!\n\t\t}\n\n\t\treturn this.onBeforeHandle(optionsOrResolve as any, hook as any) as any\n\t}\n\n\t/**\n\t * ### Before Handle | Life cycle event\n\t * Execute after validation and before the main route handler.\n\t *\n\t * If truthy value is returned, will be assigned as `Response` and skip the main handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onBeforeHandle(({ params: { id }, status }) => {\n\t *         if(id && !isExisted(id)) {\n\t * \t           status(401)\n\t *\n\t *             return \"Unauthorized\"\n\t * \t       }\n\t *     })\n\t * ```\n\t */\n\tonBeforeHandle<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tOptionalHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### Before Handle | Life cycle event\n\t * Execute after validation and before the main route handler.\n\t *\n\t * If truthy value is returned, will be assigned as `Response` and skip the main handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onBeforeHandle(({ params: { id }, status }) => {\n\t *         if(id && !isExisted(id)) {\n\t * \t           status(401)\n\t *\n\t *             return \"Unauthorized\"\n\t * \t       }\n\t *     })\n\t * ```\n\t */\n\tonBeforeHandle<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tOptionalHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t}),\n\t\t\t\tBasePath\n\t\t\t>\n\t\t>\n\t): this\n\n\tonBeforeHandle(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('beforeHandle', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'beforeHandle',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tonAfterHandle<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tAfterHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tonAfterHandle<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: LifeCycleType },\n\t\thandler: MaybeArray<\n\t\t\tOptionalHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t>\n\t): this\n\n\tonAfterHandle(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('afterHandle', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'afterHandle',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .mapResponse((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tmapResponse<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tMapResponse<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .mapResponse((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tmapResponse<const Schema extends RouteSchema, Type extends LifeCycleType>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tMapResponse<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t>\n\t): this\n\n\tmapResponse(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('mapResponse', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'mapResponse',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### response | Life cycle event\n\t * Call AFTER main handler is executed\n\t * Good for analytic metrics\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterResponse(() => {\n\t *         cleanup()\n\t *     })\n\t * ```\n\t */\n\tonAfterResponse<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tAfterResponseHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### response | Life cycle event\n\t * Call AFTER main handler is executed\n\t * Good for analytic metrics\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterResponse(() => {\n\t *         cleanup()\n\t * \t   })\n\t * ```\n\t */\n\n\tonAfterResponse<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tAfterResponseHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t>\n\t): this\n\n\tonAfterResponse(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('afterResponse', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'afterResponse',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\ttrace<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<TraceHandler<Schema, Singleton>>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\ttrace<const Schema extends RouteSchema>(\n\t\toptions: { as?: LifeCycleType },\n\t\thandler: MaybeArray<TraceHandler<Schema, Singleton>>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\ttrace(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) {\n\t\t\thandler = options as MaybeArray<Function>\n\t\t\toptions = { as: 'local' }\n\t\t}\n\n\t\tif (!Array.isArray(handler)) handler = [handler] as Function[]\n\n\t\tfor (const fn of handler)\n\t\t\tthis.on(\n\t\t\t\toptions as { as?: LifeCycleType },\n\t\t\t\t'trace',\n\t\t\t\tcreateTracer(fn as any) as any\n\t\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error('CUSTOM_ERROR', CustomError)\n\t * ```\n\t */\n\terror<\n\t\tconst Errors extends Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tprototype: Error\n\t\t\t}\n\t\t>\n\t>(\n\t\terrors: Errors\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: Definitions['typebox']\n\t\t\terror: Definitions['error'] & {\n\t\t\t\t[K in keyof Errors]: Errors[K] extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: Errors[K]\n\t\t\t}\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error({\n\t *         CUSTOM_ERROR: CustomError\n\t *     })\n\t * ```\n\t */\n\terror<\n\t\tName extends string,\n\t\tconst CustomError extends {\n\t\t\tprototype: Error\n\t\t}\n\t>(\n\t\tname: Name,\n\t\terrors: CustomError\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: Definitions['typebox']\n\t\t\terror: Definitions['error'] & {\n\t\t\t\t[name in Name]: CustomError extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: CustomError\n\t\t\t}\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error('CUSTOM_ERROR', CustomError)\n\t * ```\n\t */\n\terror<const NewErrors extends Record<string, Error>>(\n\t\tmapper: (decorators: Definitions['error']) => NewErrors\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: Definitions['typebox']\n\t\t\terror: {\n\t\t\t\t[K in keyof NewErrors]: NewErrors[K] extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: never\n\t\t\t}\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\terror(\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tname:\n\t\t\t| string\n\t\t\t| Record<\n\t\t\t\t\tstring,\n\t\t\t\t\t{\n\t\t\t\t\t\tprototype: Error\n\t\t\t\t\t}\n\t\t\t  >\n\t\t\t| Function,\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\terror?: {\n\t\t\tprototype: Error\n\t\t}\n\t): AnyElysia {\n\t\tswitch (typeof name) {\n\t\t\tcase 'string':\n\t\t\t\t// @ts-ignore\n\t\t\t\terror.prototype[ERROR_CODE] = name\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tthis.definitions.error[name] = error\n\n\t\t\t\treturn this\n\n\t\t\tcase 'function':\n\t\t\t\tthis.definitions.error = name(this.definitions.error)\n\n\t\t\t\treturn this as any\n\t\t}\n\n\t\tfor (const [code, error] of Object.entries(name)) {\n\t\t\t// @ts-ignore\n\t\t\terror.prototype[ERROR_CODE] = code as any\n\n\t\t\tthis.definitions.error[code] = error as any\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tErrorHandler<\n\t\t\t\tDefinitions['error'],\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\tSingleton,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Scope extends LifeCycleType\n\t>(\n\t\toptions: { as?: Scope },\n\t\thandler: MaybeArray<\n\t\t\tErrorHandler<\n\t\t\t\tDefinitions['error'],\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\tScope extends 'global'\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\tresolve: Singleton['resolve'] &\n\t\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t}\n\t\t\t\t\t: Scope extends 'scoped'\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tEphemeral['derive']\n\t\t\t\t\t\t\t\tresolve: Singleton['resolve'] &\n\t\t\t\t\t\t\t\t\tEphemeral['resolve']\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: Singleton,\n\t\t\t\tScope extends 'global'\n\t\t\t\t\t? Ephemeral\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tderive: Partial<Ephemeral['derive']>\n\t\t\t\t\t\t\tresolve: Partial<Ephemeral['resolve']>\n\t\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\t\tstandaloneSchema: Ephemeral['standaloneSchema']\n\t\t\t\t\t\t},\n\t\t\t\tScope extends 'global'\n\t\t\t\t\t? Ephemeral\n\t\t\t\t\t: Scope extends 'scoped'\n\t\t\t\t\t\t? Ephemeral\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tderive: Partial<Ephemeral['derive']>\n\t\t\t\t\t\t\t\tresolve: Partial<Ephemeral['resolve']>\n\t\t\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\t\t\tstandaloneSchema: Ephemeral['standaloneSchema']\n\t\t\t\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('error', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'error',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### stop | Life cycle event\n\t * Called after server stop serving request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onStop((app) => {\n\t *         cleanup()\n\t *     })\n\t * ```\n\t */\n\tonStop(handler: MaybeArray<GracefulHandler<this>>) {\n\t\tthis.on('stop', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### on\n\t * Syntax sugar for attaching life cycle event by name\n\t *\n\t * Does the exact same thing as `.on[Event]()`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .on('error', ({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\ton<Event extends keyof LifeCycleStore>(\n\t\ttype: Event,\n\t\thandlers: MaybeArray<\n\t\t\tExtract<LifeCycleStore[Event], HookContainer[]>[0]['fn']\n\t\t>\n\t): this\n\n\t/**\n\t * ### on\n\t * Syntax sugar for attaching life cycle event by name\n\t *\n\t * Does the exact same thing as `.on[Event]()`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .on('error', ({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\ton<const Event extends keyof LifeCycleStore>(\n\t\toptions: { as?: LifeCycleType },\n\t\ttype: Event,\n\t\thandlers: MaybeArray<Extract<LifeCycleStore[Event], Function[]>[0]>\n\t): this\n\n\ton(\n\t\toptionsOrType: { as?: LifeCycleType } | string,\n\t\ttypeOrHandlers: MaybeArray<Function | HookContainer> | string,\n\t\thandlers?: MaybeArray<Function | HookContainer>\n\t) {\n\t\tlet type: keyof LifeCycleStore\n\n\t\tswitch (typeof optionsOrType) {\n\t\t\tcase 'string':\n\t\t\t\ttype = optionsOrType as any\n\t\t\t\thandlers = typeOrHandlers as any\n\n\t\t\t\tbreak\n\n\t\t\tcase 'object':\n\t\t\t\ttype = typeOrHandlers as any\n\n\t\t\t\tif (\n\t\t\t\t\t!Array.isArray(typeOrHandlers) &&\n\t\t\t\t\ttypeof typeOrHandlers === 'object'\n\t\t\t\t)\n\t\t\t\t\thandlers = typeOrHandlers\n\n\t\t\t\tbreak\n\t\t}\n\n\t\tif (Array.isArray(handlers)) handlers = fnToContainer(handlers)\n\t\telse {\n\t\t\tif (typeof handlers === 'function')\n\t\t\t\thandlers = [\n\t\t\t\t\t{\n\t\t\t\t\t\tfn: handlers\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\telse handlers = [handlers!]\n\t\t}\n\n\t\tconst handles = handlers as HookContainer[]\n\n\t\tfor (const handle of handles) {\n\t\t\thandle.scope =\n\t\t\t\ttypeof optionsOrType === 'string'\n\t\t\t\t\t? 'local'\n\t\t\t\t\t: (optionsOrType?.as ?? 'local')\n\n\t\t\t// @ts-expect-error\n\t\t\tif (type === 'resolve' || type === 'derive') handle.subType = type\n\t\t}\n\n\t\tif (type !== 'trace')\n\t\t\tthis.inference = sucrose(\n\t\t\t\t{\n\t\t\t\t\t[type]: handles.map((x) => x.fn)\n\t\t\t\t},\n\t\t\t\tthis.inference\n\t\t\t)\n\n\t\tfor (const handle of handles) {\n\t\t\tconst fn = asHookType(handle, 'global', { skipIfHasType: true })\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'start':\n\t\t\t\t\tthis.event.start ??= []\n\t\t\t\t\tthis.event.start.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'request':\n\t\t\t\t\tthis.event.request ??= []\n\t\t\t\t\tthis.event.request.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'parse':\n\t\t\t\t\tthis.event.parse ??= []\n\t\t\t\t\tthis.event.parse.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'transform':\n\t\t\t\t\tthis.event.transform ??= []\n\t\t\t\t\tthis.event.transform.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tcase 'derive':\n\t\t\t\t\tthis.event.transform ??= []\n\t\t\t\t\tthis.event.transform.push(\n\t\t\t\t\t\tfnToContainer(fn as any, 'derive') as any\n\t\t\t\t\t)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'beforeHandle':\n\t\t\t\t\tthis.event.beforeHandle ??= []\n\t\t\t\t\tthis.event.beforeHandle.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\t// eslint-disable-next-line sonarjs/no-duplicated-branches\n\t\t\t\tcase 'resolve':\n\t\t\t\t\tthis.event.beforeHandle ??= []\n\t\t\t\t\tthis.event.beforeHandle.push(\n\t\t\t\t\t\tfnToContainer(fn as any, 'resolve') as any\n\t\t\t\t\t)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'afterHandle':\n\t\t\t\t\tthis.event.afterHandle ??= []\n\t\t\t\t\tthis.event.afterHandle.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'mapResponse':\n\t\t\t\t\tthis.event.mapResponse ??= []\n\t\t\t\t\tthis.event.mapResponse.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'afterResponse':\n\t\t\t\t\tthis.event.afterResponse ??= []\n\t\t\t\t\tthis.event.afterResponse.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'trace':\n\t\t\t\t\tthis.event.trace ??= []\n\t\t\t\t\tthis.event.trace.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'error':\n\t\t\t\t\tthis.event.error ??= []\n\t\t\t\t\tthis.event.error.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'stop':\n\t\t\t\t\tthis.event.stop ??= []\n\t\t\t\t\tthis.event.stop.push(fn as any)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\tas(type: 'global'): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Prettify<\n\t\t\t\tSingleton['derive'] & Ephemeral['derive'] & Volatile['derive']\n\t\t\t>\n\t\t\tresolve: Prettify<\n\t\t\t\tSingleton['resolve'] &\n\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve']\n\t\t\t>\n\t\t},\n\t\tDefinitions,\n\t\t{\n\t\t\tschema: MergeSchema<\n\t\t\t\tMergeSchema<Volatile['schema'], Ephemeral['schema']>,\n\t\t\t\tMetadata['schema']\n\t\t\t>\n\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t\tmacro: Metadata['macro']\n\t\t\tmacroFn: Metadata['macroFn']\n\t\t\tparser: Metadata['parser']\n\t\t},\n\t\tRoutes,\n\t\t{\n\t\t\tderive: {}\n\t\t\tresolve: {}\n\t\t\tschema: {}\n\t\t\tstandaloneSchema: {}\n\t\t},\n\t\t{\n\t\t\tderive: {}\n\t\t\tresolve: {}\n\t\t\tschema: {}\n\t\t\tstandaloneSchema: {}\n\t\t}\n\t>\n\n\tas(type: 'scoped'): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\t{\n\t\t\tderive: Prettify<Ephemeral['derive'] & Volatile['derive']>\n\t\t\tresolve: Prettify<Ephemeral['resolve'] & Volatile['resolve']>\n\t\t\tschema: MergeSchema<Volatile['schema'], Ephemeral['schema']>\n\t\t\tstandaloneSchema: PrettifySchema<\n\t\t\t\tVolatile['standaloneSchema'] & Ephemeral['standaloneSchema']\n\t\t\t>\n\t\t},\n\t\t{\n\t\t\tderive: {}\n\t\t\tresolve: {}\n\t\t\tschema: {}\n\t\t\tstandaloneSchema: {}\n\t\t}\n\t>\n\n\tas(type: 'global' | 'scoped') {\n\t\tpromoteEvent(this.event.parse, type)\n\t\tpromoteEvent(this.event.transform, type)\n\t\tpromoteEvent(this.event.beforeHandle, type)\n\t\tpromoteEvent(this.event.afterHandle, type)\n\t\tpromoteEvent(this.event.mapResponse, type)\n\t\tpromoteEvent(this.event.afterResponse, type)\n\t\tpromoteEvent(this.event.trace, type)\n\t\tpromoteEvent(this.event.error, type)\n\n\t\tif (type === 'scoped') {\n\t\t\tthis.validator.scoped = mergeSchemaValidator(\n\t\t\t\tthis.validator.scoped,\n\t\t\t\tthis.validator.local\n\t\t\t)\n\t\t\tthis.validator.local = null\n\t\t} else if (type === 'global') {\n\t\t\tthis.validator.global = mergeSchemaValidator(\n\t\t\t\tthis.validator.global,\n\t\t\t\tmergeSchemaValidator(\n\t\t\t\t\tthis.validator.scoped,\n\t\t\t\t\tthis.validator.local\n\t\t\t\t) as SchemaValidator\n\t\t\t) as SchemaValidator\n\n\t\t\tthis.validator.scoped = null\n\t\t\tthis.validator.local = null\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\tgroup<const Prefix extends string, const NewElysia extends AnyElysia>(\n\t\tprefix: Prefix,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tJoinPath<BasePath, Prefix>,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: MergeSchema<\n\t\t\t\t\t\tUnwrapRoute<\n\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\tDefinitions['typebox'],\n\t\t\t\t\t\t\tJoinPath<BasePath, Prefix>\n\t\t\t\t\t\t>,\n\t\t\t\t\t\tMetadata['schema']\n\t\t\t\t\t>\n\t\t\t\t\tstandaloneSchema: Prettify<\n\t\t\t\t\t\tUnwrapRoute<\n\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\tDefinitions['typebox'],\n\t\t\t\t\t\t\tJoinPath<BasePath, Prefix>\n\t\t\t\t\t\t> &\n\t\t\t\t\t\t\tMetadata['standaloneSchema']\n\t\t\t\t\t>\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t\tparser: Metadata['parser']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tPrettify<Routes & NewElysia['~Routes']>,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tgroup<\n\t\tconst Prefix extends string,\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Input extends InputSchema<keyof Definitions['typebox'] & string>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tInput,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Prefix>\n\t\t\t>,\n\t\t\tMetadata['schema']\n\t\t>,\n\t\tconst Resolutions extends MaybeArray<\n\t\t\tResolveHandler<\n\t\t\t\tSchema,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t>(\n\t\tprefix: Prefix,\n\t\tschema: LocalHook<\n\t\t\tInput,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\tkeyof Metadata['parser']\n\t\t>,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tJoinPath<BasePath, Prefix>,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Prettify<\n\t\t\t\t\t\tSingleton['derive'] &\n\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t>\n\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\tSingleton['resolve'] &\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\tResolveResolutions<Resolutions>\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: Prettify<Schema>\n\t\t\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t\tparser: Metadata['parser']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes & NewElysia['~Routes'],\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### group\n\t * Encapsulate and group path with prefix\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .group('/v1', app => app\n\t *         .get('/', () => 'Hi')\n\t *         .get('/name', () => 'Elysia')\n\t *     })\n\t * ```\n\t */\n\tgroup(\n\t\tprefix: string,\n\t\tschemaOrRun: AnyLocalHook | ((group: AnyElysia) => AnyElysia),\n\t\trun?: (group: AnyElysia) => AnyElysia\n\t): AnyElysia {\n\t\tconst instance = new Elysia({\n\t\t\t...this.config,\n\t\t\tprefix: ''\n\t\t})\n\n\t\tinstance.singleton = { ...this.singleton }\n\t\tinstance.definitions = { ...this.definitions }\n\t\tinstance.getServer = () => this.getServer()\n\t\tinstance.inference = cloneInference(this.inference)\n\t\tinstance.extender = { ...this.extender }\n\t\tinstance['~parser'] = this['~parser']\n\t\tinstance.standaloneValidator = {\n\t\t\tlocal: [...(this.standaloneValidator.local ?? [])],\n\t\t\tscoped: [...(this.standaloneValidator.scoped ?? [])],\n\t\t\tglobal: [...(this.standaloneValidator.global ?? [])]\n\t\t}\n\n\t\tconst isSchema = typeof schemaOrRun === 'object'\n\t\tconst sandbox = (isSchema ? run! : schemaOrRun)(instance)\n\t\tthis.singleton = mergeDeep(this.singleton, instance.singleton) as any\n\t\tthis.definitions = mergeDeep(this.definitions, instance.definitions)\n\n\t\tif (sandbox.event.request?.length)\n\t\t\tthis.event.request = [\n\t\t\t\t...(this.event.request || []),\n\t\t\t\t...((sandbox.event.request || []) as any)\n\t\t\t]\n\n\t\tif (sandbox.event.mapResponse?.length)\n\t\t\tthis.event.mapResponse = [\n\t\t\t\t...(this.event.mapResponse || []),\n\t\t\t\t...((sandbox.event.mapResponse || []) as any)\n\t\t\t]\n\n\t\tthis.model(sandbox.definitions.type)\n\n\t\tObject.values(instance.router.history).forEach(\n\t\t\t({ method, path, handler, hooks, standaloneValidators }) => {\n\t\t\t\tpath = (isSchema ? '' : this.config.prefix) + prefix + path\n\n\t\t\t\tif (isSchema) {\n\t\t\t\t\tconst hook = schemaOrRun\n\t\t\t\t\tconst localHook = hooks as AnyLocalHook\n\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\thandler,\n\t\t\t\t\t\tmergeHook(hook, {\n\t\t\t\t\t\t\t...(localHook || {}),\n\t\t\t\t\t\t\terror: !localHook.error\n\t\t\t\t\t\t\t\t? sandbox.event.error\n\t\t\t\t\t\t\t\t: Array.isArray(localHook.error)\n\t\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t\t...(localHook.error || {}),\n\t\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error || {})\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t: [\n\t\t\t\t\t\t\t\t\t\t\tlocalHook.error,\n\t\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error || {})\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tstandaloneValidators\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\thandler,\n\t\t\t\t\t\tmergeHook(hooks as AnyLocalHook, {\n\t\t\t\t\t\t\terror: sandbox.event.error\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tskipPrefix: true\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstandaloneValidators\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox'], BasePath>,\n\t\t\tMetadata['schema']\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst MacroContext extends MacroToContext<\n\t\t\tMetadata['macroFn'],\n\t\t\tNoInfer<Macro>\n\t\t>,\n\t\tconst GuardType extends GuardSchemaType,\n\t\tconst AsType extends LifeCycleType\n\t>(\n\t\thook: {\n\t\t\t/**\n\t\t\t * @default 'override'\n\t\t\t */\n\t\t\tas?: AsType\n\t\t\t/**\n\t\t\t * @default 'standalone'\n\t\t\t * @since 1.3.0\n\t\t\t */\n\t\t\tschema?: GuardType\n\t\t} & LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Or<\n\t\tGuardSchemaType extends GuardType ? true : false,\n\t\tGuardType extends 'override' ? true : false\n\t> extends true\n\t\t? Or<\n\t\t\t\tLifeCycleType extends AsType ? true : false,\n\t\t\t\tAsType extends 'local' ? true : false\n\t\t\t> extends true\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<Volatile['resolve'] & MacroContext>\n\t\t\t\t\t\tschema: Prettify<\n\t\t\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\t\t\tUnwrapRoute<\n\t\t\t\t\t\t\t\t\tLocalSchema,\n\t\t\t\t\t\t\t\t\tDefinitions['typebox']\n\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\tMetadata['schema']\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t: AsType extends 'global'\n\t\t\t\t? Elysia<\n\t\t\t\t\t\tBasePath,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\t\tSingleton['resolve'] & MacroContext\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t},\n\t\t\t\t\t\tDefinitions,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tschema: Prettify<\n\t\t\t\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\t\t\t\tUnwrapRoute<\n\t\t\t\t\t\t\t\t\t\tLocalSchema,\n\t\t\t\t\t\t\t\t\t\tDefinitions['typebox'],\n\t\t\t\t\t\t\t\t\t\tBasePath\n\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\tMetadata['schema']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t\t\t\tparser: Metadata['parser']\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes,\n\t\t\t\t\t\tEphemeral,\n\t\t\t\t\t\tVolatile\n\t\t\t\t\t>\n\t\t\t\t: Elysia<\n\t\t\t\t\t\tBasePath,\n\t\t\t\t\t\tSingleton,\n\t\t\t\t\t\tDefinitions,\n\t\t\t\t\t\tMetadata,\n\t\t\t\t\t\tRoutes,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tderive: Ephemeral['derive']\n\t\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\t\tEphemeral['resolve'] & MacroContext\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\tschema: Prettify<\n\t\t\t\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\t\t\t\tUnwrapRoute<\n\t\t\t\t\t\t\t\t\t\tLocalSchema,\n\t\t\t\t\t\t\t\t\t\tDefinitions['typebox']\n\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\tMetadata['schema'] & Ephemeral['schema']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\tstandaloneSchema: Ephemeral['standaloneSchema']\n\t\t\t\t\t\t},\n\t\t\t\t\t\tVolatile\n\t\t\t\t\t>\n\t\t: Or<\n\t\t\t\t\tLifeCycleType extends AsType ? true : false,\n\t\t\t\t\tAsType extends 'local' ? true : false\n\t\t\t  > extends true\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<Volatile['resolve'] & MacroContext>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t\tstandaloneSchema: Volatile['standaloneSchema'] &\n\t\t\t\t\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox']>\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t: AsType extends 'global'\n\t\t\t\t? Elysia<\n\t\t\t\t\t\tBasePath,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\t\tSingleton['resolve'] & MacroContext\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t},\n\t\t\t\t\t\tDefinitions,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tschema: Metadata['schema']\n\t\t\t\t\t\t\tstandaloneSchema: UnwrapRoute<\n\t\t\t\t\t\t\t\tLocalSchema,\n\t\t\t\t\t\t\t\tDefinitions['typebox'],\n\t\t\t\t\t\t\t\tBasePath\n\t\t\t\t\t\t\t> &\n\t\t\t\t\t\t\t\tMetadata['standaloneSchema']\n\t\t\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t\t\t\tparser: Metadata['parser']\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes,\n\t\t\t\t\t\tEphemeral,\n\t\t\t\t\t\tVolatile\n\t\t\t\t\t>\n\t\t\t\t: Elysia<\n\t\t\t\t\t\tBasePath,\n\t\t\t\t\t\tSingleton,\n\t\t\t\t\t\tDefinitions,\n\t\t\t\t\t\tMetadata,\n\t\t\t\t\t\tRoutes,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tderive: Ephemeral['derive']\n\t\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\t\tEphemeral['resolve'] & MacroContext\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\t\tstandaloneSchema: Ephemeral['standaloneSchema'] &\n\t\t\t\t\t\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox']>\n\t\t\t\t\t\t},\n\t\t\t\t\t\tVolatile\n\t\t\t\t\t>\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox'], BasePath>,\n\t\t\tMetadata['schema']\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst MacroContext extends MacroToContext<\n\t\t\tMetadata['macroFn'],\n\t\t\tNoInfer<Macro>\n\t\t>\n\t>(\n\t\thook: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroContext\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['derive']\n\t\t\tresolve: Prettify<Volatile['resolve'] & MacroContext>\n\t\t\tschema: Prettify<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox'], BasePath>,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t\t>\n\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t}\n\t>\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox'], BasePath>,\n\t\t\tMetadata['schema']\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst MacroContext extends MacroToContext<\n\t\t\tMetadata['macroFn'],\n\t\t\tNoInfer<Macro>\n\t\t>\n\t>(\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: Singleton['resolve'] & MacroContext\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: Prettify<Schema>\n\t\t\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t\tparser: Metadata['parser']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tPrettify<Routes & NewElysia['~Routes']>,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox'], BasePath>,\n\t\t\tMetadata['schema']\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst MacroContext extends MacroToContext<\n\t\t\tMetadata['macroFn'],\n\t\t\tNoInfer<Macro>\n\t\t>\n\t>(\n\t\tschema: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: Prettify<Singleton['resolve'] & MacroContext>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: Prettify<Schema>\n\t\t\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t\tparser: Metadata['parser']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tPrettify<Routes & NewElysia['~Routes']>,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['derive']\n\t\t\tresolve: Prettify<Volatile['resolve'] & MacroContext>\n\t\t\tschema: Volatile['schema']\n\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t}\n\t>\n\n\t/**\n\t * ### guard\n\t * Encapsulate and pass hook into all child handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .guard({\n\t *          schema: {\n\t *              body: t.Object({\n\t *                  username: t.String(),\n\t *                  password: t.String()\n\t *              })\n\t *          }\n\t *     }, app => app\n\t *         .get(\"/\", () => 'Hi')\n\t *         .get(\"/name\", () => 'Elysia')\n\t *     })\n\t * ```\n\t */\n\tguard(\n\t\thook:\n\t\t\t| (AnyLocalHook & {\n\t\t\t\t\tas: LifeCycleType\n\t\t\t  })\n\t\t\t| ((group: AnyElysia) => AnyElysia),\n\t\trun?: (group: AnyElysia) => AnyElysia\n\t): AnyElysia {\n\t\tif (!run) {\n\t\t\tif (typeof hook === 'object') {\n\t\t\t\tthis.applyMacro(hook)\n\n\t\t\t\tif (hook.detail) {\n\t\t\t\t\tif (this.config.detail)\n\t\t\t\t\t\tthis.config.detail = mergeDeep(\n\t\t\t\t\t\t\tObject.assign({}, this.config.detail),\n\t\t\t\t\t\t\thook.detail\n\t\t\t\t\t\t)\n\t\t\t\t\telse this.config.detail = hook.detail\n\t\t\t\t}\n\n\t\t\t\tif (hook.tags) {\n\t\t\t\t\tif (!this.config.detail)\n\t\t\t\t\t\tthis.config.detail = {\n\t\t\t\t\t\t\ttags: hook.tags\n\t\t\t\t\t\t}\n\t\t\t\t\telse this.config.detail.tags = hook.tags\n\t\t\t\t}\n\n\t\t\t\tconst type: LifeCycleType = hook.as ?? 'local'\n\n\t\t\t\tif (hook.schema === 'standalone') {\n\t\t\t\t\tif (!this.standaloneValidator[type])\n\t\t\t\t\t\tthis.standaloneValidator[type] = []\n\n\t\t\t\t\tconst response =\n\t\t\t\t\t\thook?.response ||\n\t\t\t\t\t\ttypeof hook?.response === 'string' ||\n\t\t\t\t\t\t(hook?.response && Kind in hook.response)\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t200: hook.response\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: hook?.response\n\n\t\t\t\t\tthis.standaloneValidator[type].push({\n\t\t\t\t\t\tbody: hook.body,\n\t\t\t\t\t\theaders: hook.headers,\n\t\t\t\t\t\tparams: hook.params,\n\t\t\t\t\t\tquery: hook.query,\n\t\t\t\t\t\tresponse,\n\t\t\t\t\t\tcookie: hook.cookie\n\t\t\t\t\t})\n\n\t\t\t\t\treturn this\n\t\t\t\t}\n\n\t\t\t\tthis.validator[type] = {\n\t\t\t\t\tbody: hook.body ?? this.validator[type]?.body,\n\t\t\t\t\theaders: hook.headers ?? this.validator[type]?.headers,\n\t\t\t\t\tparams: hook.params ?? this.validator[type]?.params,\n\t\t\t\t\tquery: hook.query ?? this.validator[type]?.query,\n\t\t\t\t\tresponse: hook.response ?? this.validator[type]?.response,\n\t\t\t\t\tcookie: hook.cookie ?? this.validator[type]?.cookie\n\t\t\t\t}\n\n\t\t\t\tif (hook.parse) this.on({ as: type }, 'parse', hook.parse)\n\t\t\t\tif (hook.transform)\n\t\t\t\t\tthis.on({ as: type }, 'transform', hook.transform)\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (hook.derive) this.on({ as: type }, 'derive', hook.derive)\n\t\t\t\tif (hook.beforeHandle)\n\t\t\t\t\tthis.on({ as: type }, 'beforeHandle', hook.beforeHandle)\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (hook.resolve) this.on({ as: type }, 'resolve', hook.resolve)\n\t\t\t\tif (hook.afterHandle)\n\t\t\t\t\tthis.on({ as: type }, 'afterHandle', hook.afterHandle)\n\t\t\t\tif (hook.mapResponse)\n\t\t\t\t\tthis.on({ as: type }, 'mapResponse', hook.mapResponse)\n\t\t\t\tif (hook.afterResponse)\n\t\t\t\t\tthis.on({ as: type }, 'afterResponse', hook.afterResponse)\n\t\t\t\tif (hook.error) this.on({ as: type }, 'error', hook.error)\n\n\t\t\t\treturn this\n\t\t\t}\n\n\t\t\treturn this.guard({} as any, hook)\n\t\t}\n\n\t\tconst instance = new Elysia({\n\t\t\t...this.config,\n\t\t\tprefix: ''\n\t\t})\n\t\tinstance.singleton = { ...this.singleton }\n\t\tinstance.definitions = { ...this.definitions }\n\t\tinstance.inference = cloneInference(this.inference)\n\t\tinstance.extender = { ...this.extender }\n\n\t\tconst sandbox = run(instance)\n\t\tthis.singleton = mergeDeep(this.singleton, instance.singleton) as any\n\t\tthis.definitions = mergeDeep(this.definitions, instance.definitions)\n\n\t\t// ? Inject getServer for websocket and trace (important, do not remove)\n\t\tsandbox.getServer = () => this.server\n\n\t\tif (sandbox.event.request?.length)\n\t\t\tthis.event.request = [\n\t\t\t\t...(this.event.request || []),\n\t\t\t\t...(sandbox.event.request || [])\n\t\t\t]\n\n\t\tif (sandbox.event.mapResponse?.length)\n\t\t\tthis.event.mapResponse = [\n\t\t\t\t...(this.event.mapResponse || []),\n\t\t\t\t...(sandbox.event.mapResponse || [])\n\t\t\t]\n\n\t\tthis.model(sandbox.definitions.type)\n\n\t\tObject.values(instance.router.history).forEach(\n\t\t\t({ method, path, handler, hooks: localHook }) => {\n\t\t\t\tthis.add(\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath,\n\t\t\t\t\thandler,\n\t\t\t\t\tmergeHook(hook as AnyLocalHook, {\n\t\t\t\t\t\t...((localHook || {}) as AnyLocalHook),\n\t\t\t\t\t\terror: !localHook.error\n\t\t\t\t\t\t\t? sandbox.event.error\n\t\t\t\t\t\t\t: Array.isArray(localHook.error)\n\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t...(localHook.error || {}),\n\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error || [])\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t: [\n\t\t\t\t\t\t\t\t\t\tlocalHook.error,\n\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error || [])\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * Inline fn\n\t */\n\tuse<\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Param extends AnyElysia = this\n\t>(\n\t\tplugin: (app: Param) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\t// @ts-expect-error - This is truly ideal\n\t\tPrettify2<Singleton & NewElysia['~Singleton']>,\n\t\tPrettify<Definitions & NewElysia['~Definitions']>,\n\t\tPrettify2<Metadata & NewElysia['~Metadata']>,\n\t\tBasePath extends ``\n\t\t\t? Routes & NewElysia['~Routes']\n\t\t\t: Routes & CreateEden<BasePath, NewElysia['~Routes']>,\n\t\tPrettify2<Ephemeral & NewElysia['~Ephemeral']>,\n\t\tPrettify2<Volatile & NewElysia['~Volatile']>\n\t>\n\n\t/**\n\t * Inline async fn\n\t */\n\tuse<\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Param extends AnyElysia = this\n\t>(\n\t\tplugin:\n\t\t\t| ((app: Param) => Promise<NewElysia>)\n\t\t\t| Promise<(app: Param) => NewElysia>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Prettify<\n\t\t\t\tSingleton['decorator'] &\n\t\t\t\t\tPartial<NewElysia['~Singleton']['decorator']>\n\t\t\t>\n\t\t\tstore: Prettify<\n\t\t\t\tSingleton['store'] & Partial<NewElysia['~Singleton']['store']>\n\t\t\t>\n\t\t\tderive: Prettify<\n\t\t\t\tSingleton['derive'] & Partial<NewElysia['~Singleton']['derive']>\n\t\t\t>\n\t\t\tresolve: Prettify<\n\t\t\t\tSingleton['resolve'] &\n\t\t\t\t\tPartial<NewElysia['~Singleton']['resolve']>\n\t\t\t>\n\t\t},\n\t\t{\n\t\t\terror: Prettify<\n\t\t\t\tDefinitions['error'] & NewElysia['~Definitions']['error']\n\t\t\t>\n\t\t\ttypebox: Prettify<\n\t\t\t\tDefinitions['typebox'] & NewElysia['~Definitions']['typebox']\n\t\t\t>\n\t\t},\n\t\t// @ts-expect-error this is truly ideal\n\t\tPrettify2<Metadata & NewElysia['~Metadata']>,\n\t\tBasePath extends ``\n\t\t\t? Routes & NewElysia['~Routes']\n\t\t\t: Routes & CreateEden<BasePath, NewElysia['~Routes']>,\n\t\t{\n\t\t\tschema: Prettify<\n\t\t\t\tEphemeral['schema'] & Partial<NewElysia['~Ephemeral']['schema']>\n\t\t\t>\n\t\t\tstandaloneSchema: PrettifySchema<\n\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tPartial<NewElysia['~Ephemeral']['standaloneSchema']>\n\t\t\t>\n\t\t\tresolve: Prettify<\n\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\tPartial<NewElysia['~Ephemeral']['resolve']>\n\t\t\t>\n\t\t\tderive: Prettify<\n\t\t\t\tEphemeral['derive'] & Partial<NewElysia['~Ephemeral']['derive']>\n\t\t\t>\n\t\t},\n\t\t{\n\t\t\tschema: Prettify<\n\t\t\t\tVolatile['schema'] & Partial<NewElysia['~Volatile']['schema']>\n\t\t\t>\n\t\t\tstandaloneSchema: PrettifySchema<\n\t\t\t\tVolatile['standaloneSchema'] &\n\t\t\t\t\tPartial<NewElysia['~Volatile']['standaloneSchema']>\n\t\t\t>\n\t\t\tresolve: Prettify<\n\t\t\t\tVolatile['resolve'] & Partial<NewElysia['~Volatile']['resolve']>\n\t\t\t>\n\t\t\tderive: Prettify<\n\t\t\t\tVolatile['derive'] & Partial<NewElysia['~Volatile']['derive']>\n\t\t\t>\n\t\t}\n\t>\n\n\t/**\n\t * Entire Instance\n\t **/\n\tuse<const NewElysia extends AnyElysia>(\n\t\tinstance: MaybePromise<NewElysia>\n\t): Elysia<\n\t\tBasePath,\n\t\t// @ts-expect-error - This is truly ideal\n\t\tPrettify2<Singleton & NewElysia['~Singleton']>,\n\t\tPrettify2<Definitions & NewElysia['~Definitions']>,\n\t\tPrettify2<Metadata & NewElysia['~Metadata']>,\n\t\tBasePath extends ``\n\t\t\t? Routes & NewElysia['~Routes']\n\t\t\t: Routes & CreateEden<BasePath, NewElysia['~Routes']>,\n\t\tEphemeral,\n\t\tPrettify2<Volatile & NewElysia['~Ephemeral']>\n\t>\n\n\t/**\n\t * Entire multiple Instance\n\t **/\n\tuse<const Instances extends AnyElysia[]>(\n\t\tinstance: MaybePromise<Instances>\n\t): MergeElysiaInstances<Instances, BasePath>\n\n\t/**\n\t * Import fn\n\t */\n\tuse<const NewElysia extends AnyElysia>(\n\t\tplugin: Promise<{\n\t\t\tdefault: (elysia: AnyElysia) => MaybePromise<NewElysia>\n\t\t}>\n\t): Elysia<\n\t\tBasePath,\n\t\t// @ts-expect-error - This is truly ideal\n\t\tPrettify2<Singleton & NewElysia['~Singleton']>,\n\t\t{\n\t\t\terror: Prettify<\n\t\t\t\tDefinitions['error'] & NewElysia['~Definitions']['error']\n\t\t\t>\n\t\t\ttypebox: Prettify<\n\t\t\t\tDefinitions['typebox'] & NewElysia['~Definitions']['typebox']\n\t\t\t>\n\t\t},\n\t\tPrettify2<Metadata & NewElysia['~Metadata']>,\n\t\tBasePath extends ``\n\t\t\t? Routes & NewElysia['~Routes']\n\t\t\t: Routes & CreateEden<BasePath, NewElysia['~Routes']>,\n\t\tPrettify2<Ephemeral & NewElysia['~Ephemeral']>,\n\t\tPrettify2<Volatile & NewElysia['~Volatile']>\n\t>\n\n\t/**\n\t * Import entire instance\n\t */\n\tuse<const LazyLoadElysia extends AnyElysia>(\n\t\tplugin: Promise<{\n\t\t\tdefault: LazyLoadElysia\n\t\t}>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Prettify<\n\t\t\t\tSingleton['decorator'] &\n\t\t\t\t\tPartial<LazyLoadElysia['~Singleton']['decorator']>\n\t\t\t>\n\t\t\tstore: Prettify<\n\t\t\t\tSingleton['store'] &\n\t\t\t\t\tPartial<LazyLoadElysia['~Singleton']['store']>\n\t\t\t>\n\t\t\tderive: Prettify<\n\t\t\t\tSingleton['derive'] &\n\t\t\t\t\tPartial<LazyLoadElysia['~Singleton']['derive']>\n\t\t\t>\n\t\t\tresolve: Prettify<\n\t\t\t\tSingleton['resolve'] &\n\t\t\t\t\tPartial<LazyLoadElysia['~Singleton']['resolve']>\n\t\t\t>\n\t\t},\n\t\t{\n\t\t\terror: Prettify<\n\t\t\t\tDefinitions['error'] & LazyLoadElysia['~Definitions']['error']\n\t\t\t>\n\t\t\ttypebox: Prettify<\n\t\t\t\tDefinitions['typebox'] &\n\t\t\t\t\tLazyLoadElysia['~Definitions']['typebox']\n\t\t\t>\n\t\t},\n\t\t// @ts-expect-error - This is truly ideal\n\t\tPrettify2<Metadata & LazyLoadElysia['~Metadata']>,\n\t\tBasePath extends ``\n\t\t\t? Routes & LazyLoadElysia['~Routes']\n\t\t\t: Routes & CreateEden<BasePath, LazyLoadElysia['~Routes']>,\n\t\tEphemeral,\n\t\tPrettify2<{\n\t\t\tschema: Prettify<\n\t\t\t\tVolatile['schema'] &\n\t\t\t\t\tPartial<LazyLoadElysia['~Ephemeral']['schema']>\n\t\t\t>\n\t\t\tstandaloneSchema: PrettifySchema<\n\t\t\t\tVolatile['standaloneSchema'] &\n\t\t\t\t\tPartial<LazyLoadElysia['~Ephemeral']['standaloneSchema']>\n\t\t\t>\n\t\t\tresolve: Prettify<\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tPartial<LazyLoadElysia['~Ephemeral']['resolve']>\n\t\t\t>\n\t\t\tderive: Prettify<\n\t\t\t\tVolatile['derive'] &\n\t\t\t\t\tPartial<LazyLoadElysia['~Ephemeral']['derive']>\n\t\t\t>\n\t\t}>\n\t>\n\n\t/**\n\t * ### use\n\t * Merge separate logic of Elysia with current\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * const plugin = (app: Elysia) => app\n\t *     .get('/plugin', () => 'hi')\n\t *\n\t * new Elysia()\n\t *     .use(plugin)\n\t * ```\n\t */\n\tuse(\n\t\tplugin:\n\t\t\t| MaybeArray<MaybePromise<AnyElysia>>\n\t\t\t| MaybePromise<\n\t\t\t\t\tAnyElysia | ((app: AnyElysia) => MaybePromise<AnyElysia>)\n\t\t\t  >\n\t\t\t| Promise<{\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t| AnyElysia\n\t\t\t\t\t\t| ((app: AnyElysia) => MaybePromise<AnyElysia>)\n\t\t\t  }>,\n\t\toptions?: { scoped?: boolean }\n\t): AnyElysia {\n\t\tif (Array.isArray(plugin)) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\t\tlet app = this\n\t\t\tfor (const p of plugin) app = app.use(p) as any\n\t\t\treturn app\n\t\t}\n\n\t\tif (options?.scoped)\n\t\t\treturn this.guard({} as any, (app) => app.use(plugin as any))\n\n\t\tif (Array.isArray(plugin)) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\t\tlet current = this\n\n\t\t\tfor (const p of plugin) current = this.use(p) as any\n\n\t\t\treturn current\n\t\t}\n\n\t\tif (plugin instanceof Promise) {\n\t\t\tthis.promisedModules.add(\n\t\t\t\tplugin\n\t\t\t\t\t.then((plugin) => {\n\t\t\t\t\t\tif (typeof plugin === 'function') return plugin(this)\n\n\t\t\t\t\t\tif (plugin instanceof Elysia)\n\t\t\t\t\t\t\treturn this._use(plugin).compile()\n\n\t\t\t\t\t\tif (plugin.constructor.name === 'Elysia')\n\t\t\t\t\t\t\treturn this._use(\n\t\t\t\t\t\t\t\tplugin as unknown as Elysia\n\t\t\t\t\t\t\t).compile()\n\n\t\t\t\t\t\tif (typeof plugin.default === 'function')\n\t\t\t\t\t\t\treturn plugin.default(this)\n\n\t\t\t\t\t\tif (plugin.default instanceof Elysia)\n\t\t\t\t\t\t\treturn this._use(plugin.default)\n\n\t\t\t\t\t\tif (plugin.constructor.name === 'Elysia')\n\t\t\t\t\t\t\treturn this._use(plugin.default)\n\n\t\t\t\t\t\tif (plugin.constructor.name === '_Elysia')\n\t\t\t\t\t\t\treturn this._use(plugin.default)\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn this._use(plugin.default)\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t\t'Invalid plugin type. Expected Elysia instance, function, or module with \"default\" as Elysia instance or function that returns Elysia instance.'\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\tthrow error\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.then((v) => {\n\t\t\t\t\t\tif (v && typeof v.compile === 'function') v.compile()\n\n\t\t\t\t\t\treturn v\n\t\t\t\t\t})\n\t\t\t)\n\n\t\t\treturn this\n\t\t}\n\n\t\treturn this._use(plugin)\n\t}\n\n\tprivate propagatePromiseModules(plugin: Elysia) {\n\t\tif (plugin.promisedModules.size <= 0) return this\n\n\t\tfor (const promise of plugin.promisedModules.promises)\n\t\t\tthis.promisedModules.add(\n\t\t\t\tpromise.then((v) => {\n\t\t\t\t\tif (!v) return\n\n\t\t\t\t\tconst t = this._use(v)\n\t\t\t\t\tif (t instanceof Promise)\n\t\t\t\t\t\treturn t.then((v2) => {\n\t\t\t\t\t\t\tif (v2) v2.compile()\n\t\t\t\t\t\t\telse v.compile()\n\t\t\t\t\t\t})\n\n\t\t\t\t\treturn v.compile()\n\t\t\t\t})\n\t\t\t)\n\n\t\treturn this\n\t}\n\n\tprivate _use(\n\t\tplugin: AnyElysia | ((app: AnyElysia) => MaybePromise<AnyElysia>)\n\t) {\n\t\tif (typeof plugin === 'function') {\n\t\t\tconst instance = plugin(this as unknown as any) as unknown as any\n\n\t\t\tif (instance instanceof Promise) {\n\t\t\t\tthis.promisedModules.add(\n\t\t\t\t\tinstance\n\t\t\t\t\t\t.then((plugin) => {\n\t\t\t\t\t\t\tif (plugin instanceof Elysia) {\n\t\t\t\t\t\t\t\tplugin.getServer = () => this.getServer()\n\t\t\t\t\t\t\t\tplugin.getGlobalRoutes = () =>\n\t\t\t\t\t\t\t\t\tthis.getGlobalRoutes()\n\t\t\t\t\t\t\t\tplugin.getGlobalDefinitions = () =>\n\t\t\t\t\t\t\t\t\tthis.getGlobalDefinitions()\n\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * Model and error is required for Swagger generation\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tplugin.model(this.definitions.type as any)\n\t\t\t\t\t\t\t\tplugin.error(this.definitions.error as any)\n\n\t\t\t\t\t\t\t\t// Recompile async plugin routes\n\t\t\t\t\t\t\t\tfor (const {\n\t\t\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\thandler,\n\t\t\t\t\t\t\t\t\thooks,\n\t\t\t\t\t\t\t\t\tstandaloneValidators\n\t\t\t\t\t\t\t\t} of Object.values(plugin.router.history))\n\t\t\t\t\t\t\t\t\tthis.add(\n\t\t\t\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\t\thandler,\n\t\t\t\t\t\t\t\t\t\tisNotEmpty(plugin.event.error)\n\t\t\t\t\t\t\t\t\t\t\t? mergeHook(hooks as AnyLocalHook, {\n\t\t\t\t\t\t\t\t\t\t\t\t\terror: plugin.event.error\n\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t: hooks,\n\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\tstandaloneValidators\n\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\tif (plugin === this) return\n\n\t\t\t\t\t\t\t\tthis.propagatePromiseModules(plugin)\n\n\t\t\t\t\t\t\t\treturn plugin\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (typeof plugin === 'function')\n\t\t\t\t\t\t\t\treturn plugin(\n\t\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\t\tif (typeof plugin.default === 'function')\n\t\t\t\t\t\t\t\treturn plugin.default(\n\t\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\t\treturn this._use(plugin)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then((v) => {\n\t\t\t\t\t\t\tif (v && typeof v.compile === 'function')\n\t\t\t\t\t\t\t\tv.compile()\n\n\t\t\t\t\t\t\treturn v\n\t\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t\treturn this as unknown as any\n\t\t\t}\n\n\t\t\treturn instance\n\t\t}\n\n\t\tthis.propagatePromiseModules(plugin)\n\n\t\tconst name = plugin.config.name\n\t\tconst seed = plugin.config.seed\n\n\t\tplugin.getParent = () => this as any\n\t\tplugin.getServer = () => this.getServer()\n\t\tplugin.getGlobalRoutes = () => this.getGlobalRoutes()\n\t\tplugin.getGlobalDefinitions = () => this.getGlobalDefinitions()\n\n\t\t// if (this.config.sanitize) {\n\t\t// \tconst isArray = (v: unknown): v is any[] => Array.isArray(v)\n\n\t\t// \tif (plugin.config.sanitize) {\n\t\t// \t\tif (isArray(this.config.sanitize)) {\n\t\t// \t\t\tif (isArray(plugin.config.sanitize)) {\n\t\t// \t\t\t\tplugin.config.sanitize = this.config.sanitize.concat(\n\t\t// \t\t\t\t\tplugin.config.sanitize\n\t\t// \t\t\t\t)\n\t\t// \t\t\t} else {\n\t\t// \t\t\t\tif (isArray(plugin.config.sanitize)) {\n\t\t// \t\t\t\t\tplugin.config.sanitize =\n\t\t// \t\t\t\t\t\tthis.config.sanitize.concat(\n\t\t// \t\t\t\t\t\t\tplugin.config.sanitize\n\t\t// \t\t\t\t\t\t)\n\t\t// \t\t\t\t} else {\n\t\t// \t\t\t\t\tif (this.config.sanitize)\n\t\t// \t\t\t\t\t\tplugin.config.sanitize = [\n\t\t// \t\t\t\t\t\t\t...this.config.sanitize,\n\t\t// \t\t\t\t\t\t\tplugin.config.sanitize\n\t\t// \t\t\t\t\t\t]\n\t\t// \t\t\t\t}\n\t\t// \t\t\t}\n\t\t// \t\t} else {\n\t\t// \t\t\tif (isArray(plugin.config.sanitize)) {\n\t\t// \t\t\t\tplugin.config.sanitize = [\n\t\t// \t\t\t\t\tthis.config.sanitize,\n\t\t// \t\t\t\t\t...plugin.config.sanitize\n\t\t// \t\t\t\t]\n\t\t// \t\t\t} else {\n\t\t// \t\t\t\tif (this.config.sanitize)\n\t\t// \t\t\t\t\tplugin.config.sanitize = [\n\t\t// \t\t\t\t\t\tthis.config.sanitize,\n\t\t// \t\t\t\t\t\tplugin.config.sanitize\n\t\t// \t\t\t\t\t]\n\t\t// \t\t\t}\n\t\t// \t\t}\n\t\t// \t} else plugin.config.sanitize = this.config.sanitize\n\t\t// }\n\n\t\tif (plugin.standaloneValidator?.scoped) {\n\t\t\tif (this.standaloneValidator.local)\n\t\t\t\tthis.standaloneValidator.local =\n\t\t\t\t\tthis.standaloneValidator.local.concat(\n\t\t\t\t\t\tplugin.standaloneValidator.scoped\n\t\t\t\t\t)\n\t\t\telse\n\t\t\t\tthis.standaloneValidator.local =\n\t\t\t\t\tplugin.standaloneValidator.scoped\n\t\t}\n\n\t\tif (plugin.standaloneValidator?.global) {\n\t\t\tif (this.standaloneValidator.global)\n\t\t\t\tthis.standaloneValidator.global =\n\t\t\t\t\tthis.standaloneValidator.global.concat(\n\t\t\t\t\t\tplugin.standaloneValidator.global\n\t\t\t\t\t)\n\t\t\telse\n\t\t\t\tthis.standaloneValidator.global =\n\t\t\t\t\tplugin.standaloneValidator.global\n\t\t}\n\n\t\t/**\n\t\t * Model and error is required for Swagger generation\n\t\t */\n\t\t// plugin.model(this.definitions.type as any)\n\t\t// plugin.error(this.definitions.error as any)\n\n\t\tif (isNotEmpty(plugin['~parser']))\n\t\t\tthis['~parser'] = {\n\t\t\t\t...plugin['~parser'],\n\t\t\t\t...this['~parser']\n\t\t\t}\n\n\t\tif (plugin.setHeaders) this.headers(plugin.setHeaders)\n\n\t\tif (name) {\n\t\t\tif (!(name in this.dependencies)) this.dependencies[name] = []\n\n\t\t\tconst current =\n\t\t\t\tseed !== undefined ? checksum(name + JSON.stringify(seed)) : 0\n\n\t\t\tif (\n\t\t\t\t!this.dependencies[name].some(\n\t\t\t\t\t({ checksum }) => current === checksum\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tthis.extender.macros = this.extender.macros.concat(\n\t\t\t\t\tplugin.extender.macros\n\t\t\t\t)\n\n\t\t\t\tthis.extender.higherOrderFunctions =\n\t\t\t\t\tthis.extender.higherOrderFunctions.concat(\n\t\t\t\t\t\tplugin.extender.higherOrderFunctions\n\t\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tif (plugin.extender.macros.length)\n\t\t\t\tthis.extender.macros = this.extender.macros.concat(\n\t\t\t\t\tplugin.extender.macros\n\t\t\t\t)\n\n\t\t\tif (plugin.extender.higherOrderFunctions.length)\n\t\t\t\tthis.extender.higherOrderFunctions =\n\t\t\t\t\tthis.extender.higherOrderFunctions.concat(\n\t\t\t\t\t\tplugin.extender.higherOrderFunctions\n\t\t\t\t\t)\n\t\t}\n\n\t\t// ! Deduplicate current instance\n\t\tdeduplicateChecksum(this.extender.macros)\n\t\tdeduplicateChecksum(this.extender.higherOrderFunctions)\n\n\t\t// ! Deduplicate current instance\n\t\tconst hofHashes: number[] = []\n\t\tfor (let i = 0; i < this.extender.higherOrderFunctions.length; i++) {\n\t\t\tconst hof = this.extender.higherOrderFunctions[i]\n\n\t\t\tif (hof.checksum) {\n\t\t\t\tif (hofHashes.includes(hof.checksum)) {\n\t\t\t\t\tthis.extender.higherOrderFunctions.splice(i, 1)\n\t\t\t\t\ti--\n\t\t\t\t}\n\n\t\t\t\thofHashes.push(hof.checksum)\n\t\t\t}\n\t\t}\n\t\thofHashes.length = 0\n\n\t\tthis.inference = mergeInference(this.inference, plugin.inference)\n\n\t\tif (isNotEmpty(plugin.singleton.decorator))\n\t\t\tthis.decorate(plugin.singleton.decorator)\n\n\t\tif (isNotEmpty(plugin.singleton.store))\n\t\t\tthis.state(plugin.singleton.store)\n\n\t\tif (isNotEmpty(plugin.definitions.type))\n\t\t\tthis.model(plugin.definitions.type)\n\n\t\tif (isNotEmpty(plugin.definitions.error))\n\t\t\tthis.error(plugin.definitions.error as any)\n\n\t\tif (isNotEmpty(plugin.definitions.error))\n\t\t\tplugin.extender.macros = this.extender.macros.concat(\n\t\t\t\tplugin.extender.macros\n\t\t\t)\n\n\t\tfor (const {\n\t\t\tmethod,\n\t\t\tpath,\n\t\t\thandler,\n\t\t\thooks,\n\t\t\tstandaloneValidators\n\t\t} of Object.values(plugin.router.history)) {\n\t\t\tthis.add(\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\thandler,\n\t\t\t\tisNotEmpty(plugin.event.error)\n\t\t\t\t\t? mergeHook(hooks as AnyLocalHook, {\n\t\t\t\t\t\t\terror: plugin.event.error\n\t\t\t\t\t\t})\n\t\t\t\t\t: hooks,\n\t\t\t\tundefined,\n\t\t\t\tstandaloneValidators\n\t\t\t)\n\t\t}\n\n\t\tif (name) {\n\t\t\tif (!(name in this.dependencies)) this.dependencies[name] = []\n\n\t\t\tconst current =\n\t\t\t\tseed !== undefined ? checksum(name + JSON.stringify(seed)) : 0\n\n\t\t\tif (\n\t\t\t\tthis.dependencies[name].some(\n\t\t\t\t\t({ checksum }) => current === checksum\n\t\t\t\t)\n\t\t\t)\n\t\t\t\treturn this\n\n\t\t\tthis.dependencies[name].push(\n\t\t\t\tthis.config?.analytic\n\t\t\t\t\t? ({\n\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\tdependencies: plugin.dependencies,\n\t\t\t\t\t\t\tstack: plugin.telemetry?.stack,\n\t\t\t\t\t\t\troutes: plugin.router.history,\n\t\t\t\t\t\t\tdecorators: plugin.singleton,\n\t\t\t\t\t\t\tstore: plugin.singleton.store,\n\t\t\t\t\t\t\terror: plugin.definitions.error,\n\t\t\t\t\t\t\tderive: plugin.event.transform\n\t\t\t\t\t\t\t\t?.filter((x) => x?.subType === 'derive')\n\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\tfn: x.toString(),\n\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t\tresolve: plugin.event.transform\n\t\t\t\t\t\t\t\t?.filter((x) => x?.subType === 'resolve')\n\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\tfn: x.toString(),\n\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t} as any)\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\tdependencies: plugin.dependencies\n\t\t\t\t\t\t}\n\t\t\t)\n\n\t\t\tif (isNotEmpty(plugin.event))\n\t\t\t\tthis.event = mergeLifeCycle(\n\t\t\t\t\tthis.event,\n\t\t\t\t\tfilterGlobalHook(plugin.event),\n\t\t\t\t\tcurrent\n\t\t\t\t)\n\t\t} else {\n\t\t\tif (isNotEmpty(plugin.event))\n\t\t\t\tthis.event = mergeLifeCycle(\n\t\t\t\t\tthis.event,\n\t\t\t\t\tfilterGlobalHook(plugin.event)\n\t\t\t\t)\n\t\t}\n\n\t\tif (plugin.validator.global)\n\t\t\t// @ts-ignore\n\t\t\tthis.validator.global = mergeHook(this.validator.global, {\n\t\t\t\t...plugin.validator.global\n\t\t\t}) as any\n\n\t\tif (plugin.validator.scoped)\n\t\t\t// @ts-ignore\n\t\t\tthis.validator.local = mergeHook(this.validator.local, {\n\t\t\t\t...plugin.validator.scoped\n\t\t\t})\n\n\t\treturn this\n\t}\n\n\tmacro<const NewMacro extends BaseMacroFn>(\n\t\tmacro: (\n\t\t\troute: MacroManager<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Partial<Ephemeral['derive'] & Volatile['derive']>\n\t\t\t\t\tresolve: Partial<Ephemeral['resolve'] & Volatile['resolve']>\n\t\t\t\t},\n\t\t\t\tDefinitions['error']\n\t\t\t>\n\t\t) => NewMacro\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\t{\n\t\t\tschema: Metadata['schema']\n\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t\tmacro: Metadata['macro'] & Partial<MacroToProperty<NewMacro>>\n\t\t\tmacroFn: Metadata['macroFn'] & NewMacro\n\t\t\tparser: Metadata['parser']\n\t\t},\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmacro<\n\t\tconst NewMacro extends HookMacroFn<\n\t\t\tMetadata['schema'],\n\t\t\tSingleton & {\n\t\t\t\tderive: Partial<Ephemeral['derive'] & Volatile['derive']>\n\t\t\t\tresolve: Partial<Ephemeral['resolve'] & Volatile['resolve']>\n\t\t\t},\n\t\t\tDefinitions['error']\n\t\t>\n\t>(\n\t\tmacro: NewMacro\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\t{\n\t\t\tschema: Metadata['schema']\n\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t\tmacro: Metadata['macro'] & Partial<MacroToProperty<NewMacro>>\n\t\t\tmacroFn: Metadata['macroFn'] & NewMacro\n\t\t\tparser: Metadata['parser']\n\t\t},\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmacro(macro: Function | Record<keyof any, Function>) {\n\t\tif (typeof macro === 'function') {\n\t\t\tconst hook: MacroQueue = {\n\t\t\t\tchecksum: checksum(\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\tname: this.config.name,\n\t\t\t\t\t\tseed: this.config.seed,\n\t\t\t\t\t\tcontent: macro.toString()\n\t\t\t\t\t})\n\t\t\t\t),\n\t\t\t\tfn: macro as any\n\t\t\t}\n\n\t\t\tthis.extender.macros.push(hook)\n\t\t} else if (typeof macro === 'object') {\n\t\t\tfor (const name of Object.keys(macro))\n\t\t\t\tif (typeof macro[name] === 'object') {\n\t\t\t\t\tconst actualValue = { ...(macro[name] as Object) }\n\n\t\t\t\t\tmacro[name] = (v: boolean) => {\n\t\t\t\t\t\tif (v === true) return actualValue\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tconst hook: MacroQueue = {\n\t\t\t\tchecksum: checksum(\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\tname: this.config.name,\n\t\t\t\t\t\tseed: this.config.seed,\n\t\t\t\t\t\tcontent: Object.entries(macro)\n\t\t\t\t\t\t\t.map(([k, v]) => `${k}+${v}`)\n\t\t\t\t\t\t\t.join(',')\n\t\t\t\t\t})\n\t\t\t\t),\n\t\t\t\tfn: () => macro\n\t\t\t}\n\n\t\t\tthis.extender.macros.push(hook)\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\tmount(\n\t\thandle: ((request: Request) => MaybePromise<Response>) | AnyElysia,\n\t\tdetail?: { detail?: DocumentDecoration }\n\t): this\n\tmount(\n\t\tpath: string,\n\t\thandle: ((request: Request) => MaybePromise<Response>) | AnyElysia,\n\t\tdetail?: { detail?: DocumentDecoration }\n\t): this\n\n\tmount(\n\t\tpath:\n\t\t\t| string\n\t\t\t| ((request: Request) => MaybePromise<Response>)\n\t\t\t| AnyElysia,\n\t\thandleOrConfig?:\n\t\t\t| ((request: Request) => MaybePromise<Response>)\n\t\t\t| AnyElysia\n\t\t\t| { detail?: DocumentDecoration },\n\t\tconfig?: { detail?: DocumentDecoration }\n\t) {\n\t\tif (\n\t\t\tpath instanceof Elysia ||\n\t\t\ttypeof path === 'function' ||\n\t\t\tpath.length === 0 ||\n\t\t\tpath === '/'\n\t\t) {\n\t\t\tconst run =\n\t\t\t\ttypeof path === 'function'\n\t\t\t\t\t? path\n\t\t\t\t\t: path instanceof Elysia\n\t\t\t\t\t\t? path.compile().fetch\n\t\t\t\t\t\t: handleOrConfig instanceof Elysia\n\t\t\t\t\t\t\t? handleOrConfig.compile().fetch\n\t\t\t\t\t\t\t: typeof handleOrConfig === 'function'\n\t\t\t\t\t\t\t\t? handleOrConfig\n\t\t\t\t\t\t\t\t: (() => {\n\t\t\t\t\t\t\t\t\t\tthrow new Error('Invalid handler')\n\t\t\t\t\t\t\t\t\t})()\n\n\t\t\tconst handler: Handler = ({ request, path }) =>\n\t\t\t\trun(\n\t\t\t\t\tnew Request(replaceUrlPath(request.url, path), {\n\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\theaders: request.headers,\n\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\tcredentials: request.credentials,\n\t\t\t\t\t\treferrerPolicy: request.referrerPolicy as any,\n\t\t\t\t\t\tduplex: request.duplex,\n\t\t\t\t\t\tredirect: request.redirect,\n\t\t\t\t\t\tmode: request.mode,\n\t\t\t\t\t\tkeepalive: request.keepalive,\n\t\t\t\t\t\tintegrity: request.integrity,\n\t\t\t\t\t\tbody: request.body\n\t\t\t\t\t})\n\t\t\t\t)\n\n\t\t\tthis.route('ALL', '/*', handler as any, {\n\t\t\t\tparse: 'none',\n\t\t\t\t...config,\n\t\t\t\tdetail: {\n\t\t\t\t\t...config?.detail,\n\t\t\t\t\thide: true\n\t\t\t\t},\n\t\t\t\tconfig: {\n\t\t\t\t\tmount: run\n\t\t\t\t}\n\t\t\t})\n\n\t\t\treturn this\n\t\t}\n\n\t\tconst handle =\n\t\t\thandleOrConfig instanceof Elysia\n\t\t\t\t? handleOrConfig.compile().fetch\n\t\t\t\t: typeof handleOrConfig === 'function'\n\t\t\t\t\t? handleOrConfig\n\t\t\t\t\t: (() => {\n\t\t\t\t\t\t\tthrow new Error('Invalid handler')\n\t\t\t\t\t\t})()\n\n\t\tconst length = path.length - (path.endsWith('*') ? 1 : 0)\n\n\t\tconst handler: Handler = ({ request, path }) =>\n\t\t\thandle(\n\t\t\t\tnew Request(\n\t\t\t\t\treplaceUrlPath(request.url, path.slice(length) || '/'),\n\t\t\t\t\t{\n\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\theaders: request.headers,\n\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\tcredentials: request.credentials,\n\t\t\t\t\t\treferrerPolicy: request.referrerPolicy as any,\n\t\t\t\t\t\tduplex: request.duplex,\n\t\t\t\t\t\tredirect: request.redirect,\n\t\t\t\t\t\tmode: request.mode,\n\t\t\t\t\t\tkeepalive: request.keepalive,\n\t\t\t\t\t\tintegrity: request.integrity,\n\t\t\t\t\t\tbody: request.body\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\n\n\t\tthis.route('ALL', path, handler as any, {\n\t\t\tparse: 'none',\n\t\t\t...config,\n\t\t\tdetail: {\n\t\t\t\t...config?.detail,\n\t\t\t\thide: true\n\t\t\t},\n\t\t\tconfig: {\n\t\t\t\tmount: handle\n\t\t\t}\n\t\t})\n\n\t\tthis.route(\n\t\t\t'ALL',\n\t\t\tpath + (path.endsWith('/') ? '*' : '/*'),\n\t\t\thandler as any,\n\t\t\t{\n\t\t\t\tparse: 'none',\n\t\t\t\t...config,\n\t\t\t\tdetail: {\n\t\t\t\t\t...config?.detail,\n\t\t\t\t\thide: true\n\t\t\t\t},\n\t\t\t\tconfig: {\n\t\t\t\t\tmount: handle\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### get\n\t * Register handler for path with method [GET]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .get('/', () => 'hi')\n\t *     .get('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tget<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tget: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('GET', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### post\n\t * Register handler for path with method [POST]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .post('/', () => 'hi')\n\t *     .post('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tpost<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tpost: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('POST', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### put\n\t * Register handler for path with method [PUT]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .put('/', () => 'hi')\n\t *     .put('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tput<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tput: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('PUT', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### patch\n\t * Register handler for path with method [PATCH]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .patch('/', () => 'hi')\n\t *     .patch('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tpatch<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tpatch: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('PATCH', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### delete\n\t * Register handler for path with method [DELETE]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .delete('/', () => 'hi')\n\t *     .delete('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tdelete<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tdelete: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('DELETE', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### options\n\t * Register handler for path with method [POST]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .options('/', () => 'hi')\n\t *     .options('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\toptions<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('OPTIONS', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### all\n\t * Register handler for path with method [ALL]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .all('/', () => 'hi')\n\t *     .all('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tall<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\t[method in string]: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('ALL', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### head\n\t * Register handler for path with method [HEAD]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .head('/', () => 'hi')\n\t *     .head('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\thead<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\thead: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('HEAD', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### connect\n\t * Register handler for path with method [CONNECT]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .connect('/', () => 'hi')\n\t *     .connect('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tconnect<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tconnect: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('CONNECT', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### route\n\t * Register handler for path with method [ROUTE]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .route('/', () => 'hi')\n\t *     .route('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\troute<\n\t\tconst Method extends HTTPMethod,\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tmethod: Method,\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t> & {\n\t\t\tconfig?: {\n\t\t\t\tallowMeta?: boolean\n\t\t\t\tmount?: Function\n\t\t\t}\n\t\t}\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\t[method in Method]: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add(method.toUpperCase(), path, handler as any, hook, hook?.config)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### ws\n\t * Register handler for path with method [ws]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .ws('/', {\n\t *         message(ws, message) {\n\t *             ws.send(message)\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tws<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Macro extends Metadata['macro']\n\t>(\n\t\tpath: Path,\n\t\toptions: WSLocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t\t},\n\t\t\tMacro\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tsubscribe: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: {} extends Schema['response']\n\t\t\t\t\t\t\t? unknown\n\t\t\t\t\t\t\t: Schema['response'] extends { [200]: any }\n\t\t\t\t\t\t\t\t? Schema['response'][200]\n\t\t\t\t\t\t\t\t: unknown\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tif (this['~adapter'].ws) this['~adapter'].ws(this, path, options as any)\n\t\telse console.warn(`Current adapter doesn't support WebSocket`)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<const Name extends string | number | symbol, Value>(\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Prettify<\n\t\t\t\tSingleton['store'] & {\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t}\n\t\t\t>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state({ counter: 0 })\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<Store extends Record<string, unknown>>(\n\t\tstore: Store\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Prettify<Singleton['store'] & Store>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<\n\t\tconst Type extends ContextAppendType,\n\t\tconst Name extends string | number | symbol,\n\t\tValue\n\t>(\n\t\toptions: { as: Type },\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Type extends 'override'\n\t\t\t\t? Reconcile<\n\t\t\t\t\t\tSingleton['store'],\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t[name in Name]: Value\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttrue\n\t\t\t\t\t>\n\t\t\t\t: Prettify<\n\t\t\t\t\t\tSingleton['store'] & {\n\t\t\t\t\t\t\t[name in Name]: Value\n\t\t\t\t\t\t}\n\t\t\t\t\t>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state({ counter: 0 })\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<\n\t\tconst Type extends ContextAppendType,\n\t\tStore extends Record<string, unknown>\n\t>(\n\t\toptions: { as: Type },\n\t\tstore: Store\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Type extends 'override'\n\t\t\t\t? Reconcile<Singleton['store'], Store>\n\t\t\t\t: Prettify<Singleton['store'] & Store>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tstate<NewStore extends Record<string, unknown>>(\n\t\tmapper: (decorators: Singleton['store']) => NewStore\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: NewStore\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate(\n\t\toptions:\n\t\t\t| { as: ContextAppendType }\n\t\t\t| string\n\t\t\t| Record<string, unknown>\n\t\t\t| Function,\n\t\tname?:\n\t\t\t| string\n\t\t\t| Record<string, unknown>\n\t\t\t| Function\n\t\t\t| { as: ContextAppendType },\n\t\tvalue?: unknown\n\t) {\n\t\tif (name === undefined) {\n\t\t\t/**\n\t\t\t * Using either\n\t\t\t * - decorate({ name: value })\n\t\t\t */\n\t\t\tvalue = options\n\t\t\toptions = { as: 'append' }\n\t\t\tname = ''\n\t\t} else if (value === undefined) {\n\t\t\t/**\n\t\t\t * Using either\n\t\t\t * - decorate({ as: 'override' }, { name: value })\n\t\t\t * - decorate('name', value)\n\t\t\t */\n\n\t\t\t// decorate('name', value)\n\t\t\tif (typeof options === 'string') {\n\t\t\t\tvalue = name\n\t\t\t\tname = options\n\t\t\t\toptions = { as: 'append' }\n\t\t\t} else if (typeof options === 'object') {\n\t\t\t\t// decorate({ as: 'override' }, { name: value })\n\t\t\t\tvalue = name\n\t\t\t\tname = ''\n\t\t\t}\n\t\t}\n\n\t\tconst { as } = options as { as: ContextAppendType }\n\n\t\tif (typeof name !== 'string') return this\n\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (!value || !isNotEmpty(value)) return this\n\n\t\t\t\tif (name) {\n\t\t\t\t\tif (name in this.singleton.store)\n\t\t\t\t\t\tthis.singleton.store[name] = mergeDeep(\n\t\t\t\t\t\t\tthis.singleton.store[name] as any,\n\t\t\t\t\t\t\tvalue!,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\toverride: as === 'override'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\telse this.singleton.store[name] = value\n\n\t\t\t\t\treturn this\n\t\t\t\t}\n\n\t\t\t\tif (value === null) return this\n\n\t\t\t\tthis.singleton.store = mergeDeep(this.singleton.store, value, {\n\t\t\t\t\toverride: as === 'override'\n\t\t\t\t})\n\n\t\t\t\treturn this as any\n\n\t\t\tcase 'function':\n\t\t\t\tif (name) {\n\t\t\t\t\tif (as === 'override' || !(name in this.singleton.store))\n\t\t\t\t\t\tthis.singleton.store[name] = value\n\t\t\t\t} else this.singleton.store = value(this.singleton.store)\n\n\t\t\t\treturn this as any\n\n\t\t\tdefault:\n\t\t\t\tif (as === 'override' || !(name in this.singleton.store))\n\t\t\t\t\tthis.singleton.store[name] = value\n\n\t\t\t\treturn this\n\t\t}\n\t}\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<const Name extends string, Value>(\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Prettify<\n\t\t\t\tSingleton['decorator'] & {\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t}\n\t\t\t>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<NewDecorators extends Record<string, unknown>>(\n\t\tdecorators: NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Prettify<Singleton['decorator'] & NewDecorators>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tdecorate<NewDecorators extends Record<string, unknown>>(\n\t\tmapper: (decorators: Singleton['decorator']) => NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: NewDecorators\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate({ as: 'override' }, 'getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<\n\t\tconst Type extends ContextAppendType,\n\t\tconst Name extends string,\n\t\tValue\n\t>(\n\t\toptions: { as: Type },\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Type extends 'override'\n\t\t\t\t? Reconcile<\n\t\t\t\t\t\tSingleton['decorator'],\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t[name in Name]: Value\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttrue\n\t\t\t\t\t>\n\t\t\t\t: Prettify<\n\t\t\t\t\t\tSingleton['decorator'] & {\n\t\t\t\t\t\t\t[name in Name]: Value\n\t\t\t\t\t\t}\n\t\t\t\t\t>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<\n\t\tconst Type extends ContextAppendType,\n\t\tNewDecorators extends Record<string, unknown>\n\t>(\n\t\toptions: { as: Type },\n\t\tdecorators: NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Type extends 'override'\n\t\t\t\t? Reconcile<Singleton['decorator'], NewDecorators, true>\n\t\t\t\t: Prettify<Singleton['decorator'] & NewDecorators>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate(\n\t\toptions:\n\t\t\t| { as: ContextAppendType }\n\t\t\t| string\n\t\t\t| Record<string, unknown>\n\t\t\t| Function,\n\t\tname?:\n\t\t\t| string\n\t\t\t| Record<string, unknown>\n\t\t\t| Function\n\t\t\t| { as: ContextAppendType },\n\t\tvalue?: unknown\n\t) {\n\t\tif (name === undefined) {\n\t\t\t/**\n\t\t\t * Using either\n\t\t\t * - decorate({ name: value })\n\t\t\t */\n\t\t\tvalue = options\n\t\t\toptions = { as: 'append' }\n\t\t\tname = ''\n\t\t} else if (value === undefined) {\n\t\t\t/**\n\t\t\t * Using either\n\t\t\t * - decorate({ as: 'override' }, { name: value })\n\t\t\t * - decorate('name', value)\n\t\t\t */\n\n\t\t\t// decorate('name', value)\n\t\t\tif (typeof options === 'string') {\n\t\t\t\tvalue = name\n\t\t\t\tname = options\n\t\t\t\toptions = { as: 'append' }\n\t\t\t} else if (typeof options === 'object') {\n\t\t\t\t// decorate({ as: 'override' }, { name: value })\n\t\t\t\tvalue = name\n\t\t\t\tname = ''\n\t\t\t}\n\t\t}\n\n\t\tconst { as } = options as { as: ContextAppendType }\n\n\t\tif (typeof name !== 'string') return this\n\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (name) {\n\t\t\t\t\tif (name in this.singleton.decorator)\n\t\t\t\t\t\tthis.singleton.decorator[name] = mergeDeep(\n\t\t\t\t\t\t\tthis.singleton.decorator[name] as any,\n\t\t\t\t\t\t\tvalue!,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\toverride: as === 'override'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\telse this.singleton.decorator[name] = value\n\n\t\t\t\t\treturn this\n\t\t\t\t}\n\n\t\t\t\tif (value === null) return this\n\n\t\t\t\tthis.singleton.decorator = mergeDeep(\n\t\t\t\t\tthis.singleton.decorator,\n\t\t\t\t\tvalue,\n\t\t\t\t\t{\n\t\t\t\t\t\toverride: as === 'override'\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn this as any\n\n\t\t\tcase 'function':\n\t\t\t\tif (name) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tas === 'override' ||\n\t\t\t\t\t\t!(name in this.singleton.decorator)\n\t\t\t\t\t)\n\t\t\t\t\t\tthis.singleton.decorator[name] = value\n\t\t\t\t} else\n\t\t\t\t\tthis.singleton.decorator = value(this.singleton.decorator)\n\n\t\t\t\treturn this as any\n\n\t\t\tdefault:\n\t\t\t\tif (as === 'override' || !(name in this.singleton.decorator))\n\t\t\t\t\tthis.singleton.decorator[name] = value\n\n\t\t\t\treturn this\n\t\t}\n\t}\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tderive<\n\t\tconst Derivative extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>\n\t\t\t| void\n\t>(\n\t\ttransform: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>,\n\t\t\t\t\t\tBasePath\n\t\t\t\t\t>,\n\t\t\t\t\tSingleton & {\n\t\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Derivative>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Prettify<\n\t\t\t\tVolatile['derive'] & ExcludeElysiaResponse<Derivative>\n\t\t\t>\n\t\t\tresolve: Volatile['resolve']\n\t\t\tschema: Volatile['schema']\n\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t}\n\t>\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tderive<\n\t\tconst Derivative extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>\n\t\t\t| void,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\ttransform: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>,\n\t\t\t\t\t\tBasePath\n\t\t\t\t\t> &\n\t\t\t\t\t\t'global' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t\t: {},\n\t\t\t\t\tSingleton &\n\t\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\tBasePath\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Derivative>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Prettify<\n\t\t\t\t\t\tSingleton['derive'] & ExcludeElysiaResponse<Derivative>\n\t\t\t\t\t>\n\t\t\t\t\tresolve: Singleton['resolve']\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Prettify<\n\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Derivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tresolve: Ephemeral['resolve']\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\tstandaloneSchema: Ephemeral['standaloneSchema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Prettify<\n\t\t\t\t\t\t\tVolatile['derive'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Derivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tresolve: Ephemeral['resolve']\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\tderive(\n\t\toptionsOrTransform: { as?: LifeCycleType } | Function,\n\t\ttransform?: Function\n\t) {\n\t\tif (!transform) {\n\t\t\ttransform = optionsOrTransform as any\n\t\t\toptionsOrTransform = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'derive',\n\t\t\tfn: transform!\n\t\t}\n\n\t\treturn this.onTransform(optionsOrTransform as any, hook as any) as any\n\t}\n\n\tmodel<const Name extends string, const Model extends TSchema>(\n\t\tname: Name,\n\t\tmodel: Model\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: Definitions['typebox'] & {\n\t\t\t\t[name in Name]: Model\n\t\t\t}\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmodel<const Recorder extends TProperties>(\n\t\trecord: Recorder\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: Definitions['typebox'] & Recorder\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmodel<const NewType extends Record<string, TSchema>>(\n\t\tmapper: (\n\t\t\tdecorators: Definitions['typebox'] extends infer Models extends\n\t\t\t\tRecord<string, TSchema>\n\t\t\t\t? {\n\t\t\t\t\t\t[type in keyof Models]: TRef<// @ts-ignore\n\t\t\t\t\t\ttype>\n\t\t\t\t\t}\n\t\t\t\t: {}\n\t\t) => NewType\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: {\n\t\t\t\t[key in keyof NewType]: NewType[key] extends TRef<key & string>\n\t\t\t\t\t? // @ts-expect-error\n\t\t\t\t\t\tDefinitions['typebox'][key]\n\t\t\t\t\t: NewType[key]\n\t\t\t}\n\t\t\ttype: { [x in keyof NewType]: Static<NewType[x]> }\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmodel(name: string | Record<string, TSchema> | Function, model?: TSchema) {\n\t\tswitch (typeof name) {\n\t\t\tcase 'object':\n\t\t\t\tconst parsedSchemas = {} as Record<string, TSchema>\n\n\t\t\t\tconst kvs = Object.entries(name)\n\n\t\t\t\tif (!kvs.length) return this\n\n\t\t\t\tfor (const [key, value] of kvs) {\n\t\t\t\t\tif (key in this.definitions.type) continue\n\n\t\t\t\t\tparsedSchemas[key] = this.definitions.type[key] = value\n\t\t\t\t\tparsedSchemas[key].$id ??= `#/components/schemas/${key}`\n\t\t\t\t}\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tthis.definitions.typebox = t.Module({\n\t\t\t\t\t...(this.definitions.typebox['$defs'] as TModule<{}>),\n\t\t\t\t\t...parsedSchemas\n\t\t\t\t} as any)\n\n\t\t\t\treturn this\n\n\t\t\tcase 'function':\n\t\t\t\tconst result = name(this.definitions.type)\n\t\t\t\tthis.definitions.type = result\n\t\t\t\tthis.definitions.typebox = t.Module(result as any)\n\n\t\t\t\treturn this as any\n\n\t\t\tcase 'string':\n\t\t\t\tif (!model) break\n\n\t\t\t\tconst newModel = {\n\t\t\t\t\t...model,\n\t\t\t\t\tid: model.$id ?? `#/components/schemas/${name}`\n\t\t\t\t}\n\n\t\t\t\tthis.definitions.type[name] = model\n\t\t\t\tthis.definitions.typebox = t.Module({\n\t\t\t\t\t...(this.definitions.typebox['$defs'] as TModule<{}>),\n\t\t\t\t\t...newModel\n\t\t\t\t} as any)\n\t\t\t\treturn this as any\n\t\t}\n\n\t\t;(this.definitions.type as Record<string, TSchema>)[name] = model!\n\t\tthis.definitions.typebox = t.Module({\n\t\t\t...this.definitions.typebox['$defs'],\n\t\t\t[name]: model!\n\t\t} as any)\n\n\t\treturn this as any\n\t}\n\n\tRef<K extends keyof Definitions['typebox'] & string>(key: K) {\n\t\treturn t.Ref(key)\n\t}\n\n\tmapDerive<\n\t\tconst NewDerivative extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>\n\t>(\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\t{},\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t) => MaybePromise<NewDerivative>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: ExcludeElysiaResponse<NewDerivative>\n\t\t\tresolve: Volatile['resolve']\n\t\t\tschema: Volatile['schema']\n\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t}\n\t>\n\n\tmapDerive<\n\t\tconst NewDerivative extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\t{},\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t}),\n\t\t\t\tBasePath\n\t\t\t>\n\t\t) => MaybePromise<NewDerivative>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\tSingleton['resolve'] &\n\t\t\t\t\t\t\tExcludeElysiaResponse<NewDerivative>\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Ephemeral['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewDerivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\tstandaloneSchema: Ephemeral['standaloneSchema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewDerivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\tmapDerive(\n\t\toptionsOrDerive: { as?: LifeCycleType } | Function,\n\t\tmapper?: Function\n\t) {\n\t\tif (!mapper) {\n\t\t\tmapper = optionsOrDerive as any\n\t\t\toptionsOrDerive = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'mapDerive',\n\t\t\tfn: mapper!\n\t\t}\n\n\t\treturn this.onTransform(optionsOrDerive as any, hook as any) as any\n\t}\n\n\taffix<\n\t\tconst Base extends 'prefix' | 'suffix',\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(\n\t\tbase: Base,\n\t\ttype: Type,\n\t\tword: Word\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['decorator']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['decorator']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Singleton['decorator']>\n\t\t\t\t: Singleton['decorator']\n\t\t\tstore: Type extends 'state' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['store']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['store']>\n\t\t\t\t\t: AddSuffix<Word, Singleton['store']>\n\t\t\t\t: Singleton['store']\n\t\t\tderive: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['derive']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['derive']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Singleton['derive']>\n\t\t\t\t: Singleton['derive']\n\t\t\tresolve: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['resolve']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['resolve']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Singleton['resolve']>\n\t\t\t\t: Singleton['resolve']\n\t\t},\n\t\t{\n\t\t\ttypebox: Type extends 'model' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Definitions['typebox']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Definitions['typebox']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Definitions['typebox']>\n\t\t\t\t: Definitions['typebox']\n\t\t\terror: Type extends 'error' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Definitions['error']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Definitions['error']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Definitions['error']>\n\t\t\t\t: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tif (word === '') return this as any\n\n\t\tconst delimieter = ['_', '-', ' ']\n\t\tconst capitalize = (word: string) =>\n\t\t\tword[0].toUpperCase() + word.slice(1)\n\n\t\tconst joinKey =\n\t\t\tbase === 'prefix'\n\t\t\t\t? (prefix: string, word: string) =>\n\t\t\t\t\t\tdelimieter.includes(prefix.at(-1) ?? '')\n\t\t\t\t\t\t\t? prefix + word\n\t\t\t\t\t\t\t: prefix + capitalize(word)\n\t\t\t\t: delimieter.includes(word.at(-1) ?? '')\n\t\t\t\t\t? (suffix: string, word: string) => word + suffix\n\t\t\t\t\t: (suffix: string, word: string) =>\n\t\t\t\t\t\t\tword + capitalize(suffix)\n\n\t\tconst remap = (type: 'decorator' | 'state' | 'model' | 'error') => {\n\t\t\tconst store: Record<string, any> = {}\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'decorator':\n\t\t\t\t\tfor (const key in this.singleton.decorator) {\n\t\t\t\t\t\tstore[joinKey(word, key)] =\n\t\t\t\t\t\t\tthis.singleton.decorator[key]\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.singleton.decorator = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'state':\n\t\t\t\t\tfor (const key in this.singleton.store)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.singleton.store[key]\n\n\t\t\t\t\tthis.singleton.store = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'model':\n\t\t\t\t\tfor (const key in this.definitions.type)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.definitions.type[key]\n\n\t\t\t\t\tthis.definitions.type = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'error':\n\t\t\t\t\tfor (const key in this.definitions.error)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.definitions.error[key]\n\n\t\t\t\t\tthis.definitions.error = store\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst types = Array.isArray(type) ? type : [type]\n\n\t\tfor (const type of types.some((x) => x === 'all')\n\t\t\t? ['decorator', 'state', 'model', 'error']\n\t\t\t: types)\n\t\t\tremap(type as 'decorator')\n\n\t\treturn this as any\n\t}\n\n\tprefix<\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(type: Type, word: Word) {\n\t\treturn this.affix('prefix', type, word)\n\t}\n\n\tsuffix<\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(type: Type, word: Word) {\n\t\treturn this.affix('suffix', type, word)\n\t}\n\n\tcompile() {\n\t\tif (this['~adapter'].isWebStandard) {\n\t\t\tthis.fetch = this.config.aot\n\t\t\t\t? composeGeneralHandler(this)\n\t\t\t\t: createDynamicHandler(this)\n\n\t\t\tif (typeof this.server?.reload === 'function')\n\t\t\t\tthis.server.reload({\n\t\t\t\t\t...(this.server || {}),\n\t\t\t\t\tfetch: this.fetch\n\t\t\t\t})\n\n\t\t\treturn this\n\t\t}\n\n\t\tif (typeof this.server?.reload === 'function')\n\t\t\tthis.server.reload(this.server || {})\n\n\t\tthis._handle = composeGeneralHandler(this)\n\n\t\treturn this\n\t}\n\n\thandle = async (request: Request) => this.fetch(request)\n\n\t/**\n\t * Use handle can be either sync or async to save performance.\n\t *\n\t * Beside benchmark purpose, please use 'handle' instead.\n\t */\n\tfetch = (request: Request): MaybePromise<Response> => {\n\t\treturn (this.fetch = this.config.aot\n\t\t\t? composeGeneralHandler(this)\n\t\t\t: createDynamicHandler(this))(request)\n\t}\n\n\t/**\n\t * Custom handle written by adapter\n\t */\n\tprotected _handle?(...a: unknown[]): unknown\n\n\tprotected handleError = async (\n\t\tcontext: Partial<\n\t\t\tContext<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t> & {\n\t\t\trequest: Request\n\t\t},\n\t\terror:\n\t\t\t| Error\n\t\t\t| ValidationError\n\t\t\t| ParseError\n\t\t\t| NotFoundError\n\t\t\t| InternalServerError\n\t) => {\n\t\treturn (this.handleError = this.config.aot\n\t\t\t? composeErrorHandler(this)\n\t\t\t: createDynamicErrorHandler(this))(context, error)\n\t}\n\n\t/**\n\t * ### listen\n\t * Assign current instance to port and start serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(3000)\n\t * ```\n\t */\n\tlisten = (\n\t\toptions: string | number | Partial<Serve>,\n\t\tcallback?: ListenCallback\n\t) => {\n\t\tthis['~adapter'].listen(this)(options, callback)\n\n\t\tif (this.promisedModules.size) clearSucroseCache(5000)\n\n\t\tthis.promisedModules.then(() => {\n\t\t\tclearSucroseCache(1000)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### stop\n\t * Stop server from serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * const app = new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(3000)\n\t *\n\t * // Sometime later\n\t * app.stop()\n\t * ```\n\t *\n\t * @example\n\t * ```typescript\n\t * const app = new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(3000)\n\t *\n\t * app.stop(true) // Abruptly any requests inflight\n\t * ```\n\t */\n\tstop = async (closeActiveConnections?: boolean) => {\n\t\tif (!this.server)\n\t\t\tthrow new Error(\n\t\t\t\t\"Elysia isn't running. Call `app.listen` to start the server.\"\n\t\t\t)\n\n\t\tif (this.server) {\n\t\t\tthis.server.stop(closeActiveConnections)\n\t\t\tthis.server = null\n\n\t\t\tif (this.event.stop?.length)\n\t\t\t\tfor (let i = 0; i < this.event.stop.length; i++)\n\t\t\t\t\tthis.event.stop[i].fn(this)\n\t\t}\n\t}\n\n\t/**\n\t * Wait until all lazy loaded modules all load is fully\n\t */\n\tget modules() {\n\t\treturn this.promisedModules\n\t}\n}\n\nexport { Elysia }\n\nexport { t } from './type-system'\nexport { serializeCookie, Cookie, type CookieOptions } from './cookies'\nexport type { Context, PreContext, ErrorContext } from './context'\nexport {\n\tELYSIA_TRACE,\n\ttype TraceEvent,\n\ttype TraceListener,\n\ttype TraceHandler,\n\ttype TraceProcess,\n\ttype TraceStream\n} from './trace'\n\nexport {\n\tgetSchemaValidator,\n\tgetResponseSchemaValidator,\n\treplaceSchemaType\n} from './schema'\n\nexport {\n\tmergeHook,\n\tmergeObjectArray,\n\tredirect,\n\tStatusMap,\n\tInvertedStatusMap,\n\tform,\n\treplaceUrlPath,\n\tchecksum,\n\tcloneInference,\n\tdeduplicateChecksum,\n\tELYSIA_FORM_DATA,\n\tELYSIA_REQUEST_ID\n} from './utils'\n\nexport {\n\tstatus,\n\terror,\n\tmapValueError,\n\tParseError,\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tInvalidCookieSignature,\n\tERROR_CODE\n} from './error'\n\nexport type {\n\tEphemeralType,\n\tCreateEden,\n\tComposeElysiaResponse,\n\tElysiaConfig,\n\tSingletonBase,\n\tDefinitionBase,\n\tRouteBase,\n\tHandler,\n\tComposedHandler,\n\tInputSchema,\n\tLocalHook,\n\tMergeSchema,\n\tRouteSchema,\n\tUnwrapRoute,\n\tInternalRoute,\n\tHTTPMethod,\n\tSchemaValidator,\n\tVoidHandler,\n\tPreHandler,\n\tBodyHandler,\n\tOptionalHandler,\n\tAfterResponseHandler,\n\tErrorHandler,\n\tLifeCycleEvent,\n\tLifeCycleStore,\n\tLifeCycleType,\n\tMaybePromise,\n\tUnwrapSchema,\n\tChecksum,\n\tDocumentDecoration,\n\tInferContext,\n\tInferHandler,\n\tResolvePath,\n\tMapResponse,\n\tMacroQueue,\n\tBaseMacro,\n\tMacroManager,\n\tBaseMacroFn,\n\tMacroToProperty,\n\tResolveMacroContext,\n\tMergeElysiaInstances,\n\tMaybeArray,\n\tModelValidator,\n\tMetadataBase,\n\tUnwrapBodySchema,\n\tUnwrapGroupGuardRoute,\n\tModelValidatorError,\n\tExcludeElysiaResponse,\n\tCoExist\n} from './types'\n\nexport { env } from './universal/env'\nexport { file, ElysiaFile } from './universal/file'\nexport type { ElysiaAdapter } from './adapter'\n\nexport { TypeSystemPolicy } from '@sinclair/typebox/system'\nexport type { Static, TSchema } from '@sinclair/typebox'\n",
    "import { Type, Kind } from '@sinclair/typebox'\nimport type {\n\tArrayOptions,\n\tDateOptions,\n\tIntegerOptions,\n\tObjectOptions,\n\tSchemaOptions,\n\tTAnySchema,\n\tTArray,\n\tTBoolean,\n\tTDate,\n\tTEnumValue,\n\tTInteger,\n\tTNumber,\n\tTObject,\n\tTProperties,\n\tTSchema,\n\tTString,\n\tNumberOptions,\n\tJavaScriptTypeBuilder,\n\tStringOptions,\n\tTUnsafe\n} from '@sinclair/typebox'\n\nimport './format'\nimport {\n\tcompile,\n\tcreateType,\n\tloadFileType,\n\ttryParse,\n\tvalidateFile\n} from './utils'\nimport {\n\tCookieValidatorOptions,\n\tTFile,\n\tTFiles,\n\tFileOptions,\n\tFilesOptions,\n\tNonEmptyArray,\n\tTForm,\n\tTUnionEnum,\n\tElysiaTransformDecodeBuilder\n} from './types'\n\nimport { ELYSIA_FORM_DATA, form } from '../utils'\nimport { ValidationError } from '../error'\nimport { parseDateTimeEmptySpace } from './format'\n\nconst t = Object.assign({}, Type) as unknown as Omit<\n\tJavaScriptTypeBuilder,\n\t'String' | 'Transform'\n> &\n\ttypeof ElysiaType & {\n\t\tTransform<Type extends TSchema>(\n\t\t\ttype: Type\n\t\t): ElysiaTransformDecodeBuilder<Type>\n\t}\n\ncreateType<TUnionEnum>(\n\t'UnionEnum',\n\t(schema, value) =>\n\t\t(typeof value === 'number' ||\n\t\t\ttypeof value === 'string' ||\n\t\t\tvalue === null) &&\n\t\tschema.enum.includes(value as never)\n)\n\nconst internalFiles = createType<FilesOptions, File[]>(\n\t'Files',\n\t(options, value) => {\n\t\tif (!Array.isArray(value)) return validateFile(options, value)\n\n\t\tif (options.minItems && value.length < options.minItems) return false\n\n\t\tif (options.maxItems && value.length > options.maxItems) return false\n\n\t\tfor (let i = 0; i < value.length; i++)\n\t\t\tif (!validateFile(options, value[i])) return false\n\n\t\treturn true\n\t}\n) as unknown as TFiles\n\nconst internalFormData = createType<TForm, FormData>(\n\t'ElysiaForm',\n\t({ compiler, ...schema }, value) => {\n\t\tif (!(value instanceof FormData)) return false\n\n\t\tif (compiler) {\n\t\t\tif (!(ELYSIA_FORM_DATA in value))\n\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\tif (!compiler.Check(value[ELYSIA_FORM_DATA]))\n\t\t\t\tthrow compiler.Error(value[ELYSIA_FORM_DATA])\n\t\t}\n\n\t\treturn true\n\t}\n) as unknown as TForm\n\ninterface ElysiaStringOptions extends StringOptions {\n\t/**\n\t * Whether the value include JSON escape sequences or not\n\t *\n\t * When using JSON Accelerator, this will bypass the JSON escape sequence validation\n\t *\n\t * Set to `true` if the value doesn't include JSON escape sequences\n\t *\n\t * @default false\n\t */\n\ttrusted?: boolean\n}\n\nexport const ElysiaType = {\n\t// @ts-ignore\n\tString: (property?: ElysiaStringOptions) => Type.String(property),\n\tNumeric: (property?: NumberOptions) => {\n\t\tconst schema = Type.Number(property)\n\t\tconst compiler = compile(schema)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'numeric',\n\t\t\t\t\t\t\tdefault: 0\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.Number(property)\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tconst number = +value\n\t\t\t\tif (isNaN(number)) return value\n\n\t\t\t\tif (property && !compiler.Check(number))\n\t\t\t\t\tthrow compiler.Error(value)\n\n\t\t\t\treturn number\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TNumber\n\t},\n\n\tInteger: (property?: IntegerOptions): TInteger => {\n\t\tconst schema = Type.Integer(property)\n\t\tconst compiler = compile(schema)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'integer',\n\t\t\t\t\t\t\tdefault: 0\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tType.Integer(property)\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tconst number = +value\n\n\t\t\t\tif (!compiler.Check(number)) throw compiler.Error(number)\n\n\t\t\t\treturn number\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TInteger\n\t},\n\n\tDate: (property?: DateOptions) => {\n\t\tconst schema = Type.Date(property)\n\t\tconst compiler = compile(schema)\n\n\t\tconst _default = property?.default\n\t\t\t? new Date(property.default) // in case the default is an ISO string or milliseconds from epoch\n\t\t\t: undefined\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tType.Date(property),\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'date-time',\n\t\t\t\t\t\t\tdefault: _default?.toISOString()\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'date',\n\t\t\t\t\t\t\tdefault: _default?.toISOString()\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.Number({ default: _default?.getTime() })\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'number') {\n\t\t\t\t\tconst date = new Date(value)\n\n\t\t\t\t\tif (!compiler.Check(date)) throw compiler.Error(date)\n\n\t\t\t\t\treturn date\n\t\t\t\t}\n\n\t\t\t\tif (value instanceof Date) return value\n\n\t\t\t\tconst date = new Date(parseDateTimeEmptySpace(value))\n\n\t\t\t\tif (!date || isNaN(date.getTime()))\n\t\t\t\t\tthrow new ValidationError('property', schema, date)\n\n\t\t\t\tif (!compiler.Check(date)) throw compiler.Error(date)\n\n\t\t\t\treturn date\n\t\t\t})\n\t\t\t.Encode((value) => value.toISOString()) as any as TDate\n\t},\n\n\tBooleanString: (property?: SchemaOptions) => {\n\t\tconst schema = Type.Boolean(property)\n\t\tconst compiler = compile(schema)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tt.Boolean(property),\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'boolean',\n\t\t\t\t\t\t\tdefault: false\n\t\t\t\t\t\t})\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'string') return value === 'true'\n\n\t\t\t\tif (value !== undefined && !compiler.Check(value))\n\t\t\t\t\tthrow compiler.Error(value)\n\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TBoolean\n\t},\n\n\tObjectString: <T extends TProperties>(\n\t\tproperties: T,\n\t\toptions?: ObjectOptions\n\t) => {\n\t\tconst schema = t.Object(properties, options)\n\t\tconst compiler = compile(schema)\n\n\t\tconst defaultValue = JSON.stringify(compiler.Create())\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union([\n\t\t\t\t\tt.String({\n\t\t\t\t\t\tformat: 'ObjectString',\n\t\t\t\t\t\tdefault: defaultValue\n\t\t\t\t\t}),\n\t\t\t\t\tschema\n\t\t\t\t])\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\tif (value.charCodeAt(0) !== 123)\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\t\tif (!compiler.Check((value = tryParse(value, schema))))\n\t\t\t\t\t\tthrow compiler.Error(value)\n\n\t\t\t\t\treturn compiler.Decode(value)\n\t\t\t\t}\n\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => {\n\t\t\t\tlet original\n\t\t\t\tif (typeof value === 'string')\n\t\t\t\t\tvalue = tryParse((original = value), schema)\n\n\t\t\t\tif (!compiler.Check(value)) throw compiler.Error(value)\n\n\t\t\t\treturn original ?? JSON.stringify(value)\n\t\t\t}) as any as TObject<T>\n\t},\n\n\tArrayString: <T extends TSchema = TString>(\n\t\tchildren: T = t.String() as any,\n\t\toptions?: ArrayOptions\n\t) => {\n\t\tconst schema = t.Array(children, options)\n\t\tconst compiler = compile(schema)\n\n\t\tconst decode = (value: string, isProperty = false) => {\n\t\t\tif (value.charCodeAt(0) === 91) {\n\t\t\t\tif (!compiler.Check((value = tryParse(value, schema))))\n\t\t\t\t\tthrow compiler.Error(value)\n\n\t\t\t\treturn compiler.Decode(value)\n\t\t\t}\n\n\t\t\t// has , (as used in nuqs)\n\t\t\tif (value.indexOf(',') !== -1) {\n\t\t\t\t// const newValue = value.split(',').map((v) => v.trim())\n\n\t\t\t\tif (!compiler.Check(value)) throw compiler.Error(value)\n\n\t\t\t\treturn compiler.Decode(value)\n\t\t\t}\n\n\t\t\tif (isProperty) return value\n\n\t\t\tthrow new ValidationError('property', schema, value)\n\t\t}\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union([\n\t\t\t\t\tt.String({\n\t\t\t\t\t\tformat: 'ArrayString',\n\t\t\t\t\t\tdefault: options?.default\n\t\t\t\t\t}),\n\t\t\t\t\tschema\n\t\t\t\t])\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tlet values = <unknown[]>[]\n\n\t\t\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\t\t\tconst v = value[i]\n\t\t\t\t\t\tif (typeof v === 'string') {\n\t\t\t\t\t\t\tconst t = decode(v, true)\n\t\t\t\t\t\t\tif (Array.isArray(t)) values = values.concat(t)\n\t\t\t\t\t\t\telse values.push(t)\n\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvalues.push(v)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn values\n\t\t\t\t}\n\n\t\t\t\tif (typeof value === 'string') return decode(value)\n\n\t\t\t\t// Is probably transformed, unable to check schema\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => {\n\t\t\t\tlet original\n\t\t\t\tif (typeof value === 'string')\n\t\t\t\t\tvalue = tryParse((original = value), schema)\n\n\t\t\t\tif (!compiler.Check(value))\n\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\treturn original ?? JSON.stringify(value)\n\t\t\t}) as any as TArray<T>\n\t},\n\n\tFile: createType<FileOptions, File>(\n\t\t'File',\n\t\tvalidateFile\n\t) as unknown as TFile,\n\n\tFiles: (options: FilesOptions = {}): TUnsafe<File[]> =>\n\t\tt\n\t\t\t.Transform(internalFiles(options))\n\t\t\t.Decode((value) => {\n\t\t\t\tif (Array.isArray(value)) return value\n\t\t\t\treturn [value]\n\t\t\t})\n\t\t\t.Encode((value) => value) as unknown as TUnsafe<File[]>,\n\n\tNullable: <T extends TSchema>(schema: T, options?: SchemaOptions) =>\n\t\tt.Union([schema, t.Null()], options),\n\n\t/**\n\t * Allow Optional, Nullable and Undefined\n\t */\n\tMaybeEmpty: <T extends TSchema>(schema: T, options?: SchemaOptions) =>\n\t\tt.Union([schema, t.Null(), t.Undefined()], options),\n\n\tCookie: <T extends TProperties>(\n\t\tproperties: T,\n\t\t{\n\t\t\tdomain,\n\t\t\texpires,\n\t\t\thttpOnly,\n\t\t\tmaxAge,\n\t\t\tpath,\n\t\t\tpriority,\n\t\t\tsameSite,\n\t\t\tsecure,\n\t\t\tsecrets,\n\t\t\tsign,\n\t\t\t...options\n\t\t}: CookieValidatorOptions<T> = {}\n\t) => {\n\t\tconst v = t.Object(properties, options)\n\n\t\tv.config = {\n\t\t\tdomain,\n\t\t\texpires,\n\t\t\thttpOnly,\n\t\t\tmaxAge,\n\t\t\tpath,\n\t\t\tpriority,\n\t\t\tsameSite,\n\t\t\tsecure,\n\t\t\tsecrets,\n\t\t\tsign\n\t\t}\n\n\t\treturn v\n\t},\n\n\tUnionEnum: <\n\t\tconst T extends\n\t\t\t| NonEmptyArray<TEnumValue>\n\t\t\t| Readonly<NonEmptyArray<TEnumValue>>\n\t>(\n\t\tvalues: T,\n\t\toptions: SchemaOptions = {}\n\t) => {\n\t\tconst type = values.every((value) => typeof value === 'string')\n\t\t\t? { type: 'string' }\n\t\t\t: values.every((value) => typeof value === 'number')\n\t\t\t\t? { type: 'number' }\n\t\t\t\t: values.every((value) => value === null)\n\t\t\t\t\t? { type: 'null' }\n\t\t\t\t\t: {}\n\n\t\tif (values.some((x) => typeof x === 'object' && x !== null))\n\t\t\tthrow new Error('This type does not support objects or arrays')\n\n\t\treturn {\n\t\t\t// default is need for generating error message\n\t\t\tdefault: values[0],\n\t\t\t...options,\n\t\t\t[Kind]: 'UnionEnum',\n\t\t\t...type,\n\t\t\tenum: values\n\t\t} as any as TUnionEnum<T>\n\t},\n\n\tNoValidate: <T extends TAnySchema>(v: T, enabled = true) => {\n\t\tv.noValidate = enabled\n\n\t\treturn v\n\t},\n\n\tForm: <T extends TProperties>(\n\t\tv: T,\n\t\toptions: ObjectOptions = {}\n\t): TForm<T> => {\n\t\tconst schema = t.Object(v, {\n\t\t\tdefault: form({}),\n\t\t\t...options\n\t\t})\n\t\tconst compiler = compile(schema)\n\n\t\treturn t.Union([\n\t\t\tschema,\n\t\t\t// @ts-expect-error\n\t\t\tinternalFormData({\n\t\t\t\tcompiler\n\t\t\t})\n\t\t])\n\t}\n}\n\nt.BooleanString = ElysiaType.BooleanString\nt.ObjectString = ElysiaType.ObjectString\nt.ArrayString = ElysiaType.ArrayString\nt.Numeric = ElysiaType.Numeric\nt.Integer = ElysiaType.Integer\n\nt.File = (arg) => {\n\tif (arg?.type) loadFileType()\n\n\treturn ElysiaType.File({\n\t\tdefault: 'File',\n\t\t...arg,\n\t\textension: arg?.type,\n\t\ttype: 'string',\n\t\tformat: 'binary'\n\t})\n}\n\nt.Files = (arg) => {\n\tif (arg?.type) loadFileType()\n\n\treturn ElysiaType.Files({\n\t\t...arg,\n\t\telysiaMeta: 'Files',\n\t\tdefault: 'Files',\n\t\textension: arg?.type,\n\t\ttype: 'array',\n\t\titems: {\n\t\t\t...arg,\n\t\t\tdefault: 'Files',\n\t\t\ttype: 'string',\n\t\t\tformat: 'binary'\n\t\t}\n\t})\n}\n\nt.Nullable = (schema) => ElysiaType.Nullable(schema)\nt.MaybeEmpty = ElysiaType.MaybeEmpty as any\nt.Cookie = ElysiaType.Cookie\nt.Date = ElysiaType.Date\nt.UnionEnum = ElysiaType.UnionEnum\nt.NoValidate = ElysiaType.NoValidate\nt.Form = ElysiaType.Form\n\nexport { t }\n\nexport {\n\tTypeSystemPolicy,\n\tTypeSystem,\n\tTypeSystemDuplicateFormat,\n\tTypeSystemDuplicateTypeKind\n} from '@sinclair/typebox/system'\nexport { TypeRegistry, FormatRegistry } from '@sinclair/typebox'\nexport { TypeCompiler, TypeCheck } from '@sinclair/typebox/compiler'\n",
    "import { FormatRegistry } from '@sinclair/typebox'\n\n/**\n * ? Fork of ajv-formats without ajv as dependencies\n *\n * @see https://github.com/ajv-validator/ajv-formats/blob/master/src/formats.ts\n **/\n\n/* eslint-disable no-control-regex */\nexport type FormatName =\n\t| 'date'\n\t| 'time'\n\t| 'date-time'\n\t| 'iso-time'\n\t| 'iso-date-time'\n\t| 'duration'\n\t| 'uri'\n\t| 'uri-reference'\n\t| 'uri-template'\n\t| 'url'\n\t| 'email'\n\t| 'hostname'\n\t| 'ipv4'\n\t| 'ipv6'\n\t| 'regex'\n\t| 'uuid'\n\t| 'json-pointer'\n\t| 'json-pointer-uri-fragment'\n\t| 'relative-json-pointer'\n\t| 'byte'\n\t| 'int32'\n\t| 'int64'\n\t| 'float'\n\t| 'double'\n\t| 'password'\n\t| 'binary'\n\nexport const fullFormats = {\n\t// date: http://tools.ietf.org/html/rfc3339#section-5.6\n\tdate,\n\t// date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n\ttime: getTime(true),\n\t'date-time': getDateTime(true),\n\t'iso-time': getTime(false),\n\t'iso-date-time': getDateTime(false),\n\t// duration: https://tools.ietf.org/html/rfc3339#appendix-A\n\tduration:\n\t\t/^P(?!$)((\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?|(\\d+W)?)$/,\n\turi,\n\t'uri-reference':\n\t\t/^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,\n\t// uri-template: https://tools.ietf.org/html/rfc6570\n\t'uri-template':\n\t\t/^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n\t// For the source: https://gist.github.com/dperini/729294\n\t// For test cases: https://mathiasbynens.be/demo/url-regex\n\turl: /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n\temail: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n\thostname:\n\t\t/^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i,\n\t// optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n\tipv4: /^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/,\n\tipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i,\n\tregex,\n\t// uuid: http://tools.ietf.org/html/rfc4122\n\tuuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n\t// JSON-pointer: https://tools.ietf.org/html/rfc6901\n\t// uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n\t'json-pointer': /^(?:\\/(?:[^~/]|~0|~1)*)*$/,\n\t'json-pointer-uri-fragment':\n\t\t/^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n\t// relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n\t'relative-json-pointer': /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n\t// the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types\n\t// byte: https://github.com/miguelmota/is-base64\n\tbyte,\n\t// signed 32 bit integer\n\tint32: { type: 'number', validate: validateInt32 },\n\t// signed 64 bit integer\n\tint64: { type: 'number', validate: validateInt64 },\n\t// C-type float\n\tfloat: { type: 'number', validate: validateNumber },\n\t// C-type double\n\tdouble: { type: 'number', validate: validateNumber },\n\t// hint to the UI to hide input strings\n\tpassword: true,\n\t// unchecked string payload\n\tbinary: true\n} as const\n\nfunction isLeapYear(year: number): boolean {\n\t// https://tools.ietf.org/html/rfc3339#appendix-C\n\treturn year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)\n}\n\nconst DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\nfunction date(str: string): boolean {\n\t// full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n\tconst matches: string[] | null = DATE.exec(str)\n\tif (!matches) return false\n\tconst year: number = +matches[1]\n\tconst month: number = +matches[2]\n\tconst day: number = +matches[3]\n\treturn (\n\t\tmonth >= 1 &&\n\t\tmonth <= 12 &&\n\t\tday >= 1 &&\n\t\tday <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month])\n\t)\n}\n\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d(?:\\.\\d+)?)(z|([+-])(\\d\\d)(?::?(\\d\\d))?)?$/i\n\nfunction getTime(strictTimeZone?: boolean): (str: string) => boolean {\n\treturn function time(str: string): boolean {\n\t\tconst matches: string[] | null = TIME.exec(str)\n\t\tif (!matches) return false\n\t\tconst hr: number = +matches[1]\n\t\tconst min: number = +matches[2]\n\t\tconst sec: number = +matches[3]\n\t\tconst tz: string | undefined = matches[4]\n\t\tconst tzSign: number = matches[5] === '-' ? -1 : 1\n\t\tconst tzH: number = +(matches[6] || 0)\n\t\tconst tzM: number = +(matches[7] || 0)\n\t\tif (tzH > 23 || tzM > 59 || (strictTimeZone && !tz)) return false\n\t\tif (hr <= 23 && min <= 59 && sec < 60) return true\n\t\t// leap second\n\t\tconst utcMin = min - tzM * tzSign\n\t\tconst utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0)\n\t\treturn (\n\t\t\t(utcHr === 23 || utcHr === -1) &&\n\t\t\t(utcMin === 59 || utcMin === -1) &&\n\t\t\tsec < 61\n\t\t)\n\t}\n}\n\nexport const parseDateTimeEmptySpace = (str: string) => {\n\tif (str.charCodeAt(str.length - 6) === 32)\n\t\treturn str.slice(0, -6) + '+' + str.slice(-5)\n\n\treturn str\n}\n\nconst DATE_TIME_SEPARATOR = /t|\\s/i\nfunction getDateTime(strictTimeZone?: boolean): (str: string) => boolean {\n\tconst time = getTime(strictTimeZone)\n\n\treturn function date_time(str: string): boolean {\n\t\t// http://tools.ietf.org/html/rfc3339#section-5.6\n\t\tconst dateTime: string[] = str.split(DATE_TIME_SEPARATOR)\n\n\t\treturn dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1])\n\t}\n}\n\nconst NOT_URI_FRAGMENT = /\\/|:/\nconst URI =\n\t/^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i\n\nfunction uri(str: string): boolean {\n\t// http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n\treturn NOT_URI_FRAGMENT.test(str) && URI.test(str)\n}\n\nconst BYTE =\n\t/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm\n\nfunction byte(str: string): boolean {\n\tBYTE.lastIndex = 0\n\treturn BYTE.test(str)\n}\n\nconst MIN_INT32 = -(2 ** 31)\nconst MAX_INT32 = 2 ** 31 - 1\n\nfunction validateInt32(value: number): boolean {\n\treturn Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32\n}\n\nfunction validateInt64(value: number): boolean {\n\t// JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64\n\treturn Number.isInteger(value)\n}\n\nfunction validateNumber(): boolean {\n\treturn true\n}\n\nconst Z_ANCHOR = /[^\\\\]\\\\Z/\nfunction regex(str: string): boolean {\n\tif (Z_ANCHOR.test(str)) return false\n\ttry {\n\t\tnew RegExp(str)\n\t\treturn true\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\n/**\n * @license\n *\n * MIT License\n *\n * Copyright (c) 2020 Evgeny Poberezkin\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nconst isISO8601 =\n\t/(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/\n\nconst isFormalDate =\n\t/(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s\\d{2}\\s\\d{4}\\s\\d{2}:\\d{2}:\\d{2}\\sGMT(?:\\+|-)\\d{4}\\s\\([^)]+\\)/\n\nconst isShortenDate =\n\t/^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\\s-](?:0?[1-9]|1[0-2])[/\\s-](?:19|20)\\d{2})|(?:(?:19|20)\\d{2}[/\\s-](?:0?[1-9]|1[0-2])[/\\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\\s[AP]M)?)?$/\n\nconst _validateDate = fullFormats.date\nconst _validateDateTime = fullFormats['date-time']\n\nif (!FormatRegistry.Has('date'))\n\tFormatRegistry.Set('date', (value: string) => {\n\t\t// Remove quote from stringified date\n\t\tconst temp = parseDateTimeEmptySpace(value).replace(/\"/g, '')\n\n\t\tif (\n\t\t\tisISO8601.test(temp) ||\n\t\t\tisFormalDate.test(temp) ||\n\t\t\tisShortenDate.test(temp) ||\n\t\t\t_validateDate(temp)\n\t\t) {\n\t\t\tconst date = new Date(temp)\n\t\t\tif (!Number.isNaN(date.getTime())) return true\n\t\t}\n\n\t\treturn false\n\t})\n\nif (!FormatRegistry.Has('date-time'))\n\tFormatRegistry.Set('date-time', (value: string) => {\n\t\t// Remove quote from stringified date\n\t\tconst temp = value.replace(/\"/g, '')\n\n\t\tif (\n\t\t\tisISO8601.test(temp) ||\n\t\t\tisFormalDate.test(temp) ||\n\t\t\tisShortenDate.test(temp) ||\n\t\t\t_validateDateTime(temp)\n\t\t) {\n\t\t\tconst date = new Date(temp)\n\t\t\tif (!Number.isNaN(date.getTime())) return true\n\t\t}\n\n\t\treturn false\n\t})\n\nObject.entries(fullFormats).forEach((formatEntry) => {\n\tconst [formatName, formatValue] = formatEntry\n\n\tif (!FormatRegistry.Has(formatName)) {\n\t\tif (formatValue instanceof RegExp)\n\t\t\tFormatRegistry.Set(formatName, (value) => formatValue.test(value))\n\t\telse if (typeof formatValue === 'function')\n\t\t\tFormatRegistry.Set(formatName, formatValue)\n\t}\n})\n\nif (!FormatRegistry.Has('numeric'))\n\tFormatRegistry.Set('numeric', (value) => !!value && !isNaN(+value))\n\nif (!FormatRegistry.Has('integer'))\n\tFormatRegistry.Set(\n\t\t'integer',\n\t\t(value) => !!value && Number.isInteger(+value)\n\t)\n\nif (!FormatRegistry.Has('boolean'))\n\tFormatRegistry.Set(\n\t\t'boolean',\n\t\t(value) => value === 'true' || value === 'false'\n\t)\n\nif (!FormatRegistry.Has('ObjectString'))\n\tFormatRegistry.Set('ObjectString', (value) => {\n\t\tlet start = value.charCodeAt(0)\n\n\t\t// If starts with ' ', '\\t', '\\n', then trim first\n\t\tif (start === 9 || start === 10 || start === 32)\n\t\t\tstart = value.trimStart().charCodeAt(0)\n\n\t\tif (start !== 123 && start !== 91) return false\n\n\t\ttry {\n\t\t\tJSON.parse(value)\n\n\t\t\treturn true\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t})\n\nif (!FormatRegistry.Has('ArrayString'))\n\tFormatRegistry.Set('ArrayString', (value) => {\n\t\tlet start = value.charCodeAt(0)\n\n\t\t// If starts with ' ', '\\t', '\\n', then trim first\n\t\tif (start === 9 || start === 10 || start === 32)\n\t\t\tstart = value.trimStart().charCodeAt(0)\n\n\t\tif (start !== 123 && start !== 91) return false\n\n\t\ttry {\n\t\t\tJSON.parse(value)\n\n\t\t\treturn true\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t})\n",
    "import {\n\tKind,\n\tTUnsafe,\n\tTypeRegistry,\n\tUnsafe,\n\ttype TAnySchema\n} from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeCheck, TypeCompiler } from '@sinclair/typebox/compiler'\n\nimport { ElysiaFile } from '../universal/file'\nimport { InvalidFileType, ValidationError } from '../error'\nimport type { FileOptions, FileUnit } from './types'\n\nexport const tryParse = (v: unknown, schema: TAnySchema) => {\n\ttry {\n\t\treturn JSON.parse(v as string)\n\t} catch {\n\t\tthrow new ValidationError('property', schema, v)\n\t}\n}\n\nexport function createType<TSchema = unknown, TReturn = unknown>(\n\tkind: string,\n\tfunc: TypeRegistry.TypeRegistryValidationFunction<TSchema>\n): TUnsafe<TReturn> {\n\tif (!TypeRegistry.Has(kind)) TypeRegistry.Set<TSchema>(kind, func)\n\n\treturn ((options = {}) => Unsafe({ ...options, [Kind]: kind })) as any\n}\n\nexport const compile = <T extends TAnySchema>(schema: T) => {\n\ttry {\n\t\tconst compiler = TypeCompiler.Compile(schema) as TypeCheck<T> & {\n\t\t\tCreate(): T['static']\n\t\t\tError(v: unknown): asserts v is T['static']\n\t\t}\n\n\t\tcompiler.Create = () => Value.Create(schema)\n\t\tcompiler.Error = (v: unknown) =>\n\t\t\tnew ValidationError('property', schema, v, compiler.Errors(v))\n\n\t\treturn compiler\n\t} catch {\n\t\treturn {\n\t\t\tCheck: (v: unknown) => Value.Check(schema, v),\n\t\t\tCheckThrow: (v: unknown) => {\n\t\t\t\tif (!Value.Check(schema, v))\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'property',\n\t\t\t\t\t\tschema,\n\t\t\t\t\t\tv,\n\t\t\t\t\t\tValue.Errors(schema, v)\n\t\t\t\t\t)\n\t\t\t},\n\t\t\tDecode: (v: unknown) => Value.Decode(schema, v),\n\t\t\tCreate: () => Value.Create(schema),\n\t\t\tError: (v: unknown) =>\n\t\t\t\tnew ValidationError(\n\t\t\t\t\t'property',\n\t\t\t\t\tschema,\n\t\t\t\t\tv,\n\t\t\t\t\tValue.Errors(schema, v)\n\t\t\t\t)\n\t\t}\n\t}\n}\n\nexport const parseFileUnit = (size: FileUnit) => {\n\tif (typeof size === 'string')\n\t\tswitch (size.slice(-1)) {\n\t\t\tcase 'k':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1024\n\n\t\t\tcase 'm':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1048576\n\n\t\t\tdefault:\n\t\t\t\treturn +size\n\t\t}\n\n\treturn size\n}\n\nexport const checkFileExtension = (type: string, extension: string) => {\n\tif (type.startsWith(extension)) return true\n\n\treturn (\n\t\textension.charCodeAt(extension.length - 1) === 42 &&\n\t\textension.charCodeAt(extension.length - 2) === 47 &&\n\t\ttype.startsWith(extension.slice(0, -1))\n\t)\n}\n\nlet _fileTypeFromBlobWarn = false\nconst warnIfFileTypeIsNotInstalled = () => {\n\tif (!_fileTypeFromBlobWarn) {\n\t\tconsole.warn(\n\t\t\t\"[Elysia] Attempt to validate file type without 'file-type'. This may lead to security risks. We recommend installing 'file-type' to properly validate file extension.\"\n\t\t)\n\t\t_fileTypeFromBlobWarn = true\n\t}\n}\n\nexport const loadFileType = async () =>\n\timport('file-type')\n\t\t.then((x) => {\n\t\t\t_fileTypeFromBlob = x.fileTypeFromBlob\n\t\t\treturn _fileTypeFromBlob\n\t\t})\n\t\t.catch(warnIfFileTypeIsNotInstalled)\n\nlet _fileTypeFromBlob: Function\nexport const fileTypeFromBlob = (file: Blob | File) => {\n\tif (_fileTypeFromBlob) return _fileTypeFromBlob(file)\n\n\treturn loadFileType().then((mod) => {\n\t\tif (mod) return mod(file)\n\t})\n}\n\nexport const validateFileExtension = async (\n\tfile: Blob | File | undefined,\n\textension: string | string[],\n\t// @ts-ignore\n\tname = file?.name ?? ''\n) => {\n\tif (!file) return\n\n\tconst result = await fileTypeFromBlob(file)\n\tif (!result) throw new InvalidFileType(name, extension)\n\n\tif (typeof extension === 'string')\n\t\tif (!checkFileExtension(result.mime, extension))\n\t\t\tthrow new InvalidFileType(name, extension)\n\n\tfor (let i = 0; i < extension.length; i++)\n\t\tif (checkFileExtension(result.mime, extension[i])) return true\n\n\tthrow new InvalidFileType(name, extension)\n}\n\nexport const validateFile = (options: FileOptions, value: any) => {\n\tif (value instanceof ElysiaFile) return true\n\n\tif (!(value instanceof Blob)) return false\n\n\tif (options.minSize && value.size < parseFileUnit(options.minSize))\n\t\treturn false\n\n\tif (options.maxSize && value.size > parseFileUnit(options.maxSize))\n\t\treturn false\n\n\t// This only check file extension based on it's name / mimetype\n\t// to actual check the file type, use `validateFileExtension` instead\n\tif (options.extension) {\n\t\tif (typeof options.extension === 'string')\n\t\t\treturn checkFileExtension(value.type, options.extension)\n\n\t\tfor (let i = 0; i < options.extension.length; i++)\n\t\t\tif (checkFileExtension(value.type, options.extension[i]))\n\t\t\t\treturn true\n\n\t\treturn false\n\t}\n\n\treturn true\n}\n",
    "// @ts-ignore\nexport const isBun = typeof Bun !== 'undefined'\n// @ts-ignore\nexport const isDeno = typeof Deno !== 'undefined'\n",
    "/* eslint-disable sonarjs/no-duplicate-string */\nimport { type createReadStream as CreateReadStream } from 'fs'\nimport { type stat as Stat } from 'fs/promises'\n\nimport { isBun } from './utils'\nimport type { BunFile } from 'bun'\nimport type { MaybePromise } from '../types'\n\nexport const mime = {\n\taac: 'audio/aac',\n\tabw: 'application/x-abiword',\n\tai: 'application/postscript',\n\tarc: 'application/octet-stream',\n\tavi: 'video/x-msvideo',\n\tazw: 'application/vnd.amazon.ebook',\n\tbin: 'application/octet-stream',\n\tbz: 'application/x-bzip',\n\tbz2: 'application/x-bzip2',\n\tcsh: 'application/x-csh',\n\tcss: 'text/css',\n\tcsv: 'text/csv',\n\tdoc: 'application/msword',\n\tdll: 'application/octet-stream',\n\teot: 'application/vnd.ms-fontobject',\n\tepub: 'application/epub+zip',\n\tgif: 'image/gif',\n\thtm: 'text/html',\n\thtml: 'text/html',\n\tico: 'image/x-icon',\n\tics: 'text/calendar',\n\tjar: 'application/java-archive',\n\tjpeg: 'image/jpeg',\n\tjpg: 'image/jpeg',\n\tjs: 'application/javascript',\n\tjson: 'application/json',\n\tmid: 'audio/midi',\n\tmidi: 'audio/midi',\n\tmp2: 'audio/mpeg',\n\tmp3: 'audio/mpeg',\n\tmp4: 'video/mp4',\n\tmpa: 'video/mpeg',\n\tmpe: 'video/mpeg',\n\tmpeg: 'video/mpeg',\n\tmpkg: 'application/vnd.apple.installer+xml',\n\todp: 'application/vnd.oasis.opendocument.presentation',\n\tods: 'application/vnd.oasis.opendocument.spreadsheet',\n\todt: 'application/vnd.oasis.opendocument.text',\n\toga: 'audio/ogg',\n\togv: 'video/ogg',\n\togx: 'application/ogg',\n\totf: 'font/otf',\n\tpng: 'image/png',\n\tpdf: 'application/pdf',\n\tppt: 'application/vnd.ms-powerpoint',\n\trar: 'application/x-rar-compressed',\n\trtf: 'application/rtf',\n\tsh: 'application/x-sh',\n\tsvg: 'image/svg+xml',\n\tswf: 'application/x-shockwave-flash',\n\ttar: 'application/x-tar',\n\ttif: 'image/tiff',\n\ttiff: 'image/tiff',\n\tts: 'application/typescript',\n\tttf: 'font/ttf',\n\ttxt: 'text/plain',\n\tvsd: 'application/vnd.visio',\n\twav: 'audio/x-wav',\n\tweba: 'audio/webm',\n\twebm: 'video/webm',\n\twebp: 'image/webp',\n\twoff: 'font/woff',\n\twoff2: 'font/woff2',\n\txhtml: 'application/xhtml+xml',\n\txls: 'application/vnd.ms-excel',\n\txlsx: 'application/vnd.ms-excel',\n\txlsx_OLD:\n\t\t'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n\txml: 'application/xml',\n\txul: 'application/vnd.mozilla.xul+xml',\n\tzip: 'application/zip',\n\t'3gp': 'video/3gpp',\n\t'3gp_DOES_NOT_CONTAIN_VIDEO': 'audio/3gpp',\n\t'3gp2': 'video/3gpp2',\n\t'3gp2_DOES_NOT_CONTAIN_VIDEO': 'audio/3gpp2',\n\t'7z': 'application/x-7z-compressed'\n} as const\n\nexport const getFileExtension = (path: string) => {\n\tconst index = path.lastIndexOf('.')\n\tif (index === -1) return ''\n\n\treturn path.slice(index + 1)\n}\n\nexport const file = (path: string) => new ElysiaFile(path)\n\nlet createReadStream: typeof CreateReadStream\nlet stat: typeof Stat\n\nexport class ElysiaFile {\n\treadonly value: MaybePromise<unknown>\n\treadonly stats: ReturnType<typeof Stat> | undefined\n\n\tconstructor(public path: string) {\n\t\tif (isBun) this.value = Bun.file(path)\n\t\telse {\n\t\t\t// Browser\n\t\t\t// @ts-ignore\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\tconsole.warn('Browser environment does not support file')\n\t\t\t} else {\n\t\t\t\tif (!createReadStream || !stat) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.value = import('fs').then((fs) => {\n\t\t\t\t\t\t\tcreateReadStream = fs.createReadStream\n\n\t\t\t\t\t\t\treturn fs.createReadStream(path)\n\t\t\t\t\t\t})\n\t\t\t\t\t\tthis.stats = import('fs/promises').then((fs) => {\n\t\t\t\t\t\t\tstat = fs.stat\n\n\t\t\t\t\t\t\treturn fs.stat(path)\n\t\t\t\t\t\t})\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// not empty\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.value = createReadStream(path)\n\t\t\t\t\tthis.stats = stat(path)!\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn (\n\t\t\t// @ts-ignore\n\t\t\tmime[getFileExtension(this.path)] || 'application/octet-stream'\n\t\t)\n\t}\n\n\tget length() {\n\t\tif (isBun) return (this.value as BunFile).size\n\n\t\treturn this.stats?.then((x) => x.size) ?? 0\n\t}\n}\n",
    "import type { TSchema } from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport type {\n\tTypeCheck,\n\tValueError,\n\tValueErrorIterator\n} from '@sinclair/typebox/compiler'\n\nimport { StatusMap, InvertedStatusMap } from './utils'\nimport type { ElysiaTypeCheck } from './schema'\n\n// ? Cloudflare worker support\nconst env =\n\ttypeof Bun !== 'undefined'\n\t\t? Bun.env\n\t\t: typeof process !== 'undefined'\n\t\t\t? process?.env\n\t\t\t: undefined\n\nexport const ERROR_CODE = Symbol('ElysiaErrorCode')\nexport type ERROR_CODE = typeof ERROR_CODE\n\nexport const isProduction = (env?.NODE_ENV ?? env?.ENV) === 'production'\n\nexport type ElysiaErrors =\n\t| InternalServerError\n\t| NotFoundError\n\t| ParseError\n\t| ValidationError\n\t| InvalidCookieSignature\n\nexport class ElysiaCustomStatusResponse<\n\tconst in out Code extends number | keyof StatusMap,\n\tconst in out T = Code extends keyof InvertedStatusMap\n\t\t? InvertedStatusMap[Code]\n\t\t: Code,\n\tconst in out Status extends Code extends keyof StatusMap\n\t\t? StatusMap[Code]\n\t\t: Code = Code extends keyof StatusMap ? StatusMap[Code] : Code\n> {\n\tcode: Status\n\tresponse: T\n\n\tconstructor(code: Code, response: T) {\n\t\tconst res =\n\t\t\tresponse ??\n\t\t\t(code in InvertedStatusMap\n\t\t\t\t? // @ts-expect-error Always correct\n\t\t\t\t\tInvertedStatusMap[code]\n\t\t\t\t: code)\n\n\t\t// @ts-ignore Trust me bro\n\t\tthis.code = StatusMap[code] ?? code\n\t\tthis.response = res\n\t}\n}\n\nexport const status = <\n\tconst Code extends number | keyof StatusMap,\n\tconst T = Code extends keyof InvertedStatusMap\n\t\t? InvertedStatusMap[Code]\n\t\t: Code\n>(\n\tcode: Code,\n\tresponse?: T\n) => new ElysiaCustomStatusResponse<Code, T>(code, response as any)\n\n/**\n * @deprecated use `Elysia.status` instead\n */\nexport const error = status\n\nexport class InternalServerError extends Error {\n\tcode = 'INTERNAL_SERVER_ERROR'\n\tstatus = 500\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'INTERNAL_SERVER_ERROR')\n\t}\n}\n\nexport class NotFoundError extends Error {\n\tcode = 'NOT_FOUND'\n\tstatus = 404\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'NOT_FOUND')\n\t}\n}\n\nexport class ParseError extends Error {\n\tcode = 'PARSE'\n\tstatus = 400\n\n\tconstructor(cause?: Error) {\n\t\tsuper('Bad Request', {\n\t\t\tcause\n\t\t})\n\t}\n}\n\nexport class InvalidCookieSignature extends Error {\n\tcode = 'INVALID_COOKIE_SIGNATURE'\n\tstatus = 400\n\n\tconstructor(\n\t\tpublic key: string,\n\t\tmessage?: string\n\t) {\n\t\tsuper(message ?? `\"${key}\" has invalid cookie signature`)\n\t}\n}\n\nexport const mapValueError = (error: ValueError | undefined) => {\n\tif (!error)\n\t\treturn {\n\t\t\tsummary: undefined\n\t\t}\n\n\tconst { message, path, value, type } = error\n\n\tconst property = path.slice(1).replaceAll('/', '.')\n\tconst isRoot = path === ''\n\n\tswitch (type) {\n\t\tcase 42:\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: isRoot\n\t\t\t\t\t? `Value should not be provided`\n\t\t\t\t\t: `Property '${property}' should not be provided`\n\t\t\t}\n\n\t\tcase 45:\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: isRoot\n\t\t\t\t\t? `Value is missing`\n\t\t\t\t\t: `Property '${property}' is missing`\n\t\t\t}\n\n\t\tcase 50:\n\t\t\t// Expected string to match 'email' format\n\t\t\tconst quoteIndex = message.indexOf(\"'\")!\n\t\t\tconst format = message.slice(\n\t\t\t\tquoteIndex + 1,\n\t\t\t\tmessage.indexOf(\"'\", quoteIndex + 1)\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: isRoot\n\t\t\t\t\t? `Value should be an email`\n\t\t\t\t\t: `Property '${property}' should be ${format}`\n\t\t\t}\n\n\t\tcase 54:\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: `${message\n\t\t\t\t\t.slice(0, 9)\n\t\t\t\t\t.trim()} property '${property}' to be ${message\n\t\t\t\t\t.slice(8)\n\t\t\t\t\t.trim()} but found: ${value}`\n\t\t\t}\n\n\t\tcase 62:\n\t\t\tconst union = error.schema.anyOf\n\t\t\t\t.map((x: Record<string, unknown>) => `'${x?.format ?? x.type}'`)\n\t\t\t\t.join(', ')\n\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: isRoot\n\t\t\t\t\t? `Value should be one of ${union}`\n\t\t\t\t\t: `Property '${property}' should be one of: ${union}`\n\t\t\t}\n\n\t\tdefault:\n\t\t\treturn { summary: message, ...error }\n\t}\n}\n\nexport class InvalidFileType extends Error {\n\tcode = 'INVALID_FILE_TYPE'\n\tstatus = 422\n\n\tconstructor(\n\t\tpublic property: string,\n\t\tpublic expected: string | string[],\n\t\tpublic message = `\"${property}\" has invalid file type`\n\t) {\n\t\tsuper(message)\n\n\t\tObject.setPrototypeOf(this, InvalidFileType.prototype)\n\t}\n\n\ttoResponse(headers?: Record<string, any>) {\n\t\tif (isProduction)\n\t\t\treturn new Response(\n\t\t\t\tJSON.stringify({\n\t\t\t\t\ttype: 'validation',\n\t\t\t\t\ton: 'body'\n\t\t\t\t}),\n\t\t\t\t{\n\t\t\t\t\tstatus: 422,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t...headers,\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t)\n\n\t\treturn new Response(\n\t\t\tJSON.stringify({\n\t\t\t\ttype: 'validation',\n\t\t\t\ton: 'body',\n\t\t\t\tsummary: 'Invalid file type',\n\t\t\t\tmessage: this.message,\n\t\t\t\tproperty: this.property,\n\t\t\t\texpected: this.expected\n\t\t\t}),\n\t\t\t{\n\t\t\t\tstatus: 422,\n\t\t\t\theaders: {\n\t\t\t\t\t...headers,\n\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\t}\n}\n\nexport class ValidationError extends Error {\n\tcode = 'VALIDATION'\n\tstatus = 422\n\n\tconstructor(\n\t\tpublic type: string,\n\t\tpublic validator: TSchema | TypeCheck<any> | ElysiaTypeCheck<any>,\n\t\tpublic value: unknown,\n\t\terrors?: ValueErrorIterator\n\t) {\n\t\tif (\n\t\t\tvalue &&\n\t\t\ttypeof value === 'object' &&\n\t\t\tvalue instanceof ElysiaCustomStatusResponse\n\t\t)\n\t\t\tvalue = value.response\n\n\t\tconst error =\n\t\t\terrors?.First() ||\n\t\t\t(isProduction\n\t\t\t\t? undefined\n\t\t\t\t: 'Errors' in validator\n\t\t\t\t\t? validator.Errors(value).First()\n\t\t\t\t\t: Value.Errors(validator, value).First())\n\n\t\tconst customError =\n\t\t\terror?.schema?.message || error?.schema?.error !== undefined\n\t\t\t\t? typeof error.schema.error === 'function'\n\t\t\t\t\t? error.schema.error({\n\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\tvalidator,\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tget errors() {\n\t\t\t\t\t\t\t\treturn [...validator.Errors(value)].map(\n\t\t\t\t\t\t\t\t\tmapValueError\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t: error.schema.error\n\t\t\t\t: undefined\n\n\t\tconst accessor = error?.path || 'root'\n\t\tlet message = ''\n\n\t\tif (customError !== undefined) {\n\t\t\tmessage =\n\t\t\t\ttypeof customError === 'object'\n\t\t\t\t\t? JSON.stringify(customError)\n\t\t\t\t\t: customError + ''\n\t\t} else if (isProduction) {\n\t\t\tmessage = JSON.stringify({\n\t\t\t\ttype: 'validation',\n\t\t\t\ton: type,\n\t\t\t\tsummary: mapValueError(error).summary,\n\t\t\t\tmessage: error?.message,\n\t\t\t\tfound: value\n\t\t\t})\n\t\t} else {\n\t\t\t// @ts-ignore private field\n\t\t\tconst schema = validator?.schema ?? validator\n\t\t\tconst errors =\n\t\t\t\t'Errors' in validator\n\t\t\t\t\t? [...validator.Errors(value)].map(mapValueError)\n\t\t\t\t\t: [...Value.Errors(validator, value)].map(mapValueError)\n\n\t\t\tlet expected\n\n\t\t\ttry {\n\t\t\t\texpected = Value.Create(schema)\n\t\t\t} catch (error) {\n\t\t\t\texpected = {\n\t\t\t\t\ttype: 'Could not create expected value',\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tmessage: error?.message,\n\t\t\t\t\terror\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmessage = JSON.stringify(\n\t\t\t\t{\n\t\t\t\t\ttype: 'validation',\n\t\t\t\t\ton: type,\n\t\t\t\t\tsummary: mapValueError(error).summary,\n\t\t\t\t\tproperty: accessor,\n\t\t\t\t\tmessage: error?.message,\n\t\t\t\t\texpected,\n\t\t\t\t\tfound: value,\n\t\t\t\t\terrors\n\t\t\t\t},\n\t\t\t\tnull,\n\t\t\t\t2\n\t\t\t)\n\t\t}\n\n\t\tsuper(message)\n\n\t\tObject.setPrototypeOf(this, ValidationError.prototype)\n\t}\n\n\tget all() {\n\t\treturn 'Errors' in this.validator\n\t\t\t? [...this.validator.Errors(this.value)].map(mapValueError)\n\t\t\t: // @ts-ignore\n\t\t\t\t[...Value.Errors(this.validator, this.value)].map(mapValueError)\n\t}\n\n\tstatic simplifyModel(\n\t\tvalidator: TSchema | TypeCheck<any> | ElysiaTypeCheck<any>\n\t) {\n\t\t// @ts-ignore\n\t\tconst model = 'schema' in validator ? validator.schema : validator\n\n\t\ttry {\n\t\t\treturn Value.Create(model)\n\t\t} catch {\n\t\t\treturn model\n\t\t}\n\t}\n\n\tget model() {\n\t\treturn ValidationError.simplifyModel(this.validator)\n\t}\n\n\ttoResponse(headers?: Record<string, any>) {\n\t\treturn new Response(this.message, {\n\t\t\tstatus: 400,\n\t\t\theaders: {\n\t\t\t\t...headers,\n\t\t\t\t'content-type': 'application/json'\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "import type { Sucrose } from './sucrose'\nimport type { TraceHandler } from './trace'\n\nimport type {\n\tLifeCycleStore,\n\tMaybeArray,\n\tInputSchema,\n\tBaseMacro,\n\tLifeCycleType,\n\tHookContainer,\n\tGracefulHandler,\n\tPreHandler,\n\tBodyHandler,\n\tTransformHandler,\n\tOptionalHandler,\n\tMapResponse,\n\tErrorHandler,\n\tReplace,\n\tAfterResponseHandler,\n\tSchemaValidator,\n\tAnyLocalHook\n} from './types'\nimport { ElysiaFile } from './universal/file'\n\nexport const hasHeaderShorthand = 'toJSON' in new Headers()\n\nexport const replaceUrlPath = (url: string, pathname: string) => {\n\tconst urlObject = new URL(url)\n\turlObject.pathname = pathname\n\treturn urlObject.toString()\n}\n\nexport const isClass = (v: Object) =>\n\t(typeof v === 'function' && /^\\s*class\\s+/.test(v.toString())) ||\n\t// Handle Object.create(null)\n\t(v.toString &&\n\t\t// Handle import * as Sentry from '@sentry/bun'\n\t\t// This also handle [object Date], [object Array]\n\t\t// and FFI value like [object Prisma]\n\t\tv.toString().startsWith('[object ') &&\n\t\tv.toString() !== '[object Object]') ||\n\t// If object prototype is not pure, then probably a class-like object\n\tisNotEmpty(Object.getPrototypeOf(v))\n\nconst isObject = (item: any): item is Object =>\n\titem && typeof item === 'object' && !Array.isArray(item)\n\nexport const mergeDeep = <\n\tA extends Record<string, any>,\n\tB extends Record<string, any>\n>(\n\ttarget: A,\n\tsource: B,\n\toptions?: {\n\t\tskipKeys?: string[]\n\t\toverride?: boolean\n\t}\n): A & B => {\n\tconst skipKeys = options?.skipKeys\n\tconst override = options?.override ?? true\n\n\tif (!isObject(target) || !isObject(source)) return target as A & B\n\n\tfor (const [key, value] of Object.entries(source)) {\n\t\tif (skipKeys?.includes(key)) continue\n\n\t\tif (!isObject(value) || !(key in target) || isClass(value)) {\n\t\t\tif (override || !(key in target))\n\t\t\t\ttarget[key as keyof typeof target] = value\n\n\t\t\tcontinue\n\t\t}\n\n\t\ttarget[key as keyof typeof target] = mergeDeep(\n\t\t\t(target as any)[key] as any,\n\t\t\tvalue,\n\t\t\t{ skipKeys, override }\n\t\t)\n\t}\n\n\treturn target as A & B\n}\nexport const mergeCookie = <const A extends Object, const B extends Object>(\n\ta: A,\n\tb: B\n): A & B => {\n\tconst v = mergeDeep(Object.assign({}, a), b, {\n\t\tskipKeys: ['properties']\n\t}) as A & B\n\n\t// @ts-expect-error\n\tif (v.properties) delete v.properties\n\n\treturn v\n}\n\nexport const mergeObjectArray = <T extends HookContainer>(\n\ta: T | T[] | undefined,\n\tb: T | T[] | undefined\n): T[] | undefined => {\n\tif (!b) return a as any\n\n\t// ! Must copy to remove side-effect\n\tconst array = <T[]>[]\n\tconst checksums = <(number | undefined)[]>[]\n\n\tif (a) {\n\t\tif (!Array.isArray(a)) a = [a]\n\t\tfor (const item of a) {\n\t\t\tarray.push(item)\n\n\t\t\tif (item.checksum) checksums.push(item.checksum)\n\t\t}\n\t}\n\n\tif (b) {\n\t\tif (!Array.isArray(b)) b = [b]\n\t\tfor (const item of b)\n\t\t\tif (!checksums.includes(item.checksum)) array.push(item)\n\t}\n\n\treturn array\n}\n\nexport const primitiveHooks = [\n\t'start',\n\t'request',\n\t'parse',\n\t'transform',\n\t'resolve',\n\t'beforeHandle',\n\t'afterHandle',\n\t'mapResponse',\n\t'afterResponse',\n\t'trace',\n\t'error',\n\t'stop',\n\t'body',\n\t'headers',\n\t'params',\n\t'query',\n\t'response',\n\t'type',\n\t'detail'\n] as const\n\nconst primitiveHookMap = primitiveHooks.reduce(\n\t(acc, x) => ((acc[x] = true), acc),\n\t{} as Record<string, boolean>\n)\n\nexport const mergeResponse = (\n\ta: InputSchema['response'],\n\tb: InputSchema['response']\n) => {\n\t// If both are Record<number, ...> then merge them,\n\t// giving preference to b.\n\ttype RecordNumber = Record<number, any>\n\tconst isRecordNumber = (x: typeof a | typeof b): x is RecordNumber =>\n\t\ttypeof x === 'object' && Object.keys(x).every(isNumericString)\n\n\tif (isRecordNumber(a) && isRecordNumber(b)) return Object.assign(a, b)\n\telse if (a && !isRecordNumber(a) && isRecordNumber(b))\n\t\treturn Object.assign({ 200: a }, b)\n\n\treturn b ?? a\n}\n\nexport const mergeSchemaValidator = (\n\ta?: SchemaValidator | null,\n\tb?: SchemaValidator | null\n): SchemaValidator => {\n\treturn {\n\t\tbody: b?.body ?? a?.body,\n\t\theaders: b?.headers ?? a?.headers,\n\t\tparams: b?.params ?? a?.params,\n\t\tquery: b?.query ?? a?.query,\n\t\tcookie: b?.cookie ?? a?.cookie,\n\t\t// @ts-ignore ? This order is correct - SaltyAom\n\t\tresponse: mergeResponse(\n\t\t\t// @ts-ignore\n\t\t\ta?.response,\n\t\t\t// @ts-ignore\n\t\t\tb?.response\n\t\t)\n\t}\n}\n\nexport const mergeHook = (\n\ta?: Partial<LifeCycleStore>,\n\tb?: AnyLocalHook\n\t// { allowMacro = false }: { allowMacro?: boolean } = {}\n): LifeCycleStore => {\n\t// In case if merging union is need\n\t// const customAStore: Record<string, unknown> = {}\n\t// const customBStore: Record<string, unknown> = {}\n\n\t// for (const [key, value] of Object.entries(a)) {\n\t// \tif (primitiveHooks.includes(key as any)) continue\n\n\t// \tcustomAStore[key] = value\n\t// }\n\n\t// for (const [key, value] of Object.entries(b)) {\n\t// \tif (primitiveHooks.includes(key as any)) continue\n\n\t// \tcustomBStore[key] = value\n\t// }\n\n\t// const unioned = Object.keys(customAStore).filter((x) =>\n\t// \tObject.keys(customBStore).includes(x)\n\t// )\n\n\t// // Must provide empty object to prevent reference side-effect\n\t// const customStore = Object.assign({}, customAStore, customBStore)\n\n\t// for (const union of unioned)\n\t// \tcustomStore[union] = mergeObjectArray(\n\t// \t\tcustomAStore[union],\n\t// \t\tcustomBStore[union]\n\t// \t)\n\n\tif (!Object.values(b).find((x) => x !== undefined && x !== null))\n\t\treturn { ...a } as any\n\n\tconst hook = {\n\t\t...a,\n\t\t...b,\n\t\t// Merge local hook first\n\t\t// @ts-ignore\n\t\tbody: b?.body ?? a?.body,\n\t\t// @ts-ignore\n\t\theaders: b?.headers ?? a?.headers,\n\t\t// @ts-ignore\n\t\tparams: b?.params ?? a?.params,\n\t\t// @ts-ignore\n\t\tquery: b?.query ?? a?.query,\n\t\t// @ts-ignore\n\t\tcookie: b?.cookie ?? a?.cookie,\n\t\t// ? This order is correct - SaltyAom\n\t\tresponse: mergeResponse(\n\t\t\t// @ts-ignore\n\t\t\ta?.response,\n\t\t\t// @ts-ignore\n\t\t\tb?.response\n\t\t),\n\t\ttype: a?.type || b?.type,\n\t\tdetail: mergeDeep(\n\t\t\t// @ts-ignore\n\t\t\tb?.detail ?? {},\n\t\t\t// @ts-ignore\n\t\t\ta?.detail ?? {}\n\t\t),\n\t\tparse: mergeObjectArray(a?.parse as any, b?.parse),\n\t\ttransform: mergeObjectArray(a?.transform, b?.transform),\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\tmergeObjectArray(\n\t\t\t\t// @ts-ignore\n\t\t\t\tfnToContainer(a?.resolve, 'resolve'),\n\t\t\t\ta?.beforeHandle\n\t\t\t),\n\t\t\tmergeObjectArray(\n\t\t\t\tfnToContainer(b.resolve, 'resolve'),\n\t\t\t\tb?.beforeHandle\n\t\t\t)\n\t\t),\n\t\tafterHandle: mergeObjectArray(a?.afterHandle, b?.afterHandle),\n\t\tmapResponse: mergeObjectArray(a?.mapResponse, b?.mapResponse) as any,\n\t\tafterResponse: mergeObjectArray(\n\t\t\ta?.afterResponse,\n\t\t\tb?.afterResponse\n\t\t) as any,\n\t\ttrace: mergeObjectArray(a?.trace, b?.trace) as any,\n\t\terror: mergeObjectArray(a?.error, b?.error)\n\t}\n\n\tif (hook.resolve) delete hook.resolve\n\n\treturn hook\n}\n\nexport const lifeCycleToArray = (a: LifeCycleStore) => {\n\tif (a.parse && !Array.isArray(a.parse)) a.parse = [a.parse]\n\n\tif (a.transform && !Array.isArray(a.transform)) a.transform = [a.transform]\n\n\tif (a.afterHandle && !Array.isArray(a.afterHandle))\n\t\ta.afterHandle = [a.afterHandle]\n\n\tif (a.mapResponse && !Array.isArray(a.mapResponse))\n\t\ta.mapResponse = [a.mapResponse]\n\n\tif (a.afterResponse && !Array.isArray(a.afterResponse))\n\t\ta.afterResponse = [a.afterResponse]\n\n\tif (a.trace && !Array.isArray(a.trace)) a.trace = [a.trace]\n\tif (a.error && !Array.isArray(a.error)) a.error = [a.error]\n\n\tlet beforeHandle = []\n\n\t// @ts-expect-error\n\tif (a.resolve) {\n\t\tbeforeHandle = fnToContainer(\n\t\t\t// @ts-expect-error\n\t\t\tArray.isArray(a.resolve) ? a.resolve : [a.resolve],\n\t\t\t'resolve'\n\t\t) as any[]\n\n\t\t// @ts-expect-error\n\t\tdelete a.resolve\n\t}\n\n\tif (a.beforeHandle) {\n\t\tif (beforeHandle.length)\n\t\t\tbeforeHandle = beforeHandle.concat(\n\t\t\t\tArray.isArray(a.beforeHandle)\n\t\t\t\t\t? a.beforeHandle\n\t\t\t\t\t: [a.beforeHandle]\n\t\t\t)\n\t\telse\n\t\t\tbeforeHandle = Array.isArray(a.beforeHandle)\n\t\t\t\t? a.beforeHandle\n\t\t\t\t: [a.beforeHandle]\n\t}\n\n\tif (beforeHandle.length) a.beforeHandle = beforeHandle\n\n\treturn a\n}\n\nconst isBun = typeof Bun !== 'undefined'\nconst hasBunHash = isBun && typeof Bun.hash === 'function'\n\n// https://stackoverflow.com/a/52171480\nexport const checksum = (s: string) => {\n\tlet h = 9\n\n\tfor (let i = 0; i < s.length; ) h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9)\n\n\treturn (h = h ^ (h >>> 9))\n}\n\nexport const injectChecksum = (\n\tchecksum: number | undefined,\n\tx: MaybeArray<HookContainer> | undefined\n) => {\n\tif (!x) return\n\n\tif (!Array.isArray(x)) {\n\t\t// ? clone fn is required to prevent side-effect from changing hookType\n\t\tconst fn = x\n\n\t\tif (checksum && !fn.checksum) fn.checksum = checksum\n\t\tif (fn.scope === 'scoped') fn.scope = 'local'\n\n\t\treturn fn\n\t}\n\n\t// ? clone fns is required to prevent side-effect from changing hookType\n\tconst fns = [...x]\n\n\tfor (const fn of fns) {\n\t\tif (checksum && !fn.checksum) fn.checksum = checksum\n\n\t\tif (fn.scope === 'scoped') fn.scope = 'local'\n\t}\n\n\treturn fns\n}\n\nexport const mergeLifeCycle = (\n\ta: Partial<LifeCycleStore>,\n\tb: Partial<LifeCycleStore | AnyLocalHook>,\n\tchecksum?: number\n): LifeCycleStore => {\n\treturn {\n\t\tstart: mergeObjectArray(\n\t\t\ta.start,\n\t\t\tinjectChecksum(checksum, b?.start)\n\t\t) as HookContainer<GracefulHandler<any>>[],\n\t\trequest: mergeObjectArray(\n\t\t\ta.request,\n\t\t\tinjectChecksum(checksum, b?.request)\n\t\t) as HookContainer<PreHandler<any, any>>[],\n\t\tparse: mergeObjectArray(\n\t\t\ta.parse,\n\t\t\tinjectChecksum(checksum, b?.parse)\n\t\t) as HookContainer<BodyHandler<any, any>>[],\n\t\ttransform: mergeObjectArray(\n\t\t\ta.transform,\n\t\t\tinjectChecksum(checksum, b?.transform)\n\t\t) as HookContainer<TransformHandler<any, any>>[],\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\tmergeObjectArray(\n\t\t\t\t// @ts-ignore\n\t\t\t\tfnToContainer(a.resolve, 'resolve'),\n\t\t\t\ta.beforeHandle\n\t\t\t),\n\t\t\tinjectChecksum(\n\t\t\t\tchecksum,\n\t\t\t\tmergeObjectArray(\n\t\t\t\t\tfnToContainer(b?.resolve, 'resolve'),\n\t\t\t\t\tb?.beforeHandle\n\t\t\t\t)\n\t\t\t)\n\t\t) as HookContainer<OptionalHandler<any, any>>[],\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta.afterHandle,\n\t\t\tinjectChecksum(checksum, b?.afterHandle)\n\t\t) as HookContainer<OptionalHandler<any, any>>[],\n\t\tmapResponse: mergeObjectArray(\n\t\t\ta.mapResponse,\n\t\t\tinjectChecksum(checksum, b?.mapResponse)\n\t\t) as HookContainer<MapResponse<any, any>>[],\n\t\tafterResponse: mergeObjectArray(\n\t\t\ta.afterResponse,\n\t\t\tinjectChecksum(checksum, b?.afterResponse)\n\t\t) as HookContainer<AfterResponseHandler<any, any>>[],\n\t\t// Already merged on Elysia._use, also logic is more complicated, can't directly merge\n\t\ttrace: mergeObjectArray(\n\t\t\ta.trace,\n\t\t\tinjectChecksum(checksum, b?.trace)\n\t\t) as HookContainer<TraceHandler<any, any>>[],\n\t\terror: mergeObjectArray(\n\t\t\ta.error,\n\t\t\tinjectChecksum(checksum, b?.error)\n\t\t) as HookContainer<ErrorHandler<any, any, any>>[],\n\t\tstop: mergeObjectArray(\n\t\t\ta.stop,\n\t\t\tinjectChecksum(checksum, b?.stop)\n\t\t) as HookContainer<GracefulHandler<any>>[]\n\t}\n}\n\nexport const asHookType = (\n\tfn: HookContainer,\n\tinject: LifeCycleType,\n\t{ skipIfHasType = false }: { skipIfHasType?: boolean }\n) => {\n\tif (!fn) return fn\n\n\tif (!Array.isArray(fn)) {\n\t\tif (skipIfHasType) fn.scope ??= inject\n\t\telse fn.scope = inject\n\n\t\treturn fn\n\t}\n\n\tfor (const x of fn)\n\t\tif (skipIfHasType) x.scope ??= inject\n\t\telse x.scope = inject\n\n\treturn fn\n}\n\nconst filterGlobal = (fn: MaybeArray<HookContainer>) => {\n\tif (!fn) return fn\n\n\tif (!Array.isArray(fn))\n\t\tswitch (fn.scope) {\n\t\t\tcase 'global':\n\t\t\tcase 'scoped':\n\t\t\t\treturn { ...fn }\n\n\t\t\tdefault:\n\t\t\t\treturn { fn }\n\t\t}\n\n\tconst array = <any>[]\n\n\tfor (const x of fn)\n\t\tswitch (x.scope) {\n\t\t\tcase 'global':\n\t\t\tcase 'scoped':\n\t\t\t\tarray.push({\n\t\t\t\t\t...x\n\t\t\t\t})\n\t\t\t\tbreak\n\t\t}\n\n\treturn array\n}\n\nexport const filterGlobalHook = (hook: AnyLocalHook): AnyLocalHook => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: filterGlobal(hook?.parse),\n\t\ttransform: filterGlobal(hook?.transform),\n\t\tbeforeHandle: filterGlobal(hook?.beforeHandle),\n\t\tafterHandle: filterGlobal(hook?.afterHandle),\n\t\tmapResponse: filterGlobal(hook?.mapResponse),\n\t\tafterResponse: filterGlobal(hook?.afterResponse),\n\t\terror: filterGlobal(hook?.error),\n\t\ttrace: filterGlobal(hook?.trace)\n\t}\n}\n\nexport const StatusMap = {\n\tContinue: 100,\n\t'Switching Protocols': 101,\n\tProcessing: 102,\n\t'Early Hints': 103,\n\tOK: 200,\n\tCreated: 201,\n\tAccepted: 202,\n\t'Non-Authoritative Information': 203,\n\t'No Content': 204,\n\t'Reset Content': 205,\n\t'Partial Content': 206,\n\t'Multi-Status': 207,\n\t'Already Reported': 208,\n\t'Multiple Choices': 300,\n\t'Moved Permanently': 301,\n\tFound: 302,\n\t'See Other': 303,\n\t'Not Modified': 304,\n\t'Temporary Redirect': 307,\n\t'Permanent Redirect': 308,\n\t'Bad Request': 400,\n\tUnauthorized: 401,\n\t'Payment Required': 402,\n\tForbidden: 403,\n\t'Not Found': 404,\n\t'Method Not Allowed': 405,\n\t'Not Acceptable': 406,\n\t'Proxy Authentication Required': 407,\n\t'Request Timeout': 408,\n\tConflict: 409,\n\tGone: 410,\n\t'Length Required': 411,\n\t'Precondition Failed': 412,\n\t'Payload Too Large': 413,\n\t'URI Too Long': 414,\n\t'Unsupported Media Type': 415,\n\t'Range Not Satisfiable': 416,\n\t'Expectation Failed': 417,\n\t\"I'm a teapot\": 418,\n\t'Misdirected Request': 421,\n\t'Unprocessable Content': 422,\n\tLocked: 423,\n\t'Failed Dependency': 424,\n\t'Too Early': 425,\n\t'Upgrade Required': 426,\n\t'Precondition Required': 428,\n\t'Too Many Requests': 429,\n\t'Request Header Fields Too Large': 431,\n\t'Unavailable For Legal Reasons': 451,\n\t'Internal Server Error': 500,\n\t'Not Implemented': 501,\n\t'Bad Gateway': 502,\n\t'Service Unavailable': 503,\n\t'Gateway Timeout': 504,\n\t'HTTP Version Not Supported': 505,\n\t'Variant Also Negotiates': 506,\n\t'Insufficient Storage': 507,\n\t'Loop Detected': 508,\n\t'Not Extended': 510,\n\t'Network Authentication Required': 511\n} as const\n\nexport const InvertedStatusMap = Object.fromEntries(\n\tObject.entries(StatusMap).map(([k, v]) => [v, k])\n) as {\n\t[K in keyof StatusMap as StatusMap[K]]: K\n}\n\nexport type StatusMap = typeof StatusMap\nexport type InvertedStatusMap = typeof InvertedStatusMap\n\nfunction removeTrailingEquals(digest: string): string {\n\tlet trimmedDigest = digest\n\n\twhile (trimmedDigest.endsWith('='))\n\t\ttrimmedDigest = trimmedDigest.slice(0, -1)\n\n\treturn trimmedDigest\n}\n\nconst encoder = new TextEncoder()\n\nexport const signCookie = async (val: string, secret: string | null) => {\n\tif (typeof val !== 'string')\n\t\tthrow new TypeError('Cookie value must be provided as a string.')\n\n\tif (secret === null) throw new TypeError('Secret key must be provided.')\n\n\tconst secretKey = await crypto.subtle.importKey(\n\t\t'raw',\n\t\tencoder.encode(secret),\n\t\t{ name: 'HMAC', hash: 'SHA-256' },\n\t\tfalse,\n\t\t['sign']\n\t)\n\n\tconst hmacBuffer = await crypto.subtle.sign(\n\t\t'HMAC',\n\t\tsecretKey,\n\t\tencoder.encode(val)\n\t)\n\n\t// console.log({\n\t// \tval,\n\t// \tsecret,\n\t// \thash: removeTrailingEquals(Buffer.from(hmacBuffer).toString('base64'))\n\t// })\n\n\treturn (\n\t\tval +\n\t\t'.' +\n\t\tremoveTrailingEquals(Buffer.from(hmacBuffer).toString('base64'))\n\t)\n}\n\nexport const unsignCookie = async (input: string, secret: string | null) => {\n\tif (typeof input !== 'string')\n\t\tthrow new TypeError('Signed cookie string must be provided.')\n\n\tif (null === secret) throw new TypeError('Secret key must be provided.')\n\n\tconst tentativeValue = input.slice(0, input.lastIndexOf('.'))\n\tconst expectedInput = await signCookie(tentativeValue, secret)\n\n\treturn expectedInput === input ? tentativeValue : false\n}\n\nexport const traceBackMacro = (\n\textension: unknown,\n\tproperty: Record<string, unknown>,\n\tmanage: ReturnType<typeof createMacroManager>\n) => {\n\tif (!extension || typeof extension !== 'object' || !property) return\n\n\tfor (const [key, value] of Object.entries(property)) {\n\t\tif (primitiveHookMap[key] || !(key in extension)) continue\n\n\t\tconst v = extension[\n\t\t\tkey as unknown as keyof typeof extension\n\t\t] as BaseMacro[string]\n\n\t\tif (typeof v === 'function') {\n\t\t\tconst hook = v(value)\n\n\t\t\tif (typeof hook === 'object')\n\t\t\t\tfor (const [k, v] of Object.entries(hook))\n\t\t\t\t\tmanage(k as keyof LifeCycleStore)({\n\t\t\t\t\t\tfn: v as any\n\t\t\t\t\t})\n\t\t}\n\n\t\tdelete property[key as unknown as keyof typeof extension]\n\t}\n}\n\nexport const createMacroManager =\n\t({\n\t\tglobalHook,\n\t\tlocalHook\n\t}: {\n\t\tglobalHook: Partial<LifeCycleStore>\n\t\tlocalHook: Partial<AnyLocalHook>\n\t}) =>\n\t(stackName: keyof LifeCycleStore) =>\n\t(\n\t\ttype:\n\t\t\t| {\n\t\t\t\t\tinsert?: 'before' | 'after'\n\t\t\t\t\tstack?: 'global' | 'local'\n\t\t\t  }\n\t\t\t| MaybeArray<HookContainer>,\n\t\tfn?: MaybeArray<HookContainer>\n\t) => {\n\t\tif (typeof type === 'function')\n\t\t\ttype = {\n\t\t\t\tfn: type\n\t\t\t}\n\n\t\t// @ts-expect-error this is available in macro v2\n\t\tif (stackName === 'resolve') {\n\t\t\ttype = {\n\t\t\t\t...type,\n\t\t\t\tsubType: 'resolve'\n\t\t\t}\n\t\t}\n\n\t\tif (!localHook[stackName]) localHook[stackName] = []\n\t\tif (typeof localHook[stackName] === 'function')\n\t\t\tlocalHook[stackName] = [localHook[stackName]]\n\t\tif (!Array.isArray(localHook[stackName]))\n\t\t\tlocalHook[stackName] = [localHook[stackName]]\n\n\t\tif ('fn' in type || Array.isArray(type)) {\n\t\t\tif (Array.isArray(type))\n\t\t\t\tlocalHook[stackName] = (\n\t\t\t\t\tlocalHook[stackName] as unknown[]\n\t\t\t\t).concat(type) as any\n\t\t\telse localHook[stackName].push(type)\n\n\t\t\treturn\n\t\t}\n\n\t\tconst { insert = 'after', stack = 'local' } = type\n\n\t\tif (typeof fn === 'function') fn = { fn }\n\n\t\tif (stack === 'global') {\n\t\t\tif (!Array.isArray(fn)) {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\t;(globalHook[stackName] as any[]).unshift(fn)\n\t\t\t\t} else {\n\t\t\t\t\t;(globalHook[stackName] as any[]).push(fn)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\tglobalHook[stackName] = fn.concat(\n\t\t\t\t\t\tglobalHook[stackName] as any\n\t\t\t\t\t) as any\n\t\t\t\t} else {\n\t\t\t\t\tglobalHook[stackName] = (\n\t\t\t\t\t\tglobalHook[stackName] as any[]\n\t\t\t\t\t).concat(fn)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!Array.isArray(fn)) {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\t;(localHook[stackName] as any[]).unshift(fn)\n\t\t\t\t} else {\n\t\t\t\t\t;(localHook[stackName] as any[]).push(fn)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\tlocalHook[stackName] = fn.concat(localHook[stackName])\n\t\t\t\t} else {\n\t\t\t\t\tlocalHook[stackName] = localHook[stackName].concat(fn)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nconst parseNumericString = (message: string | number): number | null => {\n\tif (typeof message === 'number') return message\n\n\tif (message.length < 16) {\n\t\tif (message.trim().length === 0) return null\n\n\t\tconst length = Number(message)\n\t\tif (Number.isNaN(length)) return null\n\n\t\treturn length\n\t}\n\n\t// if 16 digit but less then 9,007,199,254,740,991 then can be parsed\n\tif (message.length === 16) {\n\t\tif (message.trim().length === 0) return null\n\n\t\tconst number = Number(message)\n\t\tif (Number.isNaN(number) || number.toString() !== message) return null\n\n\t\treturn number\n\t}\n\n\treturn null\n}\n\nexport const isNumericString = (message: string | number): boolean =>\n\tparseNumericString(message) !== null\n\nexport class PromiseGroup implements PromiseLike<void> {\n\troot: Promise<any> | null = null\n\tpromises: Promise<any>[] = []\n\n\tconstructor(\n\t\tpublic onError: (error: any) => void = console.error,\n\t\tpublic onFinally: () => void = () => {}\n\t) {}\n\n\t/**\n\t * The number of promises still being awaited.\n\t */\n\tget size() {\n\t\treturn this.promises.length\n\t}\n\n\t/**\n\t * Add a promise to the group.\n\t * @returns The promise that was added.\n\t */\n\tadd<T>(promise: Promise<T>) {\n\t\tthis.promises.push(promise)\n\t\tthis.root ||= this.drain()\n\n\t\tif (this.promises.length === 1) this.then(this.onFinally)\n\t\treturn promise\n\t}\n\n\tprivate async drain() {\n\t\twhile (this.promises.length > 0) {\n\t\t\ttry {\n\t\t\t\tawait this.promises[0]\n\t\t\t} catch (error) {\n\t\t\t\tthis.onError(error)\n\t\t\t}\n\t\t\tthis.promises.shift()\n\t\t}\n\t\tthis.root = null\n\t}\n\n\t// Allow the group to be awaited.\n\tthen<TResult1 = void, TResult2 = never>(\n\t\tonfulfilled?:\n\t\t\t| ((value: void) => TResult1 | PromiseLike<TResult1>)\n\t\t\t| undefined\n\t\t\t| null,\n\t\tonrejected?:\n\t\t\t| ((reason: any) => TResult2 | PromiseLike<TResult2>)\n\t\t\t| undefined\n\t\t\t| null\n\t): PromiseLike<TResult1 | TResult2> {\n\t\treturn (this.root ?? Promise.resolve()).then(onfulfilled, onrejected)\n\t}\n}\n\nexport const fnToContainer = (\n\tfn: MaybeArray<Function | HookContainer>,\n\t/** Only add subType to non contained fn */\n\tsubType?: HookContainer['subType']\n): MaybeArray<HookContainer> => {\n\tif (!fn) return fn\n\n\tif (!Array.isArray(fn)) {\n\t\t// parse can be a label since 1.2.0\n\t\tif (typeof fn === 'function' || typeof fn === 'string')\n\t\t\treturn subType ? { fn, subType } : { fn }\n\t\telse if ('fn' in fn) return fn\n\t}\n\n\tconst fns = <HookContainer[]>[]\n\tfor (const x of fn) {\n\t\t// parse can be a label since 1.2.0\n\t\tif (typeof x === 'function' || typeof x === 'string')\n\t\t\tfns.push(subType ? { fn: x, subType } : { fn: x })\n\t\telse if ('fn' in x) fns.push(x)\n\t}\n\n\treturn fns\n}\n\nexport const localHookToLifeCycleStore = (a: AnyLocalHook): LifeCycleStore => {\n\tif (a.start) a.start = fnToContainer(a.start)\n\tif (a.request) a.request = fnToContainer(a.request)\n\tif (a.parse) a.parse = fnToContainer(a.parse)\n\tif (a.transform) a.transform = fnToContainer(a.transform)\n\tif (a.beforeHandle) a.beforeHandle = fnToContainer(a.beforeHandle)\n\tif (a.afterHandle) a.afterHandle = fnToContainer(a.afterHandle)\n\tif (a.mapResponse) a.mapResponse = fnToContainer(a.mapResponse)\n\tif (a.afterResponse) a.afterResponse = fnToContainer(a.afterResponse)\n\tif (a.trace) a.trace = fnToContainer(a.trace)\n\tif (a.error) a.error = fnToContainer(a.error)\n\tif (a.stop) a.stop = fnToContainer(a.stop)\n\n\treturn a\n}\n\nexport const lifeCycleToFn = (a: Partial<LifeCycleStore>): AnyLocalHook => {\n\t// @ts-expect-error\n\tif (a.start?.map) a.start = a.start.map((x) => x.fn)\n\t// @ts-expect-error\n\tif (a.request?.map) a.request = a.request.map((x) => x.fn)\n\t// @ts-expect-error\n\tif (a.parse?.map) a.parse = a.parse.map((x) => x.fn)\n\t// @ts-expect-error\n\tif (a.transform?.map) a.transform = a.transform.map((x) => x.fn)\n\tif (a.beforeHandle?.map)\n\t\t// @ts-expect-error\n\t\ta.beforeHandle = a.beforeHandle.map((x) => x.fn)\n\t// @ts-expect-error\n\tif (a.afterHandle?.map) a.afterHandle = a.afterHandle.map((x) => x.fn)\n\t// @ts-expect-error\n\tif (a.mapResponse?.map) a.mapResponse = a.mapResponse.map((x) => x.fn)\n\tif (a.afterResponse?.map)\n\t\t// @ts-expect-error\n\t\ta.afterResponse = a.afterResponse.map((x) => x.fn)\n\t// @ts-expect-error\n\tif (a.trace?.map) a.trace = a.trace.map((x) => x.fn)\n\telse a.trace = []\n\t// @ts-expect-error\n\tif (a.error?.map) a.error = a.error.map((x) => x.fn)\n\t// @ts-expect-error\n\tif (a.stop?.map) a.stop = a.stop.map((x) => x.fn)\n\n\treturn a\n}\n\nexport const cloneInference = (inference: Sucrose.Inference) =>\n\t({\n\t\tbody: inference.body,\n\t\tcookie: inference.cookie,\n\t\theaders: inference.headers,\n\t\tquery: inference.query,\n\t\tset: inference.set,\n\t\tserver: inference.server,\n\t\tpath: inference.path,\n\t\troute: inference.route,\n\t\turl: inference.url\n\t}) satisfies Sucrose.Inference\n\n/**\n *\n * @param url URL to redirect to\n * @param HTTP status code to send,\n */\nexport const redirect = (\n\turl: string,\n\tstatus: 301 | 302 | 303 | 307 | 308 = 302\n) => Response.redirect(url, status)\n\nexport type redirect = typeof redirect\n\nexport const ELYSIA_FORM_DATA = Symbol('ElysiaFormData')\nexport type ELYSIA_FORM_DATA = typeof ELYSIA_FORM_DATA\n\nexport type ElysiaFormData<T extends Record<keyof any, unknown>> = FormData & {\n\t[ELYSIA_FORM_DATA]: Replace<T, Blob | ElysiaFile, File>\n}\n\nexport const ELYSIA_REQUEST_ID = Symbol('ElysiaRequestId')\nexport type ELYSIA_REQUEST_ID = typeof ELYSIA_REQUEST_ID\n\nexport const form = <const T extends Record<keyof any, unknown>>(\n\titems: T\n): ElysiaFormData<T> => {\n\tconst formData = new FormData()\n\t// @ts-ignore\n\tformData[ELYSIA_FORM_DATA] = {}\n\n\tif (items)\n\t\tfor (const [key, value] of Object.entries(items)) {\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tformData[ELYSIA_FORM_DATA][key] = []\n\n\t\t\t\tfor (const v of value) {\n\t\t\t\t\tif (value instanceof File)\n\t\t\t\t\t\tformData.append(key, value, value.name)\n\t\t\t\t\telse if (value instanceof ElysiaFile)\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tformData.append(key, value.value, value.value?.name)\n\t\t\t\t\telse formData.append(key, value as any)\n\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tformData[ELYSIA_FORM_DATA][key].push(value)\n\t\t\t\t}\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (value instanceof File) formData.append(key, value, value.name)\n\t\t\telse if (value instanceof ElysiaFile)\n\t\t\t\t// @ts-expect-error\n\t\t\t\tformData.append(key, value.value, value.value?.name)\n\t\t\telse formData.append(key, value as any)\n\t\t\t// @ts-expect-error\n\t\t\tformData[ELYSIA_FORM_DATA][key] = value\n\t\t}\n\n\treturn formData as any\n}\n\nexport const randomId = () => {\n\tconst uuid = crypto.randomUUID()\n\treturn uuid.slice(0, 8) + uuid.slice(24, 32)\n}\n\n// ! Deduplicate current instance\nexport const deduplicateChecksum = <T extends Function>(\n\tarray: HookContainer<T>[]\n): HookContainer<T>[] => {\n\tconst hashes: number[] = []\n\n\tfor (let i = 0; i < array.length; i++) {\n\t\tconst item = array[i]\n\n\t\tif (item.checksum) {\n\t\t\tif (hashes.includes(item.checksum)) {\n\t\t\t\tarray.splice(i, 1)\n\t\t\t\ti--\n\t\t\t}\n\n\t\t\thashes.push(item.checksum)\n\t\t}\n\t}\n\n\treturn array\n}\n\n/**\n * Since it's a plugin, which means that ephemeral is demoted to volatile.\n * Which  means there's no volatile and all previous ephemeral become volatile\n * We can just promote back without worry\n */\nexport const promoteEvent = (\n\tevents?: (HookContainer | Function)[],\n\tas: 'scoped' | 'global' = 'scoped'\n): void => {\n\tif (!events) return\n\n\tif (as === 'scoped') {\n\t\tfor (const event of events)\n\t\t\tif ('scope' in event && event.scope === 'local')\n\t\t\t\tevent.scope = 'scoped'\n\n\t\treturn\n\t}\n\n\tfor (const event of events) if ('scope' in event) event.scope = 'global'\n}\n\n// type PropertyKeys<T> = {\n// \t[K in keyof T]: T[K] extends (...args: any[]) => any ? never : K\n// }[keyof T]\n\n// type PropertiesOnly<T> = Pick<T, PropertyKeys<T>>\n\n// export const classToObject = <T>(\n// \tinstance: T,\n// \tprocessed: WeakMap<object, object> = new WeakMap()\n// ): T extends object ? PropertiesOnly<T> : T => {\n// \tif (typeof instance !== 'object' || instance === null)\n// \t\treturn instance as any\n\n// \tif (Array.isArray(instance))\n// \t\treturn instance.map((x) => classToObject(x, processed)) as any\n\n// \tif (processed.has(instance)) return processed.get(instance) as any\n\n// \tconst result: Partial<T> = {}\n\n// \tfor (const key of Object.keys(instance) as Array<keyof T>) {\n// \t\tconst value = instance[key]\n// \t\tif (typeof value === 'object' && value !== null)\n// \t\t\tresult[key] = classToObject(value, processed) as T[keyof T]\n// \t\telse result[key] = value\n// \t}\n\n// \tconst prototype = Object.getPrototypeOf(instance)\n// \tif (!prototype) return result as any\n\n// \tconst properties = Object.getOwnPropertyNames(prototype)\n\n// \tfor (const property of properties) {\n// \t\tconst descriptor = Object.getOwnPropertyDescriptor(\n// \t\t\tObject.getPrototypeOf(instance),\n// \t\t\tproperty\n// \t\t)\n\n// \t\tif (descriptor && typeof descriptor.get === 'function') {\n// \t\t\t// ? Very important to prevent prototype pollution\n// \t\t\tif (property === '__proto__') continue\n\n// \t\t\t;(result as any)[property as keyof typeof instance] = classToObject(\n// \t\t\t\tinstance[property as keyof typeof instance]\n// \t\t\t)\n// \t\t}\n// \t}\n\n// \treturn result as any\n// }\n\nexport const getLoosePath = (path: string) => {\n\tif (path.charCodeAt(path.length - 1) === 47)\n\t\treturn path.slice(0, path.length - 1)\n\n\treturn path + '/'\n}\n\nexport const isNotEmpty = (obj?: Object) => {\n\tif (!obj) return false\n\n\tfor (const x in obj) return true\n\n\treturn false\n}\n\nconst isEmptyHookProperty = (prop: unknown) => {\n\tif (Array.isArray(prop)) return prop.length === 0\n\n\treturn !prop\n}\n\nexport const encodePath = (path: string, { dynamic = false } = {}) => {\n\tlet encoded = encodeURIComponent(path).replace(/%2F/g, '/')\n\n\tif (dynamic) encoded = encoded.replace(/%3A/g, ':').replace(/%3F/g, '?')\n\n\treturn encoded\n}\n\nexport const supportPerMethodInlineHandler = (() => {\n\tif(typeof Bun === \"undefined\") return true\n\n\tconst semver = Bun.version.split('.')\n\tif (+semver[0] < 1 || +semver[1] < 2 || +semver[2] < 14) return false\n\n\treturn true\n})()\n",
    "/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable no-constant-condition */\nimport { checksum } from './utils'\nimport { isBun } from './universal/utils'\n\nimport type { Handler, HookContainer, LifeCycleStore } from './types'\n\nexport namespace Sucrose {\n\texport interface Inference {\n\t\tquery: boolean\n\t\theaders: boolean\n\t\tbody: boolean\n\t\tcookie: boolean\n\t\tset: boolean\n\t\tserver: boolean\n\t\troute: boolean\n\t\turl: boolean\n\t\tpath: boolean\n\t}\n\n\texport interface LifeCycle extends Partial<LifeCycleStore> {\n\t\thandler?: Handler\n\t}\n}\n\n/**\n * Separate stringified function body and paramter\n *\n * @example\n * ```typescript\n * separateFunction('async ({ hello }) => { return hello }') // => ['({ hello })', '{ return hello }']\n * ```\n */\nexport const separateFunction = (\n\tcode: string\n): [string, string, { isArrowReturn: boolean }] => {\n\t// Remove async keyword without removing space (both minify and non-minify)\n\tif (code.startsWith('async')) code = code.slice(5)\n\tcode = code.trimStart()\n\n\tlet index = -1\n\n\t// JSC: Starts with '(', is an arrow function\n\tif (code.charCodeAt(0) === 40) {\n\t\tindex = code.indexOf('=>', code.indexOf(')'))\n\n\t\tif (index !== -1) {\n\t\t\tlet bracketEndIndex = index\n\t\t\t// Walk back to find bracket end\n\t\t\twhile (bracketEndIndex > 0)\n\t\t\t\tif (code.charCodeAt(--bracketEndIndex) === 41) break\n\n\t\t\tlet body = code.slice(index + 2)\n\t\t\tif (body.charCodeAt(0) === 32) body = body.trimStart()\n\n\t\t\treturn [\n\t\t\t\tcode.slice(1, bracketEndIndex),\n\t\t\t\tbody,\n\t\t\t\t{\n\t\t\t\t\tisArrowReturn: body.charCodeAt(0) !== 123\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t}\n\n\t// V8: bracket is removed for 1 parameter arrow function\n\tif (/^(\\w+)=>/g.test(code)) {\n\t\tindex = code.indexOf('=>')\n\n\t\tif (index !== -1) {\n\t\t\tlet body = code.slice(index + 2)\n\t\t\tif (body.charCodeAt(0) === 32) body = body.trimStart()\n\n\t\t\treturn [\n\t\t\t\tcode.slice(0, index),\n\t\t\t\tbody,\n\t\t\t\t{\n\t\t\t\t\tisArrowReturn: body.charCodeAt(0) !== 123\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t}\n\n\t// Using function keyword\n\tif (code.startsWith('function')) {\n\t\tindex = code.indexOf('(')\n\t\tconst end = code.indexOf(')')\n\n\t\treturn [\n\t\t\tcode.slice(index + 1, end),\n\t\t\tcode.slice(end + 2),\n\t\t\t{\n\t\t\t\tisArrowReturn: false\n\t\t\t}\n\t\t]\n\t}\n\n\t// Probably Declare as method\n\tconst start = code.indexOf('(')\n\n\tif (start !== -1) {\n\t\tconst sep = code.indexOf('\\n', 2)\n\t\tconst parameter = code.slice(0, sep)\n\t\tconst end = parameter.lastIndexOf(')') + 1\n\n\t\tconst body = code.slice(sep + 1)\n\n\t\treturn [\n\t\t\tparameter.slice(start, end),\n\t\t\t'{' + body,\n\t\t\t{\n\t\t\t\tisArrowReturn: false\n\t\t\t}\n\t\t]\n\t}\n\n\t// Unknown case\n\tconst x = code.split('\\n', 2)\n\n\treturn [x[0], x[1], { isArrowReturn: false }]\n}\n\n/**\n * Get range between bracket pair\n *\n * @example\n * ```typescript\n * bracketPairRange('hello: { world: { a } }, elysia') // [6, 20]\n * ```\n */\nexport const bracketPairRange = (parameter: string): [number, number] => {\n\tconst start = parameter.indexOf('{')\n\tif (start === -1) return [-1, 0]\n\n\tlet end = start + 1\n\tlet deep = 1\n\n\tfor (; end < parameter.length; end++) {\n\t\tconst char = parameter.charCodeAt(end)\n\n\t\t// Open bracket\n\t\tif (char === 123) deep++\n\t\t// Close bracket\n\t\telse if (char === 125) deep--\n\n\t\tif (deep === 0) break\n\t}\n\n\tif (deep !== 0) return [0, parameter.length]\n\n\treturn [start, end + 1]\n}\n\n/**\n * Similar to `bracketPairRange` but in reverse order\n * Get range between bracket pair from end to beginning\n *\n * @example\n * ```typescript\n * bracketPairRange('hello: { world: { a } }, elysia') // [6, 20]\n * ```\n */\nexport const bracketPairRangeReverse = (\n\tparameter: string\n): [number, number] => {\n\tconst end = parameter.lastIndexOf('}')\n\tif (end === -1) return [-1, 0]\n\n\tlet start = end - 1\n\tlet deep = 1\n\n\tfor (; start >= 0; start--) {\n\t\tconst char = parameter.charCodeAt(start)\n\n\t\t// Open bracket\n\t\tif (char === 125) deep++\n\t\t// Close bracket\n\t\telse if (char === 123) deep--\n\n\t\tif (deep === 0) break\n\t}\n\n\tif (deep !== 0) return [-1, 0]\n\n\treturn [start, end + 1]\n}\n\nexport const removeColonAlias = (parameter: string) => {\n\twhile (true) {\n\t\tconst start = parameter.indexOf(':')\n\t\tif (start === -1) break\n\n\t\tlet end = parameter.indexOf(',', start)\n\t\tif (end === -1) end = parameter.indexOf('}', start) - 1\n\t\tif (end === -2) end = parameter.length\n\n\t\tparameter = parameter.slice(0, start) + parameter.slice(end)\n\t}\n\n\treturn parameter\n}\n\n/**\n * Retrieve only root paramters of a function\n *\n * @example\n * ```typescript\n * retrieveRootParameters('({ hello: { world: { a } }, elysia })') // => {\n *   parameters: ['hello', 'elysia'],\n *   hasParenthesis: true\n * }\n * ```\n */\nexport const retrieveRootParamters = (parameter: string) => {\n\tlet hasParenthesis = false\n\n\t// Remove () from parameter\n\tif (parameter.charCodeAt(0) === 40) parameter = parameter.slice(1, -1)\n\n\t// Remove {} from parameter\n\tif (parameter.charCodeAt(0) === 123) {\n\t\thasParenthesis = true\n\t\tparameter = parameter.slice(1, -1)\n\t}\n\n\tparameter = parameter.replace(/( |\\t|\\n)/g, '').trim()\n\tlet parameters = <string[]>[]\n\n\t// Object destructuring\n\twhile (true) {\n\t\t// eslint-disable-next-line prefer-const\n\t\tlet [start, end] = bracketPairRange(parameter)\n\t\tif (start === -1) break\n\n\t\t// Remove colon from object structuring cast\n\t\tparameters.push(parameter.slice(0, start - 1))\n\t\tif (parameter.charCodeAt(end) === 44) end++\n\t\tparameter = parameter.slice(end)\n\t}\n\n\tparameter = removeColonAlias(parameter)\n\tif (parameter) parameters = parameters.concat(parameter.split(','))\n\n\tconst parameterMap: Record<string, true> = Object.create(null)\n\tfor (const p of parameters) {\n\t\tif (p.indexOf(',') === -1) {\n\t\t\tparameterMap[p] = true\n\t\t\tcontinue\n\t\t}\n\n\t\tfor (const q of p.split(',')) parameterMap[q.trim()] = true\n\t}\n\n\treturn {\n\t\thasParenthesis,\n\t\tparameters: parameterMap\n\t}\n}\n\n/**\n * Find inference from parameter\n *\n * @param parameter stringified parameter\n */\nexport const findParameterReference = (\n\tparameter: string,\n\tinference: Sucrose.Inference\n) => {\n\tconst { parameters, hasParenthesis } = retrieveRootParamters(parameter)\n\n\t// Check if root is an object destructuring\n\tif (parameters.query) inference.query = true\n\tif (parameters.headers) inference.headers = true\n\tif (parameters.body) inference.body = true\n\tif (parameters.cookie) inference.cookie = true\n\tif (parameters.set) inference.set = true\n\tif (parameters.server) inference.server = true\n\tif (parameters.route) inference.route = true\n\tif (parameters.url) inference.url = true\n\tif (parameters.path) inference.path = true\n\n\tif (hasParenthesis) return `{ ${Object.keys(parameters).join(', ')} }`\n\n\treturn Object.keys(parameters).join(', ')\n}\n\nconst findEndIndex = (\n\ttype: string,\n\tcontent: string,\n\tindex?: number | undefined\n) => {\n\tconst regex = new RegExp(\n\t\t`${type.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}[\\\\n\\\\t,; ]`\n\t)\n\n\tif (index !== undefined) regex.lastIndex = index\n\n\tconst match = regex.exec(content)\n\n\treturn match ? match.index : -1\n}\n\nconst findEndQueryBracketIndex = (\n\ttype: string,\n\tcontent: string,\n\tindex?: number | undefined\n) => {\n\tconst bracketEndIndex = content.indexOf(type + ']', index)\n\tconst singleQuoteIndex = content.indexOf(type + \"'\", index)\n\tconst doubleQuoteIndex = content.indexOf(type + '\"', index)\n\n\t// Pick the smallest index that is not -1 or 0\n\treturn (\n\t\t[bracketEndIndex, singleQuoteIndex, doubleQuoteIndex]\n\t\t\t.filter((i) => i > 0)\n\t\t\t.sort((a, b) => a - b)[0] || -1\n\t)\n}\n\n/**\n * Find alias of variable from function body\n *\n * @example\n * ```typescript\n * findAlias('body', '{ const a = body, b = body }') // => ['a', 'b']\n * ```\n */\nexport const findAlias = (type: string, body: string, depth = 0) => {\n\tif (depth > 5) return []\n\n\tconst aliases: string[] = []\n\n\tlet content = body\n\n\twhile (true) {\n\t\tlet index = findEndIndex(' = ' + type, content)\n\t\t// V8 engine minified the code\n\t\tif (index === -1) index = findEndIndex('=' + type, content)\n\n\t\tif (index === -1) {\n\t\t\t/**\n\t\t\t * Check if pattern is at the end of the string\n\t\t\t *\n\t\t\t * @example\n\t\t\t * ```typescript\n\t\t\t * 'const a = body' // true\n\t\t\t * ```\n\t\t\t **/\n\t\t\tlet lastIndex = content.indexOf(' = ' + type)\n\t\t\tif (lastIndex === -1) lastIndex = content.indexOf('=' + type)\n\n\t\t\tif (lastIndex + 3 + type.length !== content.length) break\n\n\t\t\tindex = lastIndex\n\t\t}\n\n\t\tconst part = content.slice(0, index)\n\n\t\t// V8 engine minified the code\n\t\tconst lastPart = part.lastIndexOf(' ')\n\t\t/**\n\t\t * aliased variable last character\n\t\t *\n\t\t * @example\n\t\t * ```typescript\n\t\t * const { hello } = body // } is the last character\n\t\t * ```\n\t\t **/\n\t\tlet variable = part.slice(lastPart !== -1 ? lastPart + 1 : -1)\n\n\t\t// Variable is using object destructuring, find the bracket pair\n\t\tif (variable === '}') {\n\t\t\tconst [start, end] = bracketPairRangeReverse(part)\n\n\t\t\taliases.push(removeColonAlias(content.slice(start, end)))\n\n\t\t\tcontent = content.slice(index + 3 + type.length)\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// Remove comma\n\t\twhile (variable.charCodeAt(0) === 44) variable = variable.slice(1)\n\t\twhile (variable.charCodeAt(0) === 9) variable = variable.slice(1)\n\n\t\tif (!variable.includes('(')) aliases.push(variable)\n\n\t\tcontent = content.slice(index + 3 + type.length)\n\t}\n\n\tfor (const alias of aliases) {\n\t\tif (alias.charCodeAt(0) === 123) continue\n\n\t\tconst deepAlias = findAlias(alias, body)\n\t\tif (deepAlias.length > 0) aliases.push(...deepAlias)\n\t}\n\n\treturn aliases\n}\n\n// ? This is normalized to dot notation in Bun\n// const accessor = <T extends string, P extends string>(parent: T, prop: P) =>\n// \t[\n// \t\tparent + '.' + prop,\n// \t\tparent + '[\"' + prop + '\"]',\n// \t\tparent + \"['\" + prop + \"']\"\n// \t] as const\n\nexport const extractMainParameter = (parameter: string) => {\n\tif (!parameter) return\n\n\tif (parameter.charCodeAt(0) !== 123) return parameter\n\n\tparameter = parameter.slice(2, -2)\n\n\tconst hasComma = parameter.includes(',')\n\tif (!hasComma) {\n\t\tconst index = parameter.indexOf('...')\n\t\t// This happens when spread operator is used as the only parameter\n\t\tif (index !== -1) return parameter.slice(parameter.indexOf('...') + 3)\n\n\t\treturn\n\t}\n\n\tconst spreadIndex = parameter.indexOf('...')\n\tif (spreadIndex === -1) return\n\n\t// Spread parameter is always the last parameter, no need for further checking\n\treturn parameter.slice(spreadIndex + 3).trimEnd()\n}\n\n/**\n * Analyze if context is mentioned in body\n */\nexport const inferBodyReference = (\n\tcode: string,\n\taliases: string[],\n\tinference: Sucrose.Inference\n) => {\n\tconst access = (type: string, alias: string) =>\n\t\tnew RegExp(\n\t\t\t`${alias}\\\\.(${type})|${alias}\\\\[\"${type}\"\\\\]|${alias}\\\\['${type}'\\\\]`\n\t\t).test(code)\n\n\tfor (const alias of aliases) {\n\t\tif (!alias) continue\n\n\t\t// Scan object destructured property\n\t\tif (alias.charCodeAt(0) === 123) {\n\t\t\tconst parameters = retrieveRootParamters(alias).parameters\n\n\t\t\tif (parameters.query) inference.query = true\n\t\t\tif (parameters.headers) inference.headers = true\n\t\t\tif (parameters.body) inference.body = true\n\t\t\tif (parameters.cookie) inference.cookie = true\n\t\t\tif (parameters.set) inference.set = true\n\t\t\tif (parameters.server) inference.server = true\n\t\t\tif (parameters.url) inference.url = true\n\t\t\tif (parameters.route) inference.route = true\n\t\t\tif (parameters.path) inference.path = true\n\n\t\t\tcontinue\n\t\t}\n\n\t\tif (\n\t\t\t!inference.query &&\n\t\t\t(access('query', alias) ||\n\t\t\t\tcode.includes('return ' + alias) ||\n\t\t\t\tcode.includes('return ' + alias + '.query'))\n\t\t)\n\t\t\tinference.query = true\n\n\t\tif (!inference.headers && access('headers', alias))\n\t\t\tinference.headers = true\n\n\t\tif (!inference.body && access('body', alias)) inference.body = true\n\n\t\tif (!inference.cookie && access('cookie', alias))\n\t\t\tinference.cookie = true\n\n\t\tif (!inference.set && access('set', alias)) inference.set = true\n\t\tif (!inference.server && access('server', alias))\n\t\t\tinference.server = true\n\n\t\tif (!inference.route && access('route', alias)) inference.route = true\n\t\tif (!inference.url && access('url', alias)) inference.url = true\n\t\tif (!inference.path && access('path', alias)) inference.path = true\n\n\t\tif (\n\t\t\tinference.query &&\n\t\t\tinference.headers &&\n\t\t\tinference.body &&\n\t\t\tinference.cookie &&\n\t\t\tinference.set &&\n\t\t\tinference.server &&\n\t\t\tinference.route &&\n\t\t\tinference.url &&\n\t\t\tinference.path\n\t\t)\n\t\t\tbreak\n\t}\n\n\treturn aliases\n}\n\nexport const removeDefaultParameter = (parameter: string) => {\n\twhile (true) {\n\t\tconst index = parameter.indexOf('=')\n\t\tif (index === -1) break\n\n\t\tconst commaIndex = parameter.indexOf(',', index)\n\t\tconst bracketIndex = parameter.indexOf('}', index)\n\n\t\tconst end =\n\t\t\t[commaIndex, bracketIndex]\n\t\t\t\t.filter((i) => i > 0)\n\t\t\t\t.sort((a, b) => a - b)[0] || -1\n\n\t\tif (end === -1) {\n\t\t\tparameter = parameter.slice(0, index)\n\n\t\t\tbreak\n\t\t}\n\n\t\tparameter = parameter.slice(0, index) + parameter.slice(end)\n\t}\n\n\treturn parameter\n\t\t.split(',')\n\t\t.map((i) => i.trim())\n\t\t.join(', ')\n}\n\nexport const isContextPassToFunction = (\n\tcontext: string,\n\tbody: string,\n\tinference: Sucrose.Inference\n) => {\n\t// ! Function is passed to another function, assume as all is accessed\n\ttry {\n\t\tconst captureFunction = new RegExp(`\\\\w\\\\((.*?)?${context}`, 'gs')\n\t\tcaptureFunction.test(body)\n\n\t\t/*\n\t\tSince JavaScript engine already format the code (removing whitespace, newline, etc.),\n\t\twe can safely assume that the next character is either a closing bracket or a comma\n\t\tif the function is passed to another function\n\t\t*/\n\t\tconst nextChar = body.charCodeAt(captureFunction.lastIndex)\n\n\t\tif (nextChar === 41 || nextChar === 44) {\n\t\t\tinference.query = true\n\t\t\tinference.headers = true\n\t\t\tinference.body = true\n\t\t\tinference.cookie = true\n\t\t\tinference.set = true\n\t\t\tinference.server = true\n\t\t\tinference.url = true\n\t\t\tinference.route = true\n\t\t\tinference.path = true\n\n\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t} catch (error) {\n\t\tconsole.log(\n\t\t\t'[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:'\n\t\t)\n\t\tconsole.log('--- body ---')\n\t\tconsole.log(body)\n\t\tconsole.log('--- context ---')\n\t\tconsole.log(context)\n\n\t\treturn true\n\t}\n}\n\nlet pendingGC: number | undefined\nlet caches = <Record<number, Sucrose.Inference>>{}\n\nexport const clearSucroseCache = (delay = 0) => {\n\tif (pendingGC) clearTimeout(pendingGC)\n\n\tpendingGC = setTimeout(() => {\n\t\tcaches = {}\n\n\t\tpendingGC = undefined\n\t\tif (isBun) Bun.gc(false)\n\t}, delay) as unknown as number\n}\n\nexport const mergeInference = (a: Sucrose.Inference, b: Sucrose.Inference) => {\n\treturn {\n\t\tbody: a.body || b.body,\n\t\tcookie: a.cookie || b.cookie,\n\t\theaders: a.headers || b.headers,\n\t\tquery: a.query || b.query,\n\t\tset: a.set || b.set,\n\t\tserver: a.server || b.server,\n\t\turl: a.url || b.url,\n\t\troute: a.route || b.route,\n\t\tpath: a.path || b.path\n\t}\n}\n\nexport const sucrose = (\n\tlifeCycle: Sucrose.LifeCycle,\n\tinference: Sucrose.Inference = {\n\t\tquery: false,\n\t\theaders: false,\n\t\tbody: false,\n\t\tcookie: false,\n\t\tset: false,\n\t\tserver: false,\n\t\turl: false,\n\t\troute: false,\n\t\tpath: false\n\t}\n): Sucrose.Inference => {\n\tconst events = <(Handler | HookContainer)[]>[]\n\n\tif (lifeCycle.request?.length) events.push(...lifeCycle.request)\n\tif (lifeCycle.beforeHandle?.length) events.push(...lifeCycle.beforeHandle)\n\tif (lifeCycle.parse?.length) events.push(...lifeCycle.parse)\n\tif (lifeCycle.error?.length) events.push(...lifeCycle.error)\n\tif (lifeCycle.transform?.length) events.push(...lifeCycle.transform)\n\tif (lifeCycle.afterHandle?.length) events.push(...lifeCycle.afterHandle)\n\tif (lifeCycle.mapResponse?.length) events.push(...lifeCycle.mapResponse)\n\tif (lifeCycle.afterResponse?.length) events.push(...lifeCycle.afterResponse)\n\n\tif (lifeCycle.handler && typeof lifeCycle.handler === 'function')\n\t\tevents.push(lifeCycle.handler as Handler)\n\n\tfor (let i = 0; i < events.length; i++) {\n\t\tconst e = events[i]\n\t\tif (!e) continue\n\n\t\tconst event = typeof e === 'object' ? e.fn : e\n\n\t\t// parse can be either a function or string\n\t\tif (typeof event !== 'function') continue\n\n\t\tconst content = event.toString()\n\t\tconst key = checksum(content)\n\t\tconst cachedInference = caches[key]\n\t\tif (cachedInference) {\n\t\t\tinference = mergeInference(inference, cachedInference)\n\t\t\tcontinue\n\t\t}\n\n\t\tconst fnInference: Sucrose.Inference = {\n\t\t\tquery: false,\n\t\t\theaders: false,\n\t\t\tbody: false,\n\t\t\tcookie: false,\n\t\t\tset: false,\n\t\t\tserver: false,\n\t\t\turl: false,\n\t\t\troute: false,\n\t\t\tpath: false\n\t\t}\n\n\t\tconst [parameter, body] = separateFunction(content)\n\n\t\tconst rootParameters = findParameterReference(parameter, fnInference)\n\t\tconst mainParameter = extractMainParameter(rootParameters)\n\n\t\tif (mainParameter) {\n\t\t\tconst aliases = findAlias(mainParameter, body.slice(1, -1))\n\t\t\taliases.splice(0, -1, mainParameter)\n\n\t\t\tlet code = body\n\n\t\t\tif (\n\t\t\t\tcode.charCodeAt(0) === 123 &&\n\t\t\t\tcode.charCodeAt(body.length - 1) === 125\n\t\t\t)\n\t\t\t\tcode = code.slice(1, -1)\n\n\t\t\tif (!isContextPassToFunction(mainParameter, code, fnInference))\n\t\t\t\tinferBodyReference(code, aliases, fnInference)\n\n\t\t\tif (\n\t\t\t\t!fnInference.query &&\n\t\t\t\tcode.includes('return ' + mainParameter + '.query')\n\t\t\t)\n\t\t\t\tfnInference.query = true\n\t\t}\n\n\t\tif (!caches[key]) caches[key] = fnInference\n\n\t\tinference = mergeInference(inference, fnInference)\n\n\t\tif (\n\t\t\tinference.query &&\n\t\t\tinference.headers &&\n\t\t\tinference.body &&\n\t\t\tinference.cookie &&\n\t\t\tinference.set &&\n\t\t\tinference.server &&\n\t\t\tinference.url &&\n\t\t\tinference.route &&\n\t\t\tinference.path\n\t\t)\n\t\t\tbreak\n\t}\n\n\treturn inference\n}\n",
    "import { parse, serialize } from 'cookie'\n\nimport decode from 'fast-decode-uri-component'\n\nimport { isNotEmpty, unsignCookie } from './utils'\nimport { InvalidCookieSignature } from './error'\n\nimport type { Context } from './context'\nimport type { Prettify } from './types'\n\nexport interface CookieOptions {\n\t/**\n\t * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.3|Domain Set-Cookie attribute}. By default, no\n\t * domain is set, and most clients will consider the cookie to apply to only\n\t * the current domain.\n\t */\n\tdomain?: string | undefined\n\n\t/**\n\t * Specifies the `Date` object to be the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.1|`Expires` `Set-Cookie` attribute}. By default,\n\t * no expiration is set, and most clients will consider this a \"non-persistent cookie\" and will delete\n\t * it on a condition like exiting a web browser application.\n\t *\n\t * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}\n\t * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is\n\t * possible not all clients by obey this, so if both are set, they should\n\t * point to the same date and time.\n\t */\n\texpires?: Date | undefined\n\t/**\n\t * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.6|`HttpOnly` `Set-Cookie` attribute}.\n\t * When truthy, the `HttpOnly` attribute is set, otherwise it is not. By\n\t * default, the `HttpOnly` attribute is not set.\n\t *\n\t * *Note* be careful when setting this to true, as compliant clients will\n\t * not allow client-side JavaScript to see the cookie in `document.cookie`.\n\t */\n\thttpOnly?: boolean | undefined\n\t/**\n\t * Specifies the number (in seconds) to be the value for the `Max-Age`\n\t * `Set-Cookie` attribute. The given number will be converted to an integer\n\t * by rounding down. By default, no maximum age is set.\n\t *\n\t * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}\n\t * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is\n\t * possible not all clients by obey this, so if both are set, they should\n\t * point to the same date and time.\n\t */\n\tmaxAge?: number | undefined\n\t/**\n\t * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.4|`Path` `Set-Cookie` attribute}.\n\t * By default, the path is considered the \"default path\".\n\t */\n\tpath?: string | undefined\n\t/**\n\t * Specifies the `string` to be the value for the [`Priority` `Set-Cookie` attribute][rfc-west-cookie-priority-00-4.1].\n\t *\n\t * - `'low'` will set the `Priority` attribute to `Low`.\n\t * - `'medium'` will set the `Priority` attribute to `Medium`, the default priority when not set.\n\t * - `'high'` will set the `Priority` attribute to `High`.\n\t *\n\t * More information about the different priority levels can be found in\n\t * [the specification][rfc-west-cookie-priority-00-4.1].\n\t *\n\t * **note** This is an attribute that has not yet been fully standardized, and may change in the future.\n\t * This also means many clients may ignore this attribute until they understand it.\n\t */\n\tpriority?: 'low' | 'medium' | 'high' | undefined\n\t/**\n\t * Specifies the `boolean` value for the [`Partitioned` `Set-Cookie`](rfc-cutler-httpbis-partitioned-cookies)\n\t * attribute. When truthy, the `Partitioned` attribute is set, otherwise it is not. By default, the\n\t * `Partitioned` attribute is not set.\n\t *\n\t * **note** This is an attribute that has not yet been fully standardized, and may change in the future.\n\t * This also means many clients may ignore this attribute until they understand it.\n\t *\n\t * More information about can be found in [the proposal](https://github.com/privacycg/CHIPS)\n\t */\n\tpartitioned?: boolean | undefined\n\t/**\n\t * Specifies the boolean or string to be the value for the {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|`SameSite` `Set-Cookie` attribute}.\n\t *\n\t * - `true` will set the `SameSite` attribute to `Strict` for strict same\n\t * site enforcement.\n\t * - `false` will not set the `SameSite` attribute.\n\t * - `'lax'` will set the `SameSite` attribute to Lax for lax same site\n\t * enforcement.\n\t * - `'strict'` will set the `SameSite` attribute to Strict for strict same\n\t * site enforcement.\n\t *  - `'none'` will set the SameSite attribute to None for an explicit\n\t *  cross-site cookie.\n\t *\n\t * More information about the different enforcement levels can be found in {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|the specification}.\n\t *\n\t * *note* This is an attribute that has not yet been fully standardized, and may change in the future. This also means many clients may ignore this attribute until they understand it.\n\t */\n\tsameSite?: true | false | 'lax' | 'strict' | 'none' | undefined\n\t/**\n\t * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.5|`Secure` `Set-Cookie` attribute}. When truthy, the\n\t * `Secure` attribute is set, otherwise it is not. By default, the `Secure` attribute is not set.\n\t *\n\t * *Note* be careful when setting this to `true`, as compliant clients will\n\t * not send the cookie back to the server in the future if the browser does\n\t * not have an HTTPS connection.\n\t */\n\tsecure?: boolean | undefined\n\n\t/**\n\t * Secret key for signing cookie\n\t *\n\t * If array is passed, will use Key Rotation.\n\t *\n\t * Key rotation is when an encryption key is retired\n\t * and replaced by generating a new cryptographic key.\n\t */\n\tsecrets?: string | string[]\n}\n\nexport type ElysiaCookie = Prettify<\n\tCookieOptions & {\n\t\tvalue?: unknown\n\t}\n>\n\ntype Updater<T> = T | ((value: T) => T)\n\nexport class Cookie<T> implements ElysiaCookie {\n\tconstructor(\n\t\tprivate name: string,\n\t\tprivate jar: Record<string, ElysiaCookie>,\n\t\tprivate initial: Partial<ElysiaCookie> = {}\n\t) {}\n\n\tget cookie() {\n\t\treturn this.jar[this.name] ?? this.initial\n\t}\n\n\tset cookie(jar: ElysiaCookie) {\n\t\tif (!(this.name in this.jar)) this.jar[this.name] = this.initial\n\n\t\tthis.jar[this.name] = jar\n\t}\n\n\tprotected get setCookie() {\n\t\tif (!(this.name in this.jar)) this.jar[this.name] = this.initial\n\n\t\treturn this.jar[this.name]\n\t}\n\n\tprotected set setCookie(jar: ElysiaCookie) {\n\t\tthis.cookie = jar\n\t}\n\n\tget value(): T {\n\t\treturn this.cookie.value as T\n\t}\n\n\tset value(value: T) {\n\t\tthis.setCookie.value = value\n\t}\n\n\tget expires() {\n\t\treturn this.cookie.expires\n\t}\n\n\tset expires(expires) {\n\t\tthis.setCookie.expires = expires\n\t}\n\n\tget maxAge() {\n\t\treturn this.cookie.maxAge\n\t}\n\n\tset maxAge(maxAge) {\n\t\tthis.setCookie.maxAge = maxAge\n\t}\n\n\tget domain() {\n\t\treturn this.cookie.domain\n\t}\n\n\tset domain(domain) {\n\t\tthis.setCookie.domain = domain\n\t}\n\n\tget path() {\n\t\treturn this.cookie.path\n\t}\n\n\tset path(path) {\n\t\tthis.setCookie.path = path\n\t}\n\n\tget secure() {\n\t\treturn this.cookie.secure\n\t}\n\n\tset secure(secure) {\n\t\tthis.setCookie.secure = secure\n\t}\n\n\tget httpOnly() {\n\t\treturn this.cookie.httpOnly\n\t}\n\n\tset httpOnly(httpOnly) {\n\t\tthis.setCookie.httpOnly = httpOnly\n\t}\n\n\tget sameSite() {\n\t\treturn this.cookie.sameSite\n\t}\n\n\tset sameSite(sameSite) {\n\t\tthis.setCookie.sameSite = sameSite\n\t}\n\n\tget priority() {\n\t\treturn this.cookie.priority\n\t}\n\n\tset priority(priority) {\n\t\tthis.setCookie.priority = priority\n\t}\n\n\tget partitioned() {\n\t\treturn this.cookie.partitioned\n\t}\n\n\tset partitioned(partitioned) {\n\t\tthis.setCookie.partitioned = partitioned\n\t}\n\n\tget secrets() {\n\t\treturn this.cookie.secrets\n\t}\n\n\tset secrets(secrets) {\n\t\tthis.setCookie.secrets = secrets\n\t}\n\n\tupdate(config: Updater<Partial<ElysiaCookie>>) {\n\t\tthis.setCookie = Object.assign(\n\t\t\tthis.cookie,\n\t\t\ttypeof config === 'function' ? config(this.cookie) : config\n\t\t)\n\n\t\treturn this\n\t}\n\n\tset(config: Updater<Partial<ElysiaCookie>>) {\n\t\tthis.setCookie = Object.assign(\n\t\t\t{\n\t\t\t\t...this.initial,\n\t\t\t\tvalue: this.value\n\t\t\t},\n\t\t\ttypeof config === 'function' ? config(this.cookie) : config\n\t\t)\n\n\t\treturn this\n\t}\n\n\tremove() {\n\t\tif (this.value === undefined) return\n\n\t\tthis.set({\n\t\t\texpires: new Date(0),\n\t\t\tmaxAge: 0,\n\t\t\tvalue: ''\n\t\t})\n\n\t\treturn this\n\t}\n\n\ttoString() {\n\t\treturn typeof this.value === 'object'\n\t\t\t? JSON.stringify(this.value)\n\t\t\t: (this.value?.toString() ?? '')\n\t}\n}\n\nexport const createCookieJar = (\n\tset: Context['set'],\n\tstore: Record<string, ElysiaCookie>,\n\tinitial?: Partial<ElysiaCookie>\n): Record<string, Cookie<unknown>> => {\n\tif (!set.cookie) set.cookie = {}\n\n\treturn new Proxy(store, {\n\t\tget(_, key: string) {\n\t\t\tif (key in store)\n\t\t\t\treturn new Cookie(\n\t\t\t\t\tkey,\n\t\t\t\t\tset.cookie as Record<string, ElysiaCookie>,\n\t\t\t\t\tObject.assign({}, initial ?? {}, store[key])\n\t\t\t\t)\n\n\t\t\treturn new Cookie(\n\t\t\t\tkey,\n\t\t\t\tset.cookie as Record<string, ElysiaCookie>,\n\t\t\t\tObject.assign({}, initial)\n\t\t\t)\n\t\t}\n\t}) as Record<string, Cookie<unknown>>\n}\n\nexport const parseCookie = async (\n\tset: Context['set'],\n\tcookieString?: string | null,\n\t{\n\t\tsecrets,\n\t\tsign,\n\t\t...initial\n\t}: CookieOptions & {\n\t\tsign?: true | string | string[]\n\t} = {}\n) => {\n\tif (!cookieString) return createCookieJar(set, {}, initial)\n\n\tconst isStringKey = typeof secrets === 'string'\n\tif (sign && sign !== true && !Array.isArray(sign)) sign = [sign]\n\n\tconst jar: Record<string, ElysiaCookie> = {}\n\n\tconst cookies = parse(cookieString)\n\tfor (const [name, v] of Object.entries(cookies)) {\n\t\tif (v === undefined) continue\n\n\t\tlet value = decode(v)\n\n\t\tif (sign === true || sign?.includes(name)) {\n\t\t\tif (!secrets)\n\t\t\t\tthrow new Error('No secret is provided to cookie plugin')\n\n\t\t\tif (isStringKey) {\n\t\t\t\tconst temp = await unsignCookie(value as string, secrets)\n\t\t\t\tif (temp === false) throw new InvalidCookieSignature(name)\n\n\t\t\t\tvalue = temp\n\t\t\t} else {\n\t\t\t\tlet decoded = true\n\t\t\t\tfor (let i = 0; i < secrets.length; i++) {\n\t\t\t\t\tconst temp = await unsignCookie(value as string, secrets[i])\n\n\t\t\t\t\tif (temp !== false) {\n\t\t\t\t\t\tdecoded = true\n\t\t\t\t\t\tvalue = temp\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!decoded) throw new InvalidCookieSignature(name)\n\t\t\t}\n\t\t}\n\n\t\tjar[name] = {\n\t\t\tvalue\n\t\t}\n\t}\n\n\treturn createCookieJar(set, jar, initial)\n}\n\nexport const serializeCookie = (cookies: Context['set']['cookie']) => {\n\tif (!cookies || !isNotEmpty(cookies)) return undefined\n\n\tconst set: string[] = []\n\n\tfor (const [key, property] of Object.entries(cookies)) {\n\t\tif (!key || !property) continue\n\n\t\tconst value = property.value\n\t\tif (value === undefined || value === null) continue\n\n\t\tset.push(\n\t\t\tserialize(\n\t\t\t\tkey,\n\t\t\t\ttypeof value === 'object' ? JSON.stringify(value) : value + '',\n\t\t\t\tproperty\n\t\t\t)\n\t\t)\n\t}\n\n\tif (set.length === 0) return undefined\n\tif (set.length === 1) return set[0]\n\n\treturn set\n}\n",
    "import { serializeCookie } from '../cookies'\nimport { hasHeaderShorthand, isNotEmpty, StatusMap } from '../utils'\n\nimport type { Context } from '../context'\nimport { isBun } from '../universal/utils'\n\nexport const handleFile = (\n\tresponse: File | Blob,\n\tset?: Context['set']\n): Response => {\n\tif (!isBun && response instanceof Promise)\n\t\treturn response.then((res) => handleFile(res, set)) as any\n\n\tconst size = response.size\n\n\tif (\n\t\t(!set && size) ||\n\t\t(size &&\n\t\t\tset &&\n\t\t\tset.status !== 206 &&\n\t\t\tset.status !== 304 &&\n\t\t\tset.status !== 412 &&\n\t\t\tset.status !== 416)\n\t) {\n\t\tif (set) {\n\t\t\tif (set.headers instanceof Headers) {\n\t\t\t\tlet setHeaders: Record<string, any> = {\n\t\t\t\t\t'accept-ranges': 'bytes',\n\t\t\t\t\t'content-range': `bytes 0-${size - 1}/${size}`,\n\t\t\t\t\t'transfer-encoding': 'chunked'\n\t\t\t\t}\n\n\t\t\t\tif (hasHeaderShorthand)\n\t\t\t\t\tsetHeaders = (set.headers as unknown as Headers).toJSON()\n\t\t\t\telse {\n\t\t\t\t\tsetHeaders = {}\n\t\t\t\t\tfor (const [key, value] of set.headers.entries())\n\t\t\t\t\t\tif (key in set.headers) setHeaders[key] = value\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as Blob, {\n\t\t\t\t\tstatus: set.status as number,\n\t\t\t\t\theaders: setHeaders\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (isNotEmpty(set.headers))\n\t\t\t\treturn new Response(response as Blob, {\n\t\t\t\t\tstatus: set.status as number,\n\t\t\t\t\theaders: Object.assign(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t'accept-ranges': 'bytes',\n\t\t\t\t\t\t\t'content-range': `bytes 0-${size - 1}/${size}`,\n\t\t\t\t\t\t\t'transfer-encoding': 'chunked'\n\t\t\t\t\t\t} as any,\n\t\t\t\t\t\tset.headers\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t}\n\n\t\treturn new Response(response as Blob, {\n\t\t\theaders: {\n\t\t\t\t'accept-ranges': 'bytes',\n\t\t\t\t'content-range': `bytes 0-${size - 1}/${size}`,\n\t\t\t\t'transfer-encoding': 'chunked'\n\t\t\t}\n\t\t})\n\t}\n\n\treturn new Response(response as Blob)\n}\n\nexport const parseSetCookies = (headers: Headers, setCookie: string[]) => {\n\tif (!headers) return headers\n\n\theaders.delete('set-cookie')\n\n\tfor (let i = 0; i < setCookie.length; i++) {\n\t\tconst index = setCookie[i].indexOf('=')\n\n\t\theaders.append(\n\t\t\t'set-cookie',\n\t\t\t`${setCookie[i].slice(0, index)}=${\n\t\t\t\tsetCookie[i].slice(index + 1) || ''\n\t\t\t}`\n\t\t)\n\t}\n\n\treturn headers\n}\n\nexport const responseToSetHeaders = (\n\tresponse: Response,\n\tset?: Context['set']\n) => {\n\tif (set?.headers) {\n\t\tif (response) {\n\t\t\tif (hasHeaderShorthand)\n\t\t\t\tObject.assign(set.headers, response.headers.toJSON())\n\t\t\telse\n\t\t\t\tfor (const [key, value] of response.headers.entries())\n\t\t\t\t\tif (key in set.headers) set.headers[key] = value\n\t\t}\n\n\t\tif (set.status === 200) set.status = response.status\n\n\t\t// ? `content-encoding` prevent response streaming\n\t\tif (set.headers['content-encoding'])\n\t\t\tdelete set.headers['content-encoding']\n\n\t\treturn set\n\t}\n\n\tif (!response)\n\t\treturn {\n\t\t\theaders: {},\n\t\t\tstatus: set?.status ?? 200\n\t\t}\n\n\tif (hasHeaderShorthand) {\n\t\tset = {\n\t\t\theaders: response.headers.toJSON(),\n\t\t\tstatus: set?.status ?? 200\n\t\t}\n\n\t\t// ? `content-encoding` prevent response streaming\n\t\tif (set.headers['content-encoding'])\n\t\t\tdelete set.headers['content-encoding']\n\n\t\treturn set\n\t}\n\n\tset = {\n\t\theaders: {},\n\t\tstatus: set?.status ?? 200\n\t}\n\n\tfor (const [key, value] of response.headers.entries()) {\n\t\t// ? `content-encoding` prevent response streaming\n\n\t\tif (key === 'content-encoding') continue\n\n\t\tif (key in set.headers) set.headers[key] = value\n\t}\n\n\treturn set\n}\n\ntype CreateHandlerParameter = {\n\tmapResponse(\n\t\tresponse: unknown,\n\t\tset: Context['set'],\n\t\trequest?: Request\n\t): Response\n\tmapCompactResponse(response: unknown, request?: Request): Response\n}\n\nexport const createStreamHandler =\n\t({ mapResponse, mapCompactResponse }: CreateHandlerParameter) =>\n\tasync (\n\t\tgenerator: Generator | AsyncGenerator,\n\t\tset?: Context['set'],\n\t\trequest?: Request\n\t) => {\n\t\tlet init = generator.next()\n\t\tif (init instanceof Promise) init = await init\n\n\t\tif (init.done) {\n\t\t\tif (set) return mapResponse(init.value, set, request)\n\t\t\treturn mapCompactResponse(init.value, request)\n\t\t}\n\n\t\tif (set?.headers) {\n\t\t\tif (!set.headers['transfer-encoding'])\n\t\t\t\tset.headers['transfer-encoding'] = 'chunked'\n\t\t\tif (!set.headers['content-type'])\n\t\t\t\tset.headers['content-type'] = 'text/event-stream; charset=utf-8'\n\t\t} else {\n\t\t\tset = {\n\t\t\t\tstatus: 200,\n\t\t\t\theaders: {\n\t\t\t\t\t'content-type': 'text/event-stream; charset=utf-8',\n\t\t\t\t\t'transfer-encoding': 'chunked'\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Response(\n\t\t\tnew ReadableStream({\n\t\t\t\tasync start(controller) {\n\t\t\t\t\tlet end = false\n\n\t\t\t\t\trequest?.signal?.addEventListener('abort', () => {\n\t\t\t\t\t\tend = true\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcontroller.close()\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t// nothing\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\t\tif (init.value !== undefined && init.value !== null) {\n\t\t\t\t\t\tif (typeof init.value === 'object')\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tcontroller.enqueue(\n\t\t\t\t\t\t\t\t\tBuffer.from(JSON.stringify(init.value))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\tcontroller.enqueue(\n\t\t\t\t\t\t\t\t\tBuffer.from(init.value.toString())\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcontroller.enqueue(\n\t\t\t\t\t\t\t\tBuffer.from(init.value.toString())\n\t\t\t\t\t\t\t)\n\t\t\t\t\t}\n\n\t\t\t\t\tfor await (const chunk of generator) {\n\t\t\t\t\t\tif (end) break\n\t\t\t\t\t\tif (chunk === undefined || chunk === null) continue\n\n\t\t\t\t\t\tif (typeof chunk === 'object')\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tcontroller.enqueue(\n\t\t\t\t\t\t\t\t\tBuffer.from(JSON.stringify(chunk))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\tcontroller.enqueue(\n\t\t\t\t\t\t\t\t\tBuffer.from(chunk.toString())\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\telse controller.enqueue(Buffer.from(chunk.toString()))\n\n\t\t\t\t\t\t// Wait for the next event loop\n\t\t\t\t\t\t// Otherwise the data will be mixed up\n\t\t\t\t\t\tawait new Promise<void>((resolve) =>\n\t\t\t\t\t\t\tsetTimeout(() => resolve(), 0)\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcontroller.close()\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// nothing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}),\n\t\t\tset as any\n\t\t)\n\t}\n\nexport async function* streamResponse(response: Response) {\n\tconst body = response.body\n\n\tif (!body) return\n\n\tconst reader = body.getReader()\n\tconst decoder = new TextDecoder()\n\n\ttry {\n\t\twhile (true) {\n\t\t\tconst { done, value } = await reader.read()\n\t\t\tif (done) break\n\n\t\t\tyield decoder.decode(value)\n\t\t}\n\t} finally {\n\t\treader.releaseLock()\n\t}\n}\n\nexport const handleSet = (set: Context['set']) => {\n\tif (typeof set.status === 'string') set.status = StatusMap[set.status]\n\n\tif (set.cookie && isNotEmpty(set.cookie)) {\n\t\tconst cookie = serializeCookie(set.cookie)\n\n\t\tif (cookie) set.headers['set-cookie'] = cookie\n\t}\n\n\tif (set.headers['set-cookie'] && Array.isArray(set.headers['set-cookie'])) {\n\t\tset.headers = parseSetCookies(\n\t\t\tnew Headers(set.headers as any) as Headers,\n\t\t\tset.headers['set-cookie']\n\t\t) as any\n\t}\n}\n\nexport const createResponseHandler = (handler: CreateHandlerParameter) => {\n\tconst handleStream = createStreamHandler(handler)\n\n\treturn (response: Response, set: Context['set'], request?: Request) => {\n\t\tlet isCookieSet = false\n\n\t\tif (set.headers instanceof Headers)\n\t\t\tfor (const key of set.headers.keys()) {\n\t\t\t\tif (key === 'set-cookie') {\n\t\t\t\t\tif (isCookieSet) continue\n\n\t\t\t\t\tisCookieSet = true\n\n\t\t\t\t\tfor (const cookie of set.headers.getSetCookie())\n\t\t\t\t\t\tresponse.headers.append('set-cookie', cookie)\n\t\t\t\t} else response.headers.append(key, set.headers?.get(key) ?? '')\n\t\t\t}\n\t\telse\n\t\t\tfor (const key in set.headers)\n\t\t\t\t(response as Response).headers.append(\n\t\t\t\t\tkey,\n\t\t\t\t\tset.headers[key] as any\n\t\t\t\t)\n\n\t\tconst status = set.status ?? 200\n\n\t\tif (\n\t\t\t(response as Response).status !== status &&\n\t\t\tstatus !== 200 &&\n\t\t\t((response.status as number) <= 300 ||\n\t\t\t\t(response.status as number) > 400)\n\t\t)\n\t\t\treturn response.text().then((value) => {\n\t\t\t\tconst newResponse = new Response(value, {\n\t\t\t\t\theaders: response.headers,\n\t\t\t\t\tstatus: set.status as number\n\t\t\t\t})\n\n\t\t\t\tif (\n\t\t\t\t\t!(newResponse as Response).headers.has('content-length') &&\n\t\t\t\t\t(newResponse as Response).headers.get(\n\t\t\t\t\t\t'transfer-encoding'\n\t\t\t\t\t) === 'chunked'\n\t\t\t\t)\n\t\t\t\t\treturn handleStream(\n\t\t\t\t\t\tstreamResponse(newResponse as Response),\n\t\t\t\t\t\tresponseToSetHeaders(newResponse as Response, set),\n\t\t\t\t\t\trequest\n\t\t\t\t\t) as any\n\n\t\t\t\treturn newResponse\n\t\t\t})\n\n\t\tif (\n\t\t\t!(response as Response).headers.has('content-length') &&\n\t\t\t(response as Response).headers.get('transfer-encoding') ===\n\t\t\t\t'chunked'\n\t\t)\n\t\t\treturn handleStream(\n\t\t\t\tstreamResponse(response as Response),\n\t\t\t\tresponseToSetHeaders(response as Response, set),\n\t\t\t\trequest\n\t\t\t) as any\n\n\t\treturn response\n\t}\n}\n",
    "/* eslint-disable sonarjs/no-nested-switch */\n/* eslint-disable sonarjs/no-duplicate-string */\nimport {\n\tcreateResponseHandler,\n\tcreateStreamHandler,\n\thandleFile,\n\thandleSet,\n\tresponseToSetHeaders,\n\tstreamResponse\n} from '../utils'\n\nimport { ElysiaFile } from '../../universal/file'\nimport { isNotEmpty } from '../../utils'\nimport { Cookie } from '../../cookies'\nimport { ElysiaCustomStatusResponse } from '../../error'\n\nimport type { Context } from '../../context'\nimport type { AnyLocalHook } from '../../types'\n\nexport const mapResponse = (\n\tresponse: unknown,\n\tset: Context['set'],\n\trequest?: Request\n): Response => {\n\tif (isNotEmpty(set.headers) || set.status !== 200 || set.cookie) {\n\t\thandleSet(set)\n\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\tset.headers['content-type'] = 'text/plain'\n\t\t\t\treturn new Response(response as string, set as any)\n\n\t\t\tcase 'Array':\n\t\t\tcase 'Object':\n\t\t\t\tset.headers['content-type'] = 'application/json'\n\t\t\t\treturn new Response(JSON.stringify(response), set as any)\n\n\t\t\tcase 'ElysiaFile':\n\t\t\t\treturn handleFile((response as ElysiaFile).value as File)\n\t\t\t\n\t\t\tcase 'File':\n\t\t\t\treturn handleFile(response as File, set as any)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as Blob, set as any)\n\n\t\t\tcase 'ElysiaCustomStatusResponse':\n\t\t\t\tset.status = (response as ElysiaCustomStatusResponse<200>).code\n\n\t\t\t\treturn mapResponse(\n\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\tset,\n\t\t\t\t\trequest\n\t\t\t\t)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\tif (\n\t\t\t\t\t!set.headers['content-type']?.startsWith(\n\t\t\t\t\t\t'text/event-stream'\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\tset.headers['content-type'] =\n\t\t\t\t\t\t'text/event-stream; charset=utf-8'\n\n\t\t\t\trequest?.signal?.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t{\n\t\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\t\tif (request?.signal && !request?.signal?.aborted)\n\t\t\t\t\t\t\t\t(response as ReadableStream).cancel()\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn new Response(response as ReadableStream, set as any)\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('', set as any)\n\n\t\t\t\treturn new Response(JSON.stringify(response), set as any)\n\n\t\t\tcase 'Response':\n\t\t\t\treturn handleResponse(response as Response, set, request)\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Promise':\n\t\t\t\treturn (response as Promise<any>).then((x) =>\n\t\t\t\t\tmapResponse(x, set, request)\n\t\t\t\t) as any\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapResponse((response as Function)(), set, request)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response(\n\t\t\t\t\t(response as number | boolean).toString(),\n\t\t\t\t\tset as any\n\t\t\t\t)\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as any)\n\n\t\t\t\treturn new Response(response?.toString(), set as any)\n\n\t\t\tcase 'FormData':\n\t\t\t\treturn new Response(response as FormData, set as any)\n\n\t\t\tdefault:\n\t\t\t\t// recheck Response, Promise, Error because some library may extends Response\n\t\t\t\tif (response instanceof Response)\n\t\t\t\t\treturn handleResponse(response as Response, set, request)\n\n\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\treturn response.then((x) => mapResponse(x, set)) as any\n\n\t\t\t\tif (response instanceof Error)\n\t\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\t\tif (response instanceof ElysiaCustomStatusResponse) {\n\t\t\t\t\tset.status = (\n\t\t\t\t\t\tresponse as ElysiaCustomStatusResponse<200>\n\t\t\t\t\t).code\n\n\t\t\t\t\treturn mapResponse(\n\t\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\t\tset,\n\t\t\t\t\t\trequest\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.next === 'function')\n\t\t\t\t\treturn handleStream(response as any, set, request) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.then === 'function')\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\treturn response.then((x) => mapResponse(x, set)) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.toResponse === 'function')\n\t\t\t\t\treturn mapResponse((response as any).toResponse(), set)\n\n\t\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t\tset as any\n\t\t\t\t\t\t) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as any, set as any)\n\t\t}\n\t}\n\n\tif (\n\t\tresponse instanceof Response &&\n\t\t!(response as Response).headers.has('content-length') &&\n\t\t(response as Response).headers.get('transfer-encoding') === 'chunked'\n\t)\n\t\treturn handleStream(\n\t\t\tstreamResponse(response),\n\t\t\tresponseToSetHeaders(response as Response, set),\n\t\t\trequest\n\t\t) as any\n\n\t// Stream response defers a 'set' API, assume that it may include 'set'\n\tif (\n\t\t// @ts-expect-error\n\t\ttypeof response?.next === 'function' ||\n\t\tresponse instanceof ReadableStream\n\t)\n\t\treturn handleStream(response as any, set, request) as any\n\n\treturn mapCompactResponse(response, request)\n}\n\nexport const mapEarlyResponse = (\n\tresponse: unknown,\n\tset: Context['set'],\n\trequest?: Request\n): Response | undefined => {\n\tif (response === undefined || response === null) return\n\n\tif (isNotEmpty(set.headers) || set.status !== 200 || set.cookie) {\n\t\thandleSet(set)\n\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\tset.headers['content-type'] = 'text/plain'\n\t\t\t\treturn new Response(response as string, set as any)\n\n\t\t\tcase 'Array':\n\t\t\tcase 'Object':\n\t\t\t\tset.headers['content-type'] = 'application/json'\n\t\t\t\treturn new Response(JSON.stringify(response), set as any)\n\n\t\t\tcase 'ElysiaFile':\n\t\t\t\treturn handleFile((response as ElysiaFile).value as File)\n\n\t\t\tcase 'File':\n\t\t\t\treturn handleFile(response as File, set as any)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'ElysiaCustomStatusResponse':\n\t\t\t\tset.status = (response as ElysiaCustomStatusResponse<200>).code\n\n\t\t\t\treturn mapEarlyResponse(\n\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\tset,\n\t\t\t\t\trequest\n\t\t\t\t)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\tif (\n\t\t\t\t\t!set.headers['content-type']?.startsWith(\n\t\t\t\t\t\t'text/event-stream'\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\tset.headers['content-type'] =\n\t\t\t\t\t\t'text/event-stream; charset=utf-8'\n\n\t\t\t\trequest?.signal?.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t{\n\t\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\t\tif (request?.signal && !request?.signal?.aborted)\n\t\t\t\t\t\t\t\t(response as ReadableStream).cancel()\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn new Response(response as ReadableStream, set as any)\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return\n\n\t\t\t\treturn new Response(JSON.stringify(response), set as any)\n\n\t\t\tcase 'Response':\n\t\t\t\treturn handleResponse(response as Response, set, request)\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as Promise<unknown>).then((x) =>\n\t\t\t\t\tmapEarlyResponse(x, set)\n\t\t\t\t)\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapEarlyResponse((response as Function)(), set)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response(\n\t\t\t\t\t(response as number | boolean).toString(),\n\t\t\t\t\tset as any\n\t\t\t\t)\n\n\t\t\tcase 'FormData':\n\t\t\t\treturn new Response(response as FormData)\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as any)\n\n\t\t\t\treturn new Response(response?.toString(), set as any)\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response)\n\t\t\t\t\treturn handleResponse(response, set, request)\n\n\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\treturn response.then((x) => mapEarlyResponse(x, set)) as any\n\n\t\t\t\tif (response instanceof Error)\n\t\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\t\tif (response instanceof ElysiaCustomStatusResponse) {\n\t\t\t\t\tset.status = (\n\t\t\t\t\t\tresponse as ElysiaCustomStatusResponse<200>\n\t\t\t\t\t).code\n\n\t\t\t\t\treturn mapEarlyResponse(\n\t\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\t\tset,\n\t\t\t\t\t\trequest\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.next === 'function')\n\t\t\t\t\treturn handleStream(response as any, set, request) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.then === 'function')\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\treturn response.then((x) => mapEarlyResponse(x, set)) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.toResponse === 'function')\n\t\t\t\t\treturn mapEarlyResponse((response as any).toResponse(), set)\n\n\t\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t\tset as any\n\t\t\t\t\t\t) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as any, set as any)\n\t\t}\n\t} else\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\tset.headers['content-type'] = 'text/plain'\n\t\t\t\treturn new Response(response as string)\n\n\t\t\tcase 'Array':\n\t\t\tcase 'Object':\n\t\t\t\tset.headers['content-type'] = 'application/json'\n\t\t\t\treturn new Response(JSON.stringify(response), set as any)\n\n\t\t\tcase 'ElysiaFile':\n\t\t\t\treturn handleFile((response as ElysiaFile).value as File)\n\n\t\t\tcase 'File':\n\t\t\t\treturn handleFile(response as File, set as any)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'ElysiaCustomStatusResponse':\n\t\t\t\tset.status = (response as ElysiaCustomStatusResponse<200>).code\n\n\t\t\t\treturn mapEarlyResponse(\n\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\tset,\n\t\t\t\t\trequest\n\t\t\t\t)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\trequest?.signal?.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t{\n\t\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\t\tif (request?.signal && !request?.signal?.aborted)\n\t\t\t\t\t\t\t\t(response as ReadableStream).cancel()\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('')\n\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'Response':\n\t\t\t\tif (\n\t\t\t\t\t!(response as Response).headers.has('content-length') &&\n\t\t\t\t\t(response as Response).headers.get('transfer-encoding') ===\n\t\t\t\t\t\t'chunked'\n\t\t\t\t)\n\t\t\t\t\treturn handleStream(\n\t\t\t\t\t\tstreamResponse(response as Response),\n\t\t\t\t\t\tresponseToSetHeaders(response as Response),\n\t\t\t\t\t\trequest\n\t\t\t\t\t) as any\n\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapEarlyResponse(x, set)\n\t\t\t\t\tif (r !== undefined) return r\n\t\t\t\t})\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapCompactResponse((response as Function)(), request)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as any)\n\n\t\t\t\treturn new Response(response?.toString(), set as any)\n\n\t\t\tcase 'FormData':\n\t\t\t\treturn new Response(response as FormData)\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response) return response\n\n\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\treturn response.then((x) => mapEarlyResponse(x, set)) as any\n\n\t\t\t\tif (response instanceof Error)\n\t\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\t\tif (response instanceof ElysiaCustomStatusResponse) {\n\t\t\t\t\tset.status = (\n\t\t\t\t\t\tresponse as ElysiaCustomStatusResponse<200>\n\t\t\t\t\t).code\n\n\t\t\t\t\treturn mapEarlyResponse(\n\t\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\t\tset,\n\t\t\t\t\t\trequest\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.next === 'function')\n\t\t\t\t\treturn handleStream(response as any, set, request) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.then === 'function')\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\treturn response.then((x) => mapEarlyResponse(x, set)) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.toResponse === 'function')\n\t\t\t\t\treturn mapEarlyResponse((response as any).toResponse(), set)\n\n\t\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t\tset as any\n\t\t\t\t\t\t) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as any)\n\t\t}\n}\n\nexport const mapCompactResponse = (\n\tresponse: unknown,\n\trequest?: Request\n): Response => {\n\tswitch (response?.constructor?.name) {\n\t\tcase 'String':\n\t\t\treturn new Response(response as string, {\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'text/plain'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase 'Object':\n\t\tcase 'Array':\n\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase 'ElysiaFile':\n\t\t\treturn handleFile((response as ElysiaFile).value as File)\n\n\t\tcase 'File':\n\t\t\treturn handleFile(response as File)\n\n\t\tcase 'Blob':\n\t\t\treturn handleFile(response as File | Blob)\n\n\t\tcase 'ElysiaCustomStatusResponse':\n\t\t\treturn mapResponse(\n\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t{\n\t\t\t\t\tstatus: (response as ElysiaCustomStatusResponse<200>).code,\n\t\t\t\t\theaders: {}\n\t\t\t\t}\n\t\t\t)\n\n\t\tcase 'ReadableStream':\n\t\t\trequest?.signal?.addEventListener(\n\t\t\t\t'abort',\n\t\t\t\t{\n\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\tif (request?.signal && !request?.signal?.aborted)\n\t\t\t\t\t\t\t(response as ReadableStream).cancel()\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tonce: true\n\t\t\t\t}\n\t\t\t)\n\n\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase undefined:\n\t\t\tif (!response) return new Response('')\n\n\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\theaders: {\n\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase 'Response':\n\t\t\tif (\n\t\t\t\t(response as Response).headers.get('transfer-encoding') ===\n\t\t\t\t'chunked'\n\t\t\t)\n\t\t\t\treturn handleStream(\n\t\t\t\t\tstreamResponse(response as Response),\n\t\t\t\t\tresponseToSetHeaders(response as Response),\n\t\t\t\t\trequest\n\t\t\t\t) as any\n\n\t\t\treturn response as Response\n\n\t\tcase 'Error':\n\t\t\treturn errorToResponse(response as Error)\n\n\t\tcase 'Promise':\n\t\t\treturn (response as any as Promise<unknown>).then((x) =>\n\t\t\t\tmapCompactResponse(x, request)\n\t\t\t) as any\n\n\t\t// ? Maybe response or Blob\n\t\tcase 'Function':\n\t\t\treturn mapCompactResponse((response as Function)(), request)\n\n\t\tcase 'Number':\n\t\tcase 'Boolean':\n\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\tcase 'FormData':\n\t\t\treturn new Response(response as FormData)\n\n\t\tdefault:\n\t\t\tif (response instanceof Response) return response\n\n\t\t\tif (response instanceof Promise)\n\t\t\t\treturn response.then((x) =>\n\t\t\t\t\tmapCompactResponse(x, request)\n\t\t\t\t) as any\n\n\t\t\tif (response instanceof Error)\n\t\t\t\treturn errorToResponse(response as Error)\n\n\t\t\tif (response instanceof ElysiaCustomStatusResponse)\n\t\t\t\treturn mapResponse(\n\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\t{\n\t\t\t\t\t\tstatus: (response as ElysiaCustomStatusResponse<200>)\n\t\t\t\t\t\t\t.code,\n\t\t\t\t\t\theaders: {}\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t// @ts-expect-error\n\t\t\tif (typeof response?.next === 'function')\n\t\t\t\treturn handleStream(response as any, undefined, request) as any\n\n\t\t\t// @ts-expect-error\n\t\t\tif (typeof response?.then === 'function')\n\t\t\t\t// @ts-expect-error\n\t\t\t\treturn response.then((x) => mapResponse(x, set)) as any\n\n\t\t\t// @ts-expect-error\n\t\t\tif (typeof response?.toResponse === 'function')\n\t\t\t\treturn mapCompactResponse((response as any).toResponse())\n\n\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t}\n\t\t\t\t\t}) as any\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new Response(response as any)\n\t}\n}\n\nexport const errorToResponse = (error: Error, set?: Context['set']) =>\n\tnew Response(\n\t\tJSON.stringify({\n\t\t\tname: error?.name,\n\t\t\tmessage: error?.message,\n\t\t\tcause: error?.cause\n\t\t}),\n\t\t{\n\t\t\tstatus:\n\t\t\t\tset?.status !== 200 ? ((set?.status as number) ?? 500) : 500,\n\t\t\theaders: set?.headers as any\n\t\t}\n\t)\n\nexport const createStaticHandler = (\n\thandle: unknown,\n\thooks: Partial<AnyLocalHook>,\n\tsetHeaders: Context['set']['headers'] = {}\n): (() => Response) | undefined => {\n\tif (typeof handle === 'function') return\n\n\tconst response = mapResponse(handle, {\n\t\theaders: setHeaders\n\t})\n\n\tif (\n\t\t!hooks.parse?.length &&\n\t\t!hooks.transform?.length &&\n\t\t!hooks.beforeHandle?.length &&\n\t\t!hooks.afterHandle?.length\n\t)\n\t\treturn response.clone.bind(response) as any\n}\n\nconst handleResponse = createResponseHandler({\n\tmapResponse,\n\tmapCompactResponse\n})\n\nconst handleStream = createStreamHandler({\n\tmapResponse,\n\tmapCompactResponse\n})\n",
    "import {\n\tmapResponse,\n\tmapEarlyResponse,\n\tmapCompactResponse,\n\tcreateStaticHandler\n} from './handler'\n\nimport type { ElysiaAdapter } from '../types'\n\nexport const WebStandardAdapter: ElysiaAdapter = {\n\tname: 'web-standard',\n\tisWebStandard: true,\n\thandler: {\n\t\tmapResponse,\n\t\tmapEarlyResponse,\n\t\tmapCompactResponse,\n\t\tcreateStaticHandler\n\t},\n\tcomposeHandler: {\n\t\tmapResponseContext: 'c.request',\n\t\tpreferWebstandardHeaders: true,\n\t\t// @ts-ignore Bun specific\n\t\theaders:\n\t\t\t'c.headers={}\\n' +\n\t\t\t'for(const [k,v] of c.request.headers.entries())' +\n\t\t\t'c.headers[k]=v\\n',\n\t\tparser: {\n\t\t\tjson(isOptional) {\n\t\t\t\tif (isOptional)\n\t\t\t\t\treturn `try{c.body=await c.request.json()}catch{}\\n`\n\t\t\t\treturn `c.body=await c.request.json()\\n`\n\t\t\t},\n\t\t\ttext() {\n\t\t\t\treturn `c.body=await c.request.text()\\n`\n\t\t\t},\n\t\t\turlencoded() {\n\t\t\t\treturn `c.body=parseQuery(await c.request.text())\\n`\n\t\t\t},\n\t\t\tarrayBuffer() {\n\t\t\t\treturn `c.body=await c.request.arrayBuffer()\\n`\n\t\t\t},\n\t\t\tformData(isOptional) {\n\t\t\t\tlet fnLiteral = '\\nc.body={}\\n'\n\n\t\t\t\tif (isOptional)\n\t\t\t\t\tfnLiteral += `let form;try{form=await c.request.formData()}catch{}`\n\t\t\t\telse fnLiteral += `const form=await c.request.formData()\\n`\n\n\t\t\t\treturn (\n\t\t\t\t\tfnLiteral +\n\t\t\t\t\t`for(const key of form.keys()){` +\n\t\t\t\t\t`if(c.body[key]) continue\\n` +\n\t\t\t\t\t`const value=form.getAll(key)\\n` +\n\t\t\t\t\t`if(value.length===1)` +\n\t\t\t\t\t`c.body[key]=value[0]\\n` +\n\t\t\t\t\t`else c.body[key]=value` +\n\t\t\t\t\t`}`\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t},\n\tcomposeGeneralHandler: {\n\t\tparameters: 'r',\n\t\tcreateContext(app) {\n\t\t\tlet decoratorsLiteral = ''\n\t\t\tlet fnLiteral = ''\n\n\t\t\t// @ts-expect-error private\n\t\t\tconst defaultHeaders = app.setHeaders\n\n\t\t\tfor (const key of Object.keys(app.decorator))\n\t\t\t\tdecoratorsLiteral += `,'${key}':decorator['${key}']`\n\n\t\t\tconst standardHostname =\n\t\t\t\tapp.config.handler?.standardHostname ?? true\n\t\t\tconst hasTrace = !!app.event.trace?.length\n\n\t\t\tfnLiteral +=\n\t\t\t\t`const u=r.url,` +\n\t\t\t\t`s=u.indexOf('/',${standardHostname ? 11 : 7}),` +\n\t\t\t\t`qi=u.indexOf('?',s+1)\\n` +\n\t\t\t\t`let p\\n` +\n\t\t\t\t`if(qi===-1)p=u.substring(s)\\n` +\n\t\t\t\t`else p=u.substring(s, qi)\\n`\n\n\t\t\tif (hasTrace) fnLiteral += `const id=randomId()\\n`\n\n\t\t\tfnLiteral +=\n\t\t\t\t`const c={request:r,` +\n\t\t\t\t`store,` +\n\t\t\t\t`qi,` +\n\t\t\t\t`path:p,` +\n\t\t\t\t`url:u,` +\n\t\t\t\t`redirect,` +\n\t\t\t\t`error:status,` +\n\t\t\t\t`status,` +\n\t\t\t\t`set:{headers:`\n\n\t\t\tfnLiteral += Object.keys(defaultHeaders ?? {}).length\n\t\t\t\t? 'Object.assign({},app.setHeaders)'\n\t\t\t\t: 'Object.create(null)'\n\n\t\t\tfnLiteral += `,status:200}`\n\n\t\t\t// @ts-expect-error private\n\t\t\tif (app.inference.server)\n\t\t\t\tfnLiteral += `,get server(){return app.getServer()}`\n\t\t\tif (hasTrace) fnLiteral += ',[ELYSIA_REQUEST_ID]:id'\n\t\t\tfnLiteral += decoratorsLiteral\n\t\t\tfnLiteral += `}\\n`\n\n\t\t\treturn fnLiteral\n\t\t},\n\t\terror404(hasEventHook, hasErrorHook) {\n\t\t\tlet findDynamicRoute = `if(route===null)return `\n\n\t\t\tif (hasErrorHook)\n\t\t\t\tfindDynamicRoute += `app.handleError(c,notFound,false,${this.parameters})`\n\t\t\telse\n\t\t\t\tfindDynamicRoute += hasEventHook\n\t\t\t\t\t? `new Response(error404Message,{` +\n\t\t\t\t\t\t`status:c.set.status===200?404:c.set.status,` +\n\t\t\t\t\t\t`headers:c.set.headers` +\n\t\t\t\t\t\t`})`\n\t\t\t\t\t: `error404.clone()`\n\n\t\t\treturn {\n\t\t\t\tdeclare: hasErrorHook\n\t\t\t\t\t? ''\n\t\t\t\t\t: `const error404Message=notFound.message.toString()\\n` +\n\t\t\t\t\t\t`const error404=new Response(error404Message,{status:404})\\n`,\n\t\t\t\tcode: findDynamicRoute\n\t\t\t}\n\t\t}\n\t},\n\tcomposeError: {\n\t\tmapResponseContext: '',\n\t\tvalidationError:\n\t\t\t`return new Response(` +\n\t\t\t`error.message,` +\n\t\t\t`{` +\n\t\t\t`headers:Object.assign(` +\n\t\t\t`{'content-type':'application/json'},` +\n\t\t\t`set.headers` +\n\t\t\t`),` +\n\t\t\t`status:set.status` +\n\t\t\t`}` +\n\t\t\t`)`,\n\t\tunknownError:\n\t\t\t`return new Response(` +\n\t\t\t`error.message,` +\n\t\t\t`{headers:set.headers,status:error.status??set.status??500}` +\n\t\t\t`)`\n\t},\n\tlisten() {\n\t\treturn () => {\n\t\t\tthrow new Error(\n\t\t\t\t'WebStandard does not support listen, you might want to export default Elysia.fetch instead'\n\t\t\t)\n\t\t}\n\t}\n}\n",
    "import type { AnyElysia } from '.'\n\nimport { Value } from '@sinclair/typebox/value'\nimport {\n\tKind,\n\tOptionalKind,\n\tTypeBoxError,\n\ttype TAnySchema,\n\ttype TSchema\n} from '@sinclair/typebox'\n\nimport decode from 'fast-decode-uri-component'\nimport { parseQuery, parseQueryFromURL } from './parse-query'\n\nimport {\n\tELYSIA_REQUEST_ID,\n\tgetLoosePath,\n\tlifeCycleToFn,\n\trandomId,\n\tredirect,\n\tsignCookie,\n\tisNotEmpty,\n\tencodePath,\n\tmergeCookie\n} from './utils'\nimport { isBun } from './universal/utils'\nimport { ParseError, status } from './error'\n\nimport {\n\tNotFoundError,\n\tValidationError,\n\tERROR_CODE,\n\tElysiaCustomStatusResponse\n} from './error'\nimport { ELYSIA_TRACE, type TraceHandler } from './trace'\n\nimport {\n\tcoercePrimitiveRoot,\n\tElysiaTypeCheck,\n\tgetCookieValidator,\n\tgetSchemaValidator,\n\thasType,\n\tisUnion\n} from './schema'\nimport { Sucrose, sucrose } from './sucrose'\nimport { parseCookie, type CookieOptions } from './cookies'\nimport { validateFileExtension } from './type-system/utils'\n\nimport type { TraceEvent } from './trace'\nimport type {\n\tComposedHandler,\n\tElysiaConfig,\n\tHandler,\n\tHookContainer,\n\tLifeCycleStore,\n\tSchemaValidator\n} from './types'\n\nconst allocateIf = (value: string, condition: unknown) =>\n\tcondition ? value : ''\n\nconst defaultParsers = [\n\t'json',\n\t'text',\n\t'urlencoded',\n\t'arrayBuffer',\n\t'formdata',\n\t'application/json',\n\t// eslint-disable-next-line sonarjs/no-duplicate-string\n\t'text/plain',\n\t// eslint-disable-next-line sonarjs/no-duplicate-string\n\t'application/x-www-form-urlencoded',\n\t// eslint-disable-next-line sonarjs/no-duplicate-string\n\t'application/octet-stream',\n\t// eslint-disable-next-line sonarjs/no-duplicate-string\n\t'multipart/form-data'\n]\n\nconst createReport = ({\n\tcontext = 'c',\n\ttrace = [],\n\taddFn\n}: {\n\tcontext?: string\n\ttrace?: (TraceHandler | HookContainer<TraceHandler>)[]\n\taddFn(string: string): void\n}) => {\n\tif (!trace.length)\n\t\treturn () => {\n\t\t\treturn {\n\t\t\t\tresolveChild() {\n\t\t\t\t\treturn () => {}\n\t\t\t\t},\n\t\t\t\tresolve() {}\n\t\t\t}\n\t\t}\n\n\tfor (let i = 0; i < trace.length; i++)\n\t\taddFn(\n\t\t\t`let report${i},reportChild${i},reportErr${i},reportErrChild${i};` +\n\t\t\t\t`let trace${i}=${context}[ELYSIA_TRACE]?.[${i}]??trace[${i}](${context});\\n`\n\t\t)\n\n\treturn (\n\t\tevent: TraceEvent,\n\t\t{\n\t\t\tname,\n\t\t\ttotal = 0\n\t\t}: {\n\t\t\tname?: string\n\t\t\tattribute?: string\n\t\t\ttotal?: number\n\t\t} = {}\n\t) => {\n\t\t// ? For debug specific event\n\t\t// if (event !== 'mapResponse')\n\t\t// \treturn {\n\t\t// \t\tresolveChild() {\n\t\t// \t\t\treturn () => {}\n\t\t// \t\t},\n\t\t// \t\tresolve() {}\n\t\t// \t}\n\n\t\tif (!name) name = 'anonymous'\n\n\t\tconst reporter = event === 'error' ? 'reportErr' : 'report'\n\n\t\tfor (let i = 0; i < trace.length; i++)\n\t\t\taddFn(\n\t\t\t\t`${reporter}${i} = trace${i}.${event}({` +\n\t\t\t\t\t`id,` +\n\t\t\t\t\t`event:'${event}',` +\n\t\t\t\t\t`name:'${name}',` +\n\t\t\t\t\t`begin:performance.now(),` +\n\t\t\t\t\t`total:${total}` +\n\t\t\t\t\t`})\\n`\n\t\t\t)\n\n\t\treturn {\n\t\t\tresolve() {\n\t\t\t\tfor (let i = 0; i < trace.length; i++)\n\t\t\t\t\taddFn(`${reporter}${i}.resolve()\\n`)\n\t\t\t},\n\t\t\tresolveChild(name: string) {\n\t\t\t\tfor (let i = 0; i < trace.length; i++)\n\t\t\t\t\taddFn(\n\t\t\t\t\t\t`${reporter}Child${i}=${reporter}${i}.resolveChild?.shift()?.({` +\n\t\t\t\t\t\t\t`id,` +\n\t\t\t\t\t\t\t`event:'${event}',` +\n\t\t\t\t\t\t\t`name:'${name}',` +\n\t\t\t\t\t\t\t`begin:performance.now()` +\n\t\t\t\t\t\t\t`})\\n`\n\t\t\t\t\t)\n\n\t\t\t\treturn (binding?: string) => {\n\t\t\t\t\tfor (let i = 0; i < trace.length; i++) {\n\t\t\t\t\t\tif (binding)\n\t\t\t\t\t\t\t// Don't report error because HTTP response is expected and not an actual error to look for\n\t\t\t\t\t\t\t// if (${binding} instanceof ElysiaCustomStatusResponse) {\n\t\t\t\t\t\t\t//     ${reporter}Child${i}?.(${binding}.error)\n\t\t\t\t\t\t\t//     ${reporter}Child${i}?.()\\n\n\t\t\t\t\t\t\t// } else\n\t\t\t\t\t\t\taddFn(\n\t\t\t\t\t\t\t\t`if(${binding} instanceof Error){` +\n\t\t\t\t\t\t\t\t\t`${reporter}Child${i}?.(${binding}) ` +\n\t\t\t\t\t\t\t\t\t`}else{` +\n\t\t\t\t\t\t\t\t\t`${reporter}Child${i}?.()` +\n\t\t\t\t\t\t\t\t\t'}'\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\telse addFn(`${reporter}Child${i}?.()\\n`)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst composeCleaner = ({\n\tschema,\n\tname,\n\ttype,\n\ttypeAlias = type,\n\tnormalize,\n\tignoreTryCatch = false\n}: {\n\tschema: ElysiaTypeCheck<any>\n\tname: string\n\ttype: keyof SchemaValidator\n\ttypeAlias?: string\n\tnormalize: ElysiaConfig<''>['normalize']\n\tignoreTryCatch?: boolean\n}) => {\n\tif (!normalize || !schema.Clean || schema.hasAdditionalProperties) return ''\n\n\tif (normalize === true || normalize === 'exactMirror') {\n\t\tif (ignoreTryCatch)\n\t\t\treturn `${name}=validator.${typeAlias}.Clean(${name})\\n`\n\n\t\treturn (\n\t\t\t`try{` +\n\t\t\t`${name}=validator.${typeAlias}.Clean(${name})\\n` +\n\t\t\t`}catch{}`\n\t\t)\n\t}\n\n\tif (normalize === 'typebox')\n\t\treturn `${name}=validator.${typeAlias}.Clean(${name})\\n`\n\n\treturn ''\n}\n\nconst composeValidationFactory = ({\n\tinjectResponse = '',\n\tnormalize = false,\n\tvalidator,\n\tencodeSchema = false,\n\tisStaticResponse = false,\n\thasSanitize = false\n}: {\n\tinjectResponse?: string\n\tnormalize?: ElysiaConfig<''>['normalize']\n\tvalidator: SchemaValidator\n\tencodeSchema?: boolean\n\tisStaticResponse?: boolean\n\thasSanitize?: boolean\n}) => ({\n\tvalidate: (type: string, value = `c.${type}`) =>\n\t\t`c.set.status=422;throw new ValidationError('${type}',validator.${type},${value})`,\n\tresponse: (name = 'r') => {\n\t\tif (isStaticResponse) return ''\n\n\t\tlet code = injectResponse + '\\n'\n\n\t\tcode +=\n\t\t\t`if(${name} instanceof ElysiaCustomStatusResponse){` +\n\t\t\t`c.set.status=${name}.code\\n` +\n\t\t\t`${name}=${name}.response` +\n\t\t\t`}` +\n\t\t\t`switch(c.set.status){`\n\n\t\tfor (const [status, value] of Object.entries(validator.response!)) {\n\t\t\tcode += `\\ncase ${status}:if(${name} instanceof Response)break\\n`\n\n\t\t\tconst noValidate = value.schema?.noValidate === true\n\n\t\t\tconst appliedCleaner = noValidate || hasSanitize\n\n\t\t\tconst clean = ({ ignoreTryCatch = false } = {}) =>\n\t\t\t\tcomposeCleaner({\n\t\t\t\t\tname,\n\t\t\t\t\tschema: value,\n\t\t\t\t\ttype: 'response',\n\t\t\t\t\ttypeAlias: `response[${status}]`,\n\t\t\t\t\tnormalize,\n\t\t\t\t\tignoreTryCatch\n\t\t\t\t})\n\n\t\t\tif (appliedCleaner) code += clean()\n\n\t\t\tconst applyErrorCleaner =\n\t\t\t\t!appliedCleaner && normalize && !noValidate\n\n\t\t\t// Encode call TypeCheck.Check internally\n\t\t\tif (encodeSchema && value.hasTransform)\n\t\t\t\tcode +=\n\t\t\t\t\t`try{` +\n\t\t\t\t\t`${name}=validator.response[${status}].Encode(${name})\\n` +\n\t\t\t\t\t`c.set.status=${status}` +\n\t\t\t\t\t`}catch{` +\n\t\t\t\t\t(applyErrorCleaner\n\t\t\t\t\t\t? `try{\\n` +\n\t\t\t\t\t\t\tclean({ ignoreTryCatch: true }) +\n\t\t\t\t\t\t\t`${name}=validator.response[${status}].Encode(${name})\\n` +\n\t\t\t\t\t\t\t`}catch{` +\n\t\t\t\t\t\t\t`throw new ValidationError('response',validator.response[${status}],${name})` +\n\t\t\t\t\t\t\t`}`\n\t\t\t\t\t\t: `throw new ValidationError('response',validator.response[${status}],${name})`) +\n\t\t\t\t\t`}`\n\t\t\telse {\n\t\t\t\tif (!appliedCleaner) code += clean()\n\n\t\t\t\tif (!noValidate)\n\t\t\t\t\tcode +=\n\t\t\t\t\t\t`if(validator.response[${status}].Check(${name})===false)` +\n\t\t\t\t\t\t`throw new ValidationError('response',validator.response[${status}],${name})\\n` +\n\t\t\t\t\t\t`c.set.status=${status}\\n`\n\t\t\t}\n\n\t\t\tcode += 'break\\n'\n\t\t}\n\n\t\treturn code + '}'\n\t}\n})\n\nconst isAsyncName = (v: Function | HookContainer) => {\n\t// @ts-ignore\n\tconst fn = v?.fn ?? v\n\n\treturn fn.constructor.name === 'AsyncFunction'\n}\n\nconst matchResponseClone = /=>\\s?response\\.clone\\(/\nconst matchFnReturn = /(?:return|=>)\\s?\\S+\\(|a(?:sync|wait)/\n\nexport const isAsync = (v: Function | HookContainer) => {\n\tconst isObject = typeof v === 'object'\n\n\tif (isObject && v.isAsync !== undefined) return v.isAsync\n\n\tconst fn = isObject ? v.fn : v\n\n\tif (fn.constructor.name === 'AsyncFunction') return true\n\n\tconst literal: string = fn.toString()\n\n\tif (matchResponseClone.test(literal)) {\n\t\tif (isObject) v.isAsync = false\n\n\t\treturn false\n\t}\n\n\tconst result = matchFnReturn.test(literal)\n\n\tif (isObject) v.isAsync = result\n\n\treturn result\n}\n\nconst hasReturn = (v: string | HookContainer<any> | Function) => {\n\tconst isObject = typeof v === 'object'\n\n\tif (isObject && v.hasReturn !== undefined) return v.hasReturn\n\n\tconst fnLiteral = isObject\n\t\t? v.fn.toString()\n\t\t: typeof v === 'string'\n\t\t\t? v.toString()\n\t\t\t: v\n\n\tconst parenthesisEnd = fnLiteral.indexOf(')')\n\n\t// Is direct arrow function return eg. () => 1\n\tif (\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 2) === 61 &&\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 5) !== 123\n\t) {\n\t\tif (isObject) v.hasReturn = true\n\n\t\treturn true\n\t}\n\n\tconst result = fnLiteral.includes('return')\n\n\tif (isObject) v.hasReturn = result\n\n\treturn result\n}\n\nconst isGenerator = (v: Function | HookContainer) => {\n\t// @ts-ignore\n\tconst fn = v?.fn ?? v\n\n\treturn (\n\t\tfn.constructor.name === 'AsyncGeneratorFunction' ||\n\t\tfn.constructor.name === 'GeneratorFunction'\n\t)\n}\n\nexport const composeHandler = ({\n\tapp,\n\tpath,\n\tmethod,\n\thooks,\n\tvalidator,\n\thandler,\n\tallowMeta = false,\n\tinference\n}: {\n\tapp: AnyElysia\n\tpath: string\n\tmethod: string\n\thooks: Partial<LifeCycleStore>\n\tvalidator: SchemaValidator\n\thandler: unknown | Handler<any, any>\n\tallowMeta?: boolean\n\tinference: Sucrose.Inference\n}): ComposedHandler => {\n\tconst adapter = app['~adapter'].composeHandler\n\tconst adapterHandler = app['~adapter'].handler\n\tconst isHandleFn = typeof handler === 'function'\n\n\tif (!isHandleFn) {\n\t\thandler = adapterHandler.mapResponse(handler, {\n\t\t\t// @ts-expect-error private property\n\t\t\theaders: app.setHeaders ?? {}\n\t\t})\n\n\t\tif (\n\t\t\thooks.parse?.length &&\n\t\t\thooks.transform?.length &&\n\t\t\thooks.beforeHandle?.length &&\n\t\t\thooks.afterHandle?.length\n\t\t) {\n\t\t\tif (handler instanceof Response)\n\t\t\t\treturn Function(\n\t\t\t\t\t'a',\n\t\t\t\t\t'\"use strict\";\\n' + `return function(){return a.clone()}`\n\t\t\t\t)(handler)\n\n\t\t\treturn Function(\n\t\t\t\t'a',\n\t\t\t\t'\"use strict\";\\n' + 'return function(){return a}'\n\t\t\t)(handler)\n\t\t}\n\t}\n\n\tconst handle = isHandleFn ? `handler(c)` : `handler`\n\tconst hasAfterResponse = !!hooks.afterResponse?.length\n\n\tconst hasTrace = !!hooks.trace?.length\n\tlet fnLiteral = ''\n\n\tinference = sucrose(hooks, inference)\n\tinference = sucrose(\n\t\t{\n\t\t\thandler: handler as any\n\t\t},\n\t\tinference\n\t)\n\n\tif (adapter.declare) {\n\t\tconst literal = adapter.declare(inference)\n\n\t\tif (literal) fnLiteral += literal\n\t}\n\n\tif (inference.server)\n\t\tfnLiteral +=\n\t\t\t\"Object.defineProperty(c,'server',{\" +\n\t\t\t'get:function(){return getServer()}' +\n\t\t\t'})\\n'\n\n\tvalidator.createBody?.()\n\tvalidator.createQuery?.()\n\tvalidator.createHeaders?.()\n\tvalidator.createParams?.()\n\tvalidator.createCookie?.()\n\tvalidator.createResponse?.()\n\n\tconst hasValidation =\n\t\t!!validator.body ||\n\t\t!!validator.headers ||\n\t\t!!validator.params ||\n\t\t!!validator.query ||\n\t\t!!validator.cookie ||\n\t\t!!validator.response\n\n\tconst hasQuery = inference.query || !!validator.query\n\n\tconst requestNoBody =\n\t\thooks.parse?.length === 1 &&\n\t\t// @ts-expect-error\n\t\thooks.parse[0].fn === 'none'\n\n\tconst hasBody =\n\t\tmethod !== '' &&\n\t\tmethod !== 'GET' &&\n\t\tmethod !== 'HEAD' &&\n\t\t(inference.body || !!validator.body || !!hooks.parse?.length) &&\n\t\t!requestNoBody\n\n\t// @ts-expect-error private\n\tconst defaultHeaders = app.setHeaders\n\tconst hasDefaultHeaders =\n\t\tdefaultHeaders && !!Object.keys(defaultHeaders).length\n\n\t// ? defaultHeaders doesn't imply that user will use headers in handler\n\tconst hasHeaders =\n\t\tinference.headers ||\n\t\t!!validator.headers ||\n\t\t(adapter.preferWebstandardHeaders !== true && inference.body)\n\n\tconst hasCookie = inference.cookie || !!validator.cookie\n\n\tconst cookieMeta: {\n\t\tsecrets?: string | string[]\n\t\tsign: string[] | true\n\t\tproperties: { [x: string]: Object }\n\t} = validator.cookie?.config\n\t\t? mergeCookie(validator?.cookie?.config, app.config.cookie as any)\n\t\t: app.config.cookie\n\n\tlet _encodeCookie = ''\n\tconst encodeCookie = () => {\n\t\tif (_encodeCookie) return _encodeCookie\n\n\t\tif (cookieMeta?.sign) {\n\t\t\tif (!cookieMeta.secrets)\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`t.Cookie required secret which is not set in (${method}) ${path}.`\n\t\t\t\t)\n\n\t\t\tconst secret = !cookieMeta.secrets\n\t\t\t\t? undefined\n\t\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t: cookieMeta.secrets[0]\n\n\t\t\t_encodeCookie +=\n\t\t\t\t'const _setCookie = c.set.cookie\\n' + 'if(_setCookie){'\n\n\t\t\tif (cookieMeta.sign === true)\n\t\t\t\t_encodeCookie +=\n\t\t\t\t\t'for(const [key, cookie] of Object.entries(_setCookie)){' +\n\t\t\t\t\t`c.set.cookie[key].value=await signCookie(cookie.value,'${secret}')` +\n\t\t\t\t\t'}'\n\t\t\telse\n\t\t\t\tfor (const name of cookieMeta.sign)\n\t\t\t\t\t_encodeCookie +=\n\t\t\t\t\t\t`if(_setCookie['${name}']?.value)` +\n\t\t\t\t\t\t`c.set.cookie['${name}'].value=await signCookie(_setCookie['${name}'].value,'${secret}')\\n`\n\n\t\t\t_encodeCookie += '}\\n'\n\t\t}\n\n\t\treturn _encodeCookie\n\t}\n\n\tconst normalize = app.config.normalize\n\tconst encodeSchema = app.config.encodeSchema\n\n\tconst validation = composeValidationFactory({\n\t\tnormalize,\n\t\tvalidator,\n\t\tencodeSchema,\n\t\tisStaticResponse: handler instanceof Response,\n\t\thasSanitize: !!app.config.sanitize\n\t})\n\n\tif (hasHeaders) fnLiteral += adapter.headers\n\n\tif (hasTrace) fnLiteral += 'const id=c[ELYSIA_REQUEST_ID]\\n'\n\n\tconst report = createReport({\n\t\ttrace: hooks.trace,\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tfnLiteral += 'try{'\n\n\tif (hasCookie) {\n\t\tconst get = (name: keyof CookieOptions, defaultValue?: unknown) => {\n\t\t\t// @ts-ignore\n\t\t\tconst value = cookieMeta?.[name] ?? defaultValue\n\t\t\tif (!value)\n\t\t\t\treturn typeof defaultValue === 'string'\n\t\t\t\t\t? `${name}:\"${defaultValue}\",`\n\t\t\t\t\t: `${name}:${defaultValue},`\n\n\t\t\tif (typeof value === 'string') return `${name}:'${value}',`\n\t\t\tif (value instanceof Date)\n\t\t\t\treturn `${name}: new Date(${value.getTime()}),`\n\n\t\t\treturn `${name}:${value},`\n\t\t}\n\n\t\tconst options = cookieMeta\n\t\t\t? `{secrets:${\n\t\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t\t? `'${cookieMeta.secrets}'`\n\t\t\t\t\t\t\t: '[' +\n\t\t\t\t\t\t\t\tcookieMeta.secrets.reduce(\n\t\t\t\t\t\t\t\t\t(a, b) => a + `'${b}',`,\n\t\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t\t']'\n\t\t\t\t\t\t: 'undefined'\n\t\t\t\t},` +\n\t\t\t\t`sign:${\n\t\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t\t? true\n\t\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t\t\t? '[' +\n\t\t\t\t\t\t\t\tcookieMeta.sign.reduce(\n\t\t\t\t\t\t\t\t\t(a, b) => a + `'${b}',`,\n\t\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t\t']'\n\t\t\t\t\t\t\t: 'undefined'\n\t\t\t\t},` +\n\t\t\t\tget('domain') +\n\t\t\t\tget('expires') +\n\t\t\t\tget('httpOnly') +\n\t\t\t\tget('maxAge') +\n\t\t\t\tget('path', '/') +\n\t\t\t\tget('priority') +\n\t\t\t\tget('sameSite') +\n\t\t\t\tget('secure') +\n\t\t\t\t'}'\n\t\t\t: 'undefined'\n\n\t\tif (hasHeaders)\n\t\t\tfnLiteral += `\\nc.cookie=await parseCookie(c.set,c.headers.cookie,${options})\\n`\n\t\telse\n\t\t\tfnLiteral += `\\nc.cookie=await parseCookie(c.set,c.request.headers.get('cookie'),${options})\\n`\n\t}\n\n\tif (hasQuery) {\n\t\tconst destructured = <\n\t\t\t{\n\t\t\t\tkey: string\n\t\t\t\tisArray: boolean\n\t\t\t\tisNestedObjectArray: boolean\n\t\t\t\tisObject: boolean\n\t\t\t\tanyOf: boolean\n\t\t\t}[]\n\t\t>[]\n\n\t\tif (validator.query && validator.query.schema.type === 'object') {\n\t\t\tconst properties = validator.query.schema.properties\n\n\t\t\tif (!validator.query.hasAdditionalProperties)\n\t\t\t\tfor (const [key, _value] of Object.entries(properties)) {\n\t\t\t\t\tlet value = _value as TAnySchema\n\n\t\t\t\t\tconst isArray =\n\t\t\t\t\t\tvalue.type === 'array' ||\n\t\t\t\t\t\t!!value.anyOf?.some(\n\t\t\t\t\t\t\t(v: TSchema) =>\n\t\t\t\t\t\t\t\tv.type === 'string' &&\n\t\t\t\t\t\t\t\tv.format === 'ArrayString'\n\t\t\t\t\t\t)\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tif (\n\t\t\t\t\t\tvalue &&\n\t\t\t\t\t\tOptionalKind in value &&\n\t\t\t\t\t\tvalue.type === 'array' &&\n\t\t\t\t\t\tvalue.items\n\t\t\t\t\t)\n\t\t\t\t\t\tvalue = value.items\n\n\t\t\t\t\tconst { type, anyOf } = value\n\n\t\t\t\t\tdestructured.push({\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tisArray,\n\t\t\t\t\t\tisNestedObjectArray:\n\t\t\t\t\t\t\t(isArray && value.items?.type === 'object') ||\n\t\t\t\t\t\t\t!!value.items?.anyOf?.some(\n\t\t\t\t\t\t\t\t(x: TSchema) =>\n\t\t\t\t\t\t\t\t\tx.type === 'object' || x.type === 'array'\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\tisObject:\n\t\t\t\t\t\t\ttype === 'object' ||\n\t\t\t\t\t\t\tanyOf?.some(\n\t\t\t\t\t\t\t\t(v: TSchema) =>\n\t\t\t\t\t\t\t\t\tv.type === 'string' &&\n\t\t\t\t\t\t\t\t\tv.format === 'ArrayString'\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\tanyOf: !!anyOf\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t}\n\n\t\tif (!destructured.length) {\n\t\t\tfnLiteral +=\n\t\t\t\t'if(c.qi===-1){' +\n\t\t\t\t'c.query={}' +\n\t\t\t\t'}else{' +\n\t\t\t\t'c.query=parseQueryFromURL(c.url,c.qi+1)' +\n\t\t\t\t'}'\n\t\t} else {\n\t\t\tfnLiteral += 'if(c.qi!==-1){' + `let url='&'+c.url.slice(c.qi+1)\\n`\n\n\t\t\tlet index = 0\n\t\t\tfor (const {\n\t\t\t\tkey,\n\t\t\t\tisArray,\n\t\t\t\tisObject,\n\t\t\t\tisNestedObjectArray,\n\t\t\t\tanyOf\n\t\t\t} of destructured) {\n\t\t\t\tconst init =\n\t\t\t\t\t(index === 0 ? 'let ' : '') +\n\t\t\t\t\t`memory=url.indexOf('&${key}=')` +\n\t\t\t\t\t`\\nlet a${index}\\n`\n\n\t\t\t\tif (isArray) {\n\t\t\t\t\tfnLiteral += init\n\n\t\t\t\t\tif (isNestedObjectArray)\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`while(memory!==-1){` +\n\t\t\t\t\t\t\t`const start=memory+${key.length + 2}\\n` +\n\t\t\t\t\t\t\t`memory=url.indexOf('&',start)\\n` +\n\t\t\t\t\t\t\t`if(a${index}===undefined)\\n` +\n\t\t\t\t\t\t\t`a${index}=''\\n` +\n\t\t\t\t\t\t\t`else\\n` +\n\t\t\t\t\t\t\t`a${index}+=','\\n` +\n\t\t\t\t\t\t\t`let temp\\n` +\n\t\t\t\t\t\t\t`if(memory===-1)temp=decodeURIComponent(url.slice(start).replace(/\\\\+/g,' '))\\n` +\n\t\t\t\t\t\t\t`else temp=decodeURIComponent(url.slice(start, memory).replace(/\\\\+/g,' '))\\n` +\n\t\t\t\t\t\t\t`const charCode=temp.charCodeAt(0)\\n` +\n\t\t\t\t\t\t\t`if(charCode!==91&&charCode !== 123)\\n` +\n\t\t\t\t\t\t\t`temp='\"'+temp+'\"'\\n` +\n\t\t\t\t\t\t\t`a${index}+=temp\\n` +\n\t\t\t\t\t\t\t`if(memory===-1)break\\n` +\n\t\t\t\t\t\t\t`memory=url.indexOf('&${key}=',memory)\\n` +\n\t\t\t\t\t\t\t`if(memory===-1)break` +\n\t\t\t\t\t\t\t`}` +\n\t\t\t\t\t\t\t`try{` +\n\t\t\t\t\t\t\t`if(a${index}.charCodeAt(0)===91)` +\n\t\t\t\t\t\t\t`a${index} = JSON.parse(a${index})\\n` +\n\t\t\t\t\t\t\t`else\\n` +\n\t\t\t\t\t\t\t`a${index}=JSON.parse('['+a${index}+']')` +\n\t\t\t\t\t\t\t`}catch{}\\n`\n\t\t\t\t\telse\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`while(memory!==-1){` +\n\t\t\t\t\t\t\t`const start=memory+${key.length + 2}\\n` +\n\t\t\t\t\t\t\t`memory=url.indexOf('&',start)\\n` +\n\t\t\t\t\t\t\t`if(a${index}===undefined)` +\n\t\t\t\t\t\t\t`a${index}=[]\\n` +\n\t\t\t\t\t\t\t`if(memory===-1){` +\n\t\t\t\t\t\t\t`const temp=decodeURIComponent(url.slice(start)).replace(/\\\\+/g,' ')\\n` +\n\t\t\t\t\t\t\t`if(temp.includes(',')){a${index}=a${index}.concat(temp.split(','))}` +\n\t\t\t\t\t\t\t`else{a${index}.push(decodeURIComponent(url.slice(start)).replace(/\\\\+/g,' '))}\\n` +\n\t\t\t\t\t\t\t`break` +\n\t\t\t\t\t\t\t`}else{` +\n\t\t\t\t\t\t\t`const temp=decodeURIComponent(url.slice(start, memory)).replace(/\\\\+/g,' ')\\n` +\n\t\t\t\t\t\t\t`if(temp.includes(',')){a${index}=a${index}.concat(temp.split(','))}` +\n\t\t\t\t\t\t\t`else{a${index}.push(temp)}\\n` +\n\t\t\t\t\t\t\t`}` +\n\t\t\t\t\t\t\t`memory=url.indexOf('&${key}=',memory)\\n` +\n\t\t\t\t\t\t\t`if(memory===-1) break\\n` +\n\t\t\t\t\t\t\t`}`\n\t\t\t\t} else if (isObject)\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\tinit +\n\t\t\t\t\t\t`if(memory!==-1){` +\n\t\t\t\t\t\t`const start=memory+${key.length + 2}\\n` +\n\t\t\t\t\t\t`memory=url.indexOf('&',start)\\n` +\n\t\t\t\t\t\t`if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\\\+/g,' '))` +\n\t\t\t\t\t\t`else a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\\\+/g,' '))` +\n\t\t\t\t\t\t`if(a${index}!==undefined)` +\n\t\t\t\t\t\t`try{` +\n\t\t\t\t\t\t`a${index}=JSON.parse(a${index})` +\n\t\t\t\t\t\t`}catch{}` +\n\t\t\t\t\t\t'}'\n\t\t\t\t// Might be union primitive and array\n\t\t\t\telse {\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\tinit +\n\t\t\t\t\t\t`if(memory!==-1){` +\n\t\t\t\t\t\t`const start=memory+${key.length + 2}\\n` +\n\t\t\t\t\t\t`memory=url.indexOf('&',start)\\n` +\n\t\t\t\t\t\t`if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\\\+/g,' '))\\n` +\n\t\t\t\t\t\t`else{` +\n\t\t\t\t\t\t`a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\\\+/g,' '))`\n\n\t\t\t\t\tif (anyOf)\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`\\nlet deepMemory=url.indexOf('&${key}=',memory)\\n` +\n\t\t\t\t\t\t\t`if(deepMemory!==-1){` +\n\t\t\t\t\t\t\t`a${index}=[a${index}]\\n` +\n\t\t\t\t\t\t\t`let first=true\\n` +\n\t\t\t\t\t\t\t`while(true){` +\n\t\t\t\t\t\t\t`const start=deepMemory+${key.length + 2}\\n` +\n\t\t\t\t\t\t\t`if(first)first=false\\n` +\n\t\t\t\t\t\t\t`else deepMemory = url.indexOf('&', start)\\n` +\n\t\t\t\t\t\t\t`let value\\n` +\n\t\t\t\t\t\t\t`if(deepMemory===-1)value=url.slice(start).replace(/\\\\+/g,' ')\\n` +\n\t\t\t\t\t\t\t`else value=url.slice(start, deepMemory).replace(/\\\\+/g,' ')\\n` +\n\t\t\t\t\t\t\t`value=decodeURIComponent(value)\\n` +\n\t\t\t\t\t\t\t`if(value===null){if(deepMemory===-1){break}else{continue}}\\n` +\n\t\t\t\t\t\t\t`const vStart=value.charCodeAt(0)\\n` +\n\t\t\t\t\t\t\t`const vEnd=value.charCodeAt(value.length - 1)\\n` +\n\t\t\t\t\t\t\t`if((vStart===91&&vEnd===93)||(vStart===123&&vEnd===125))\\n` +\n\t\t\t\t\t\t\t`try{` +\n\t\t\t\t\t\t\t`a${index}.push(JSON.parse(value))` +\n\t\t\t\t\t\t\t`}catch{` +\n\t\t\t\t\t\t\t`a${index}.push(value)` +\n\t\t\t\t\t\t\t`}` +\n\t\t\t\t\t\t\t`if(deepMemory===-1)break` +\n\t\t\t\t\t\t\t`}}`\n\n\t\t\t\t\tfnLiteral += '}}'\n\t\t\t\t}\n\n\t\t\t\tindex++\n\t\t\t\tfnLiteral += '\\n'\n\t\t\t}\n\n\t\t\tfnLiteral +=\n\t\t\t\t`c.query={` +\n\t\t\t\tdestructured\n\t\t\t\t\t.map(({ key }, index) => `'${key}':a${index}`)\n\t\t\t\t\t.join(',') +\n\t\t\t\t`}`\n\n\t\t\t// If there are no query parameters, set it to an empty object\n\t\t\tfnLiteral += `} else c.query = {}\\n`\n\t\t}\n\t}\n\n\tconst isAsyncHandler = typeof handler === 'function' && isAsync(handler)\n\n\tconst saveResponse =\n\t\thasTrace || hooks.afterResponse?.length ? 'c.response= ' : ''\n\n\tconst maybeAsync =\n\t\thasCookie ||\n\t\thasBody ||\n\t\tisAsyncHandler ||\n\t\t!!hooks.parse?.length ||\n\t\t!!hooks.afterHandle?.some(isAsync) ||\n\t\t!!hooks.beforeHandle?.some(isAsync) ||\n\t\t!!hooks.transform?.some(isAsync) ||\n\t\t!!hooks.mapResponse?.some(isAsync)\n\n\tconst maybeStream =\n\t\t(typeof handler === 'function' ? isGenerator(handler as any) : false) ||\n\t\t!!hooks.beforeHandle?.some(isGenerator) ||\n\t\t!!hooks.afterHandle?.some(isGenerator) ||\n\t\t!!hooks.transform?.some(isGenerator)\n\n\tconst responseKeys = Object.keys(validator.response ?? {})\n\tconst hasMultipleResponses = responseKeys.length > 1\n\tconst hasSingle200 =\n\t\tresponseKeys.length === 0 ||\n\t\t(responseKeys.length === 1 && responseKeys[0] === '200')\n\n\tconst hasSet =\n\t\tinference.cookie ||\n\t\tinference.set ||\n\t\thasHeaders ||\n\t\thasTrace ||\n\t\thasMultipleResponses ||\n\t\t!hasSingle200 ||\n\t\t(isHandleFn && hasDefaultHeaders) ||\n\t\tmaybeStream\n\n\tconst mapResponse = (r = 'r') =>\n\t\t`return ${hasSet ? 'mapResponse' : 'mapCompactResponse'}(${saveResponse}${r}${hasSet ? ',c.set' : ''}${mapResponseContext})\\n`\n\n\tconst mapResponseContext =\n\t\tmaybeStream || adapter.mapResponseContext\n\t\t\t? `,${adapter.mapResponseContext}`\n\t\t\t: ''\n\n\tif (hasTrace || inference.route) fnLiteral += `c.route=\\`${path}\\`\\n`\n\n\tconst parseReporter = report('parse', {\n\t\ttotal: hooks.parse?.length\n\t})\n\n\tif (hasBody) {\n\t\tconst hasBodyInference =\n\t\t\t!!hooks.parse?.length || inference.body || validator.body\n\n\t\tif (adapter.parser.declare) fnLiteral += adapter.parser.declare\n\n\t\tfnLiteral += '\\ntry{'\n\n\t\tlet parser: string | undefined =\n\t\t\ttypeof hooks.parse === 'string'\n\t\t\t\t? hooks.parse\n\t\t\t\t: Array.isArray(hooks.parse) && hooks.parse.length === 1\n\t\t\t\t\t? typeof hooks.parse[0] === 'string'\n\t\t\t\t\t\t? hooks.parse[0]\n\t\t\t\t\t\t: typeof hooks.parse[0].fn === 'string'\n\t\t\t\t\t\t\t? hooks.parse[0].fn\n\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t: undefined\n\n\t\tif (!parser && validator.body && !hooks.parse?.length) {\n\t\t\tconst schema = validator.body.schema\n\t\t\tif (\n\t\t\t\tschema &&\n\t\t\t\tschema.anyOf &&\n\t\t\t\tschema[Kind] === 'Union' &&\n\t\t\t\tschema.anyOf?.length === 2 &&\n\t\t\t\tschema.anyOf?.find((x: TAnySchema) => x[Kind] === 'ElysiaForm')\n\t\t\t)\n\t\t\t\tparser = 'formdata'\n\t\t}\n\n\t\tif (parser && defaultParsers.includes(parser)) {\n\t\t\tconst reporter = report('parse', {\n\t\t\t\ttotal: hooks.parse?.length\n\t\t\t})\n\n\t\t\tconst isOptionalBody = !!validator.body?.isOptional\n\n\t\t\tswitch (parser) {\n\t\t\t\tcase 'json':\n\t\t\t\tcase 'application/json':\n\t\t\t\t\tfnLiteral += adapter.parser.json(isOptionalBody)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'text':\n\t\t\t\tcase 'text/plain':\n\t\t\t\t\tfnLiteral += adapter.parser.text(isOptionalBody)\n\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'urlencoded':\n\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\tfnLiteral += adapter.parser.urlencoded(isOptionalBody)\n\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'arrayBuffer':\n\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\tfnLiteral += adapter.parser.arrayBuffer(isOptionalBody)\n\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'formdata':\n\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\tfnLiteral += adapter.parser.formData(isOptionalBody)\n\t\t\t\t\tbreak\n\n\t\t\t\tdefault:\n\t\t\t\t\tif ((parser[0] as string) in app['~parser']) {\n\t\t\t\t\t\tfnLiteral += hasHeaders\n\t\t\t\t\t\t\t? `let contentType = c.headers['content-type']`\n\t\t\t\t\t\t\t: `let contentType = c.request.headers.get('content-type')`\n\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`\\nif(contentType){` +\n\t\t\t\t\t\t\t`const index=contentType.indexOf(';')\\n` +\n\t\t\t\t\t\t\t`if(index!==-1)contentType=contentType.substring(0,index)}\\n` +\n\t\t\t\t\t\t\t`else{contentType=''}` +\n\t\t\t\t\t\t\t`c.contentType=contentType\\n` +\n\t\t\t\t\t\t\t`let result=parser['${parser}'](c, contentType)\\n` +\n\t\t\t\t\t\t\t`if(result instanceof Promise)result=await result\\n` +\n\t\t\t\t\t\t\t`if(result instanceof ElysiaCustomStatusResponse)throw result\\n` +\n\t\t\t\t\t\t\t`if(result!==undefined)c.body=result\\n` +\n\t\t\t\t\t\t\t'delete c.contentType\\n'\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\treporter.resolve()\n\t\t} else if (hasBodyInference) {\n\t\t\tfnLiteral += '\\n'\n\n\t\t\tconst declaration = hooks.parse?.length ? 'let' : 'const'\n\t\t\tfnLiteral += hasHeaders\n\t\t\t\t? `${declaration} contentType=c.headers['content-type']\\n`\n\t\t\t\t: `${declaration} contentType=c.request.headers.get('content-type')\\n`\n\n\t\t\tlet hasDefaultParser = false\n\t\t\tif (hooks.parse?.length)\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`if(contentType){\\n` +\n\t\t\t\t\t`const index=contentType.indexOf(';')\\n` +\n\t\t\t\t\t`\\nif(index!==-1)contentType=contentType.substring(0,index)` +\n\t\t\t\t\t`}else{contentType=''}` +\n\t\t\t\t\t`let used=false\\n` +\n\t\t\t\t\t`c.contentType=contentType\\n`\n\t\t\telse {\n\t\t\t\thasDefaultParser = true\n\t\t\t\tconst isOptionalBody = !!validator.body?.isOptional\n\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`if(contentType)` +\n\t\t\t\t\t`switch(contentType.charCodeAt(12)){` +\n\t\t\t\t\t`\\ncase 106:` +\n\t\t\t\t\tadapter.parser.json(isOptionalBody) +\n\t\t\t\t\t'break' +\n\t\t\t\t\t`\\n` +\n\t\t\t\t\t`case 120:` +\n\t\t\t\t\tadapter.parser.urlencoded(isOptionalBody) +\n\t\t\t\t\t`break` +\n\t\t\t\t\t`\\n` +\n\t\t\t\t\t`case 111:` +\n\t\t\t\t\tadapter.parser.arrayBuffer(isOptionalBody) +\n\t\t\t\t\t`break` +\n\t\t\t\t\t`\\n` +\n\t\t\t\t\t`case 114:` +\n\t\t\t\t\tadapter.parser.formData(isOptionalBody) +\n\t\t\t\t\t`break` +\n\t\t\t\t\t`\\n` +\n\t\t\t\t\t`default:` +\n\t\t\t\t\t`if(contentType.charCodeAt(0)===116){` +\n\t\t\t\t\tadapter.parser.text(isOptionalBody) +\n\t\t\t\t\t`}` +\n\t\t\t\t\t`break\\n` +\n\t\t\t\t\t`}`\n\t\t\t}\n\n\t\t\tconst reporter = report('parse', {\n\t\t\t\ttotal: hooks.parse?.length\n\t\t\t})\n\n\t\t\tif (hooks.parse)\n\t\t\t\tfor (let i = 0; i < hooks.parse.length; i++) {\n\t\t\t\t\tconst name = `bo${i}`\n\t\t\t\t\tif (i !== 0) fnLiteral += `\\nif(!used){`\n\n\t\t\t\t\tif (typeof hooks.parse[i].fn === 'string') {\n\t\t\t\t\t\tconst endUnit = reporter.resolveChild(\n\t\t\t\t\t\t\thooks.parse[i].fn as unknown as string\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tconst isOptionalBody = !!validator.body?.isOptional\n\n\t\t\t\t\t\tswitch (hooks.parse[i].fn as unknown as string) {\n\t\t\t\t\t\t\tcase 'json':\n\t\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\t\thasDefaultParser = true\n\t\t\t\t\t\t\t\tfnLiteral += adapter.parser.json(isOptionalBody)\n\n\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\tcase 'text':\n\t\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\t\thasDefaultParser = true\n\t\t\t\t\t\t\t\tfnLiteral += adapter.parser.text(isOptionalBody)\n\n\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\tcase 'urlencoded':\n\t\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\t\thasDefaultParser = true\n\t\t\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t\t\tadapter.parser.urlencoded(isOptionalBody)\n\n\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\t\thasDefaultParser = true\n\t\t\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t\t\tadapter.parser.arrayBuffer(isOptionalBody)\n\n\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\tcase 'formdata':\n\t\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\t\thasDefaultParser = true\n\t\t\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t\t\tadapter.parser.formData(isOptionalBody)\n\n\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t\t\t`let ${name}=parser['${hooks.parse[i].fn}'](c,contentType)\\n` +\n\t\t\t\t\t\t\t\t\t`if(${name} instanceof Promise)${name}=await ${name}\\n` +\n\t\t\t\t\t\t\t\t\t`if(${name}!==undefined){c.body=${name};used=true;}\\n`\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tendUnit()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst endUnit = reporter.resolveChild(\n\t\t\t\t\t\t\thooks.parse[i].fn.name\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`let ${name}=e.parse[${i}]\\n` +\n\t\t\t\t\t\t\t`${name}=${name}(c,contentType)\\n` +\n\t\t\t\t\t\t\t`if(${name} instanceof Promise)${name}=await ${name}\\n` +\n\t\t\t\t\t\t\t`if(${name}!==undefined){c.body=${name};used=true}`\n\n\t\t\t\t\t\tendUnit()\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i !== 0) fnLiteral += `}`\n\n\t\t\t\t\tif (hasDefaultParser) break\n\t\t\t\t}\n\n\t\t\treporter.resolve()\n\n\t\t\tif (!hasDefaultParser) {\n\t\t\t\tconst isOptionalBody = !!validator.body?.isOptional\n\n\t\t\t\tif (hooks.parse?.length)\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`\\nif(!used){\\n` +\n\t\t\t\t\t\t`if(!contentType) throw new ParseError()\\n`\n\n\t\t\t\tfnLiteral += `switch(contentType){`\n\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`case 'application/json':\\n` +\n\t\t\t\t\tadapter.parser.json(isOptionalBody) +\n\t\t\t\t\t`break\\n` +\n\t\t\t\t\t`case 'text/plain':` +\n\t\t\t\t\tadapter.parser.text(isOptionalBody) +\n\t\t\t\t\t`break` +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t`case 'application/x-www-form-urlencoded':` +\n\t\t\t\t\tadapter.parser.urlencoded(isOptionalBody) +\n\t\t\t\t\t`break` +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t`case 'application/octet-stream':` +\n\t\t\t\t\tadapter.parser.arrayBuffer(isOptionalBody) +\n\t\t\t\t\t`break` +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t`case 'multipart/form-data':` +\n\t\t\t\t\tadapter.parser.formData(isOptionalBody) +\n\t\t\t\t\t`break` +\n\t\t\t\t\t'\\n'\n\n\t\t\t\tfor (const key of Object.keys(app['~parser']))\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`case '${key}':` +\n\t\t\t\t\t\t`let bo${key}=parser['${key}'](c,contentType)\\n` +\n\t\t\t\t\t\t`if(bo${key} instanceof Promise)bo${key}=await bo${key}\\n` +\n\t\t\t\t\t\t`if(bo${key} instanceof ElysiaCustomStatusResponse)throw result\\n` +\n\t\t\t\t\t\t`if(bo${key}!==undefined)c.body=bo${key}\\n` +\n\t\t\t\t\t\t`break` +\n\t\t\t\t\t\t'\\n'\n\n\t\t\t\tif (hooks.parse?.length) fnLiteral += '}'\n\n\t\t\t\tfnLiteral += '}'\n\t\t\t}\n\n\t\t\tif (hooks.parse?.length) fnLiteral += '\\ndelete c.contentType'\n\t\t}\n\n\t\tfnLiteral += '}catch(error){throw new ParseError(error)}'\n\t}\n\n\tparseReporter.resolve()\n\n\tif (hooks?.transform) {\n\t\tconst reporter = report('transform', {\n\t\t\ttotal: hooks.transform.length\n\t\t})\n\n\t\tif (hooks.transform.length) fnLiteral += 'let transformed\\n'\n\n\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\tconst transform = hooks.transform[i]\n\n\t\t\tconst endUnit = reporter.resolveChild(transform.fn.name)\n\n\t\t\tfnLiteral += isAsync(transform)\n\t\t\t\t? `transformed=await e.transform[${i}](c)\\n`\n\t\t\t\t: `transformed=e.transform[${i}](c)\\n`\n\n\t\t\tif (transform.subType === 'mapDerive')\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`if(transformed instanceof ElysiaCustomStatusResponse)throw transformed\\n` +\n\t\t\t\t\t`else{` +\n\t\t\t\t\t`transformed.request=c.request\\n` +\n\t\t\t\t\t`transformed.store=c.store\\n` +\n\t\t\t\t\t`transformed.qi=c.qi\\n` +\n\t\t\t\t\t`transformed.path=c.path\\n` +\n\t\t\t\t\t`transformed.url=c.url\\n` +\n\t\t\t\t\t`transformed.redirect=c.redirect\\n` +\n\t\t\t\t\t`transformed.set=c.set\\n` +\n\t\t\t\t\t`transformed.error=c.error\\n` +\n\t\t\t\t\t`c=transformed` +\n\t\t\t\t\t'}'\n\t\t\telse\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`if(transformed instanceof ElysiaCustomStatusResponse)throw transformed\\n` +\n\t\t\t\t\t`else Object.assign(c,transformed)\\n`\n\n\t\t\tendUnit()\n\t\t}\n\n\t\treporter.resolve()\n\t}\n\n\tconst fileUnions = <ElysiaTypeCheck<any>[]>[]\n\n\tif (validator) {\n\t\tif (validator.headers) {\n\t\t\tif (validator.headers.hasDefault)\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.headers.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: typeof value === 'string'\n\t\t\t\t\t\t\t\t? `'${value}'`\n\t\t\t\t\t\t\t\t: value\n\n\t\t\t\t\tif (parsed !== undefined)\n\t\t\t\t\t\tfnLiteral += `c.headers['${key}']??=${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += composeCleaner({\n\t\t\t\tname: 'c.headers',\n\t\t\t\tschema: validator.headers,\n\t\t\t\ttype: 'headers',\n\t\t\t\tnormalize\n\t\t\t})\n\n\t\t\tif (validator.headers.isOptional)\n\t\t\t\tfnLiteral += `if(isNotEmpty(c.headers)){`\n\n\t\t\tif (validator.body?.schema?.noValidate !== true)\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`if(validator.headers.Check(c.headers) === false){` +\n\t\t\t\t\tvalidation.validate('headers') +\n\t\t\t\t\t'}'\n\n\t\t\tif (validator.headers.hasTransform)\n\t\t\t\tfnLiteral += `c.headers=validator.headers.Decode(c.headers)\\n`\n\n\t\t\tif (validator.headers.isOptional) fnLiteral += '}'\n\t\t}\n\n\t\tif (validator.params) {\n\t\t\tif (validator.params.hasDefault)\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.params.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: typeof value === 'string'\n\t\t\t\t\t\t\t\t? `'${value}'`\n\t\t\t\t\t\t\t\t: value\n\n\t\t\t\t\tif (parsed !== undefined)\n\t\t\t\t\t\tfnLiteral += `c.params['${key}']??=${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tif (validator.params?.schema?.noValidate !== true)\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`if(validator.params.Check(c.params)===false){` +\n\t\t\t\t\tvalidation.validate('params') +\n\t\t\t\t\t'}'\n\n\t\t\tif (validator.params.hasTransform)\n\t\t\t\tfnLiteral += `c.params=validator.params.Decode(c.params)\\n`\n\t\t}\n\n\t\tif (validator.query) {\n\t\t\tif (validator.query.hasDefault)\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.query.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: typeof value === 'string'\n\t\t\t\t\t\t\t\t? `'${value}'`\n\t\t\t\t\t\t\t\t: value\n\n\t\t\t\t\tif (parsed !== undefined)\n\t\t\t\t\t\tfnLiteral += `if(c.query['${key}']===undefined)c.query['${key}']=${parsed}\\n`\n\n\t\t\t\t\tfnLiteral += composeCleaner({\n\t\t\t\t\t\tname: 'c.query',\n\t\t\t\t\t\tschema: validator.query,\n\t\t\t\t\t\ttype: 'query',\n\t\t\t\t\t\tnormalize\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\tif (validator.query.isOptional)\n\t\t\t\tfnLiteral += `if(isNotEmpty(c.query)){`\n\n\t\t\tif (validator.query?.schema?.noValidate !== true)\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`if(validator.query.Check(c.query)===false){` +\n\t\t\t\t\tvalidation.validate('query') +\n\t\t\t\t\t`}`\n\n\t\t\tif (validator.query.hasTransform)\n\t\t\t\tfnLiteral += `c.query=validator.query.Decode(Object.assign({},c.query))\\n`\n\n\t\t\tif (validator.query.isOptional) fnLiteral += `}`\n\t\t}\n\n\t\tif (hasBody && validator.body) {\n\t\t\tif (validator.body.hasTransform || validator.body.isOptional)\n\t\t\t\tfnLiteral += `const isNotEmptyObject=c.body&&(typeof c.body===\"object\"&&isNotEmpty(c.body))\\n`\n\n\t\t\tconst hasUnion = isUnion(validator.body.schema)\n\t\t\tlet hasNonUnionFileWithDefault = false\n\n\t\t\tif (validator.body.hasDefault) {\n\t\t\t\tlet value = Value.Default(\n\t\t\t\t\tvalidator.body.schema,\n\t\t\t\t\tvalidator.body.schema.type === 'object' ||\n\t\t\t\t\t\t(validator.body.schema[Kind] === 'Import' &&\n\t\t\t\t\t\t\tvalidator.body.schema.$defs[\n\t\t\t\t\t\t\t\tvalidator.body.schema.$ref\n\t\t\t\t\t\t\t][Kind] === 'Object')\n\t\t\t\t\t\t? {}\n\t\t\t\t\t\t: undefined\n\t\t\t\t)\n\n\t\t\t\tif (\n\t\t\t\t\t!hasUnion &&\n\t\t\t\t\tvalue &&\n\t\t\t\t\ttypeof value === 'object' &&\n\t\t\t\t\t(hasType('File', validator.body.schema) ||\n\t\t\t\t\t\thasType('Files', validator.body.schema))\n\t\t\t\t) {\n\t\t\t\t\thasNonUnionFileWithDefault = true\n\n\t\t\t\t\tfor (const [k, v] of Object.entries(value))\n\t\t\t\t\t\tif (v === 'File' || v === 'Files')\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tdelete value[k]\n\n\t\t\t\t\tif (!isNotEmpty(value)) value = undefined\n\t\t\t\t}\n\n\t\t\t\tconst parsed =\n\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t: typeof value === 'string'\n\t\t\t\t\t\t\t? `'${value}'`\n\t\t\t\t\t\t\t: value\n\n\t\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\t\tif (Array.isArray(value))\n\t\t\t\t\t\tfnLiteral += `if(!c.body)c.body=${parsed}\\n`\n\t\t\t\t\telse if (typeof value === 'object')\n\t\t\t\t\t\tfnLiteral += `c.body=Object.assign(${parsed},c.body)\\n`\n\t\t\t\t\telse fnLiteral += `c.body=${parsed}\\n`\n\t\t\t\t}\n\n\t\t\t\tfnLiteral += composeCleaner({\n\t\t\t\t\tname: 'c.body',\n\t\t\t\t\tschema: validator.body,\n\t\t\t\t\ttype: 'body',\n\t\t\t\t\tnormalize\n\t\t\t\t})\n\n\t\t\t\tif (validator.body?.schema?.noValidate !== true) {\n\t\t\t\t\tif (validator.body.isOptional)\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`if(isNotEmptyObject&&validator.body.Check(c.body)===false){` +\n\t\t\t\t\t\t\tvalidation.validate('body') +\n\t\t\t\t\t\t\t'}'\n\t\t\t\t\telse\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`if(validator.body.Check(c.body)===false){` +\n\t\t\t\t\t\t\tvalidation.validate('body') +\n\t\t\t\t\t\t\t`}`\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfnLiteral += composeCleaner({\n\t\t\t\t\tname: 'c.body',\n\t\t\t\t\tschema: validator.body,\n\t\t\t\t\ttype: 'body',\n\t\t\t\t\tnormalize\n\t\t\t\t})\n\n\t\t\t\tif (validator.body?.schema?.noValidate !== true) {\n\t\t\t\t\tif (validator.body.isOptional)\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`if(isNotEmptyObject&&validator.body.Check(c.body)===false){` +\n\t\t\t\t\t\t\tvalidation.validate('body') +\n\t\t\t\t\t\t\t'}'\n\t\t\t\t\telse\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`if(validator.body.Check(c.body)===false){` +\n\t\t\t\t\t\t\tvalidation.validate('body') +\n\t\t\t\t\t\t\t'}'\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (validator.body.hasTransform)\n\t\t\t\tfnLiteral += `if(isNotEmptyObject)c.body=validator.body.Decode(c.body)\\n`\n\n\t\t\tif (hasUnion && validator.body.schema.anyOf?.length) {\n\t\t\t\tconst iterator = Object.values(\n\t\t\t\t\tvalidator.body.schema.anyOf\n\t\t\t\t) as TAnySchema[]\n\n\t\t\t\tfor (let i = 0; i < iterator.length; i++) {\n\t\t\t\t\tconst type = iterator[i]\n\n\t\t\t\t\tif (hasType('File', type) || hasType('Files', type)) {\n\t\t\t\t\t\tconst candidate = getSchemaValidator(type, {\n\t\t\t\t\t\t\t// @ts-expect-error private property\n\t\t\t\t\t\t\tmodules: app.definitions.typebox,\n\t\t\t\t\t\t\tdynamic: !app.config.aot,\n\t\t\t\t\t\t\t// @ts-expect-error private property\n\t\t\t\t\t\t\tmodels: app.definitions.type,\n\t\t\t\t\t\t\tnormalize: app.config.normalize,\n\t\t\t\t\t\t\tadditionalCoerce: coercePrimitiveRoot(),\n\t\t\t\t\t\t\tsanitize: () => app.config.sanitize\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tif (candidate) {\n\t\t\t\t\t\t\tconst isFirst = fileUnions.length === 0\n\n\t\t\t\t\t\t\tconst iterator = Object.entries(\n\t\t\t\t\t\t\t\ttype.properties\n\t\t\t\t\t\t\t) as [string, TSchema][]\n\n\t\t\t\t\t\t\tlet validator = isFirst ? '\\n' : ' else '\n\t\t\t\t\t\t\tvalidator += `if(fileUnions[${fileUnions.length}].Check(c.body)){`\n\n\t\t\t\t\t\t\tlet validateFile = ''\n\t\t\t\t\t\t\tlet validatorLength = 0\n\t\t\t\t\t\t\tfor (let i = 0; i < iterator.length; i++) {\n\t\t\t\t\t\t\t\tconst [k, v] = iterator[i]\n\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t!v.extension ||\n\t\t\t\t\t\t\t\t\t(v[Kind] !== 'File' && v[Kind] !== 'Files')\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\t\tif (validatorLength) validateFile += ','\n\t\t\t\t\t\t\t\tvalidateFile += `validateFileExtension(c.body.${k},${JSON.stringify(v.extension)},'body.${k}')`\n\n\t\t\t\t\t\t\t\tvalidatorLength++\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (validateFile) {\n\t\t\t\t\t\t\t\tif (validatorLength === 1)\n\t\t\t\t\t\t\t\t\tvalidator += `await ${validateFile}\\n`\n\t\t\t\t\t\t\t\telse if (validatorLength > 1)\n\t\t\t\t\t\t\t\t\tvalidator += `await Promise.all([${validateFile}])\\n`\n\n\t\t\t\t\t\t\t\tvalidator += '}'\n\n\t\t\t\t\t\t\t\tfnLiteral += validator\n\t\t\t\t\t\t\t\tfileUnions.push(candidate)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\thasNonUnionFileWithDefault ||\n\t\t\t\t(!hasUnion &&\n\t\t\t\t\t(hasType('File', validator.body.schema) ||\n\t\t\t\t\t\thasType('Files', validator.body.schema)))\n\t\t\t) {\n\t\t\t\tlet validateFile = ''\n\n\t\t\t\tlet i = 0\n\t\t\t\tfor (const [k, v] of Object.entries(\n\t\t\t\t\tvalidator.body.schema.properties\n\t\t\t\t) as [string, TSchema][]) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!v.extension ||\n\t\t\t\t\t\t(v[Kind] !== 'File' && v[Kind] !== 'Files')\n\t\t\t\t\t)\n\t\t\t\t\t\tcontinue\n\n\t\t\t\t\tif (i) validateFile += ','\n\t\t\t\t\tvalidateFile += `validateFileExtension(c.body.${k},${JSON.stringify(v.extension)},'body.${k}')`\n\n\t\t\t\t\ti++\n\t\t\t\t}\n\n\t\t\t\tif (i) fnLiteral += '\\n'\n\n\t\t\t\tif (i === 1) fnLiteral += `await ${validateFile}\\n`\n\t\t\t\telse if (i > 1)\n\t\t\t\t\tfnLiteral += `await Promise.all([${validateFile}])\\n`\n\t\t\t}\n\t\t}\n\n\t\tif (validator.cookie) {\n\t\t\t// ! Get latest app.config.cookie\n\t\t\tconst cookieValidator = getCookieValidator({\n\t\t\t\t// @ts-expect-error private property\n\t\t\t\tmodules: app.definitions.typebox,\n\t\t\t\tvalidator: validator.cookie as any,\n\t\t\t\tdefaultConfig: app.config.cookie,\n\t\t\t\tdynamic: !!app.config.aot,\n\t\t\t\tconfig: validator.cookie?.config ?? {},\n\t\t\t\t// @ts-expect-error\n\t\t\t\tmodels: app.definitions.type\n\t\t\t})!\n\n\t\t\tfnLiteral +=\n\t\t\t\t`const cookieValue={}\\n` +\n\t\t\t\t`for(const [key,value] of Object.entries(c.cookie))` +\n\t\t\t\t`cookieValue[key]=value.value\\n`\n\n\t\t\tif (cookieValidator.hasDefault)\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(cookieValidator.schema, {}) as Object\n\t\t\t\t)) {\n\t\t\t\t\tfnLiteral += `cookieValue['${key}'] = ${\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: value\n\t\t\t\t\t}\\n`\n\t\t\t\t}\n\n\t\t\tif (cookieValidator.isOptional)\n\t\t\t\tfnLiteral += `if(isNotEmpty(c.cookie)){`\n\n\t\t\tif (validator.body?.schema?.noValidate !== true) {\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`if(validator.cookie.Check(cookieValue)===false){` +\n\t\t\t\t\tvalidation.validate('cookie', 'cookieValue') +\n\t\t\t\t\t'}'\n\t\t\t}\n\n\t\t\tif (cookieValidator.hasTransform)\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`for(const [key,value] of Object.entries(validator.cookie.Decode(cookieValue)))` +\n\t\t\t\t\t`c.cookie[key].value=value\\n`\n\n\t\t\tif (cookieValidator.isOptional) fnLiteral += `}`\n\t\t}\n\t}\n\n\tif (hooks?.beforeHandle) {\n\t\tconst reporter = report('beforeHandle', {\n\t\t\ttotal: hooks.beforeHandle.length\n\t\t})\n\n\t\tlet hasResolve = false\n\n\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\tconst beforeHandle = hooks.beforeHandle[i]\n\n\t\t\tconst endUnit = reporter.resolveChild(beforeHandle.fn.name)\n\n\t\t\tconst returning = hasReturn(beforeHandle)\n\t\t\tconst isResolver =\n\t\t\t\tbeforeHandle.subType === 'resolve' ||\n\t\t\t\tbeforeHandle.subType === 'mapResolve'\n\n\t\t\tif (isResolver) {\n\t\t\t\tif (!hasResolve) {\n\t\t\t\t\thasResolve = true\n\t\t\t\t\tfnLiteral += '\\nlet resolved\\n'\n\t\t\t\t}\n\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `resolved=await e.beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `resolved=e.beforeHandle[${i}](c);\\n`\n\n\t\t\t\tif (beforeHandle.subType === 'mapResolve')\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`if(resolved instanceof ElysiaCustomStatusResponse)` +\n\t\t\t\t\t\t`throw resolved\\n` +\n\t\t\t\t\t\t`else{` +\n\t\t\t\t\t\t`resolved.request=c.request\\n` +\n\t\t\t\t\t\t`resolved.store=c.store\\n` +\n\t\t\t\t\t\t`resolved.qi=c.qi\\n` +\n\t\t\t\t\t\t`resolved.path=c.path\\n` +\n\t\t\t\t\t\t`resolved.url=c.url\\n` +\n\t\t\t\t\t\t`resolved.redirect=c.redirect\\n` +\n\t\t\t\t\t\t`resolved.set=c.set\\n` +\n\t\t\t\t\t\t`resolved.error=c.error\\n` +\n\t\t\t\t\t\t`c=resolved` +\n\t\t\t\t\t\t`}`\n\t\t\t\telse\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`if(resolved instanceof ElysiaCustomStatusResponse)throw resolved\\n` +\n\t\t\t\t\t\t`else Object.assign(c, resolved)\\n`\n\t\t\t} else if (!returning) {\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `await e.beforeHandle[${i}](c)\\n`\n\t\t\t\t\t: `e.beforeHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `be=await e.beforeHandle[${i}](c)\\n`\n\t\t\t\t\t: `be=e.beforeHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit('be')\n\n\t\t\t\tfnLiteral += `if(be!==undefined){`\n\t\t\t\treporter.resolve()\n\n\t\t\t\tif (hooks.afterHandle?.length) {\n\t\t\t\t\treport('handle', {\n\t\t\t\t\t\tname: isHandleFn\n\t\t\t\t\t\t\t? (handler as Function).name\n\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t}).resolve()\n\n\t\t\t\t\tconst reporter = report('afterHandle', {\n\t\t\t\t\t\ttotal: hooks.afterHandle.length\n\t\t\t\t\t})\n\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tconst hook = hooks.afterHandle[i]\n\t\t\t\t\t\tconst returning = hasReturn(hook)\n\t\t\t\t\t\tconst endUnit = reporter.resolveChild(hook.fn.name)\n\n\t\t\t\t\t\tfnLiteral += `c.response = be\\n`\n\n\t\t\t\t\t\tif (!returning) {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t\t\t\t? `await e.afterHandle[${i}](c, be)\\n`\n\t\t\t\t\t\t\t\t: `e.afterHandle[${i}](c, be)\\n`\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t\t\t\t? `af=await e.afterHandle[${i}](c)\\n`\n\t\t\t\t\t\t\t\t: `af=e.afterHandle[${i}](c)\\n`\n\n\t\t\t\t\t\t\tfnLiteral += `if(af!==undefined) c.response=be=af\\n`\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tendUnit('af')\n\t\t\t\t\t}\n\t\t\t\t\treporter.resolve()\n\t\t\t\t}\n\n\t\t\t\tif (validator.response) fnLiteral += validation.response('be')\n\n\t\t\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\t\t\ttotal: hooks.mapResponse?.length\n\t\t\t\t})\n\n\t\t\t\tif (hooks.mapResponse?.length) {\n\t\t\t\t\tfnLiteral += `c.response=be\\n`\n\n\t\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`if(mr===undefined){` +\n\t\t\t\t\t\t\t`mr=${isAsyncName(mapResponse) ? 'await ' : ''}e.mapResponse[${i}](c)\\n` +\n\t\t\t\t\t\t\t`if(mr!==undefined)be=c.response=mr` +\n\t\t\t\t\t\t\t'}'\n\n\t\t\t\t\t\tendUnit()\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmapResponseReporter.resolve()\n\n\t\t\t\tfnLiteral += encodeCookie()\n\t\t\t\tfnLiteral += `return mapEarlyResponse(${saveResponse}be,c.set${\n\t\t\t\t\tmapResponseContext\n\t\t\t\t})}\\n`\n\t\t\t}\n\t\t}\n\n\t\treporter.resolve()\n\t}\n\n\tif (hooks.afterHandle?.length) {\n\t\tconst handleReporter = report('handle', {\n\t\t\tname: isHandleFn ? (handler as Function).name : undefined\n\t\t})\n\n\t\tif (hooks.afterHandle.length)\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r=c.response=await ${handle}\\n`\n\t\t\t\t: `let r=c.response=${handle}\\n`\n\t\telse\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r=await ${handle}\\n`\n\t\t\t\t: `let r=${handle}\\n`\n\n\t\thandleReporter.resolve()\n\n\t\tconst reporter = report('afterHandle', {\n\t\t\ttotal: hooks.afterHandle.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\tconst hook = hooks.afterHandle[i]\n\t\t\tconst returning = hasReturn(hook)\n\t\t\tconst endUnit = reporter.resolveChild(hook.fn.name)\n\n\t\t\tif (!returning) {\n\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t? `await e.afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `e.afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t? `af=await e.afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `af=e.afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit('af')\n\n\t\t\t\tif (validator.response) {\n\t\t\t\t\tfnLiteral += `if(af!==undefined){`\n\t\t\t\t\treporter.resolve()\n\n\t\t\t\t\tfnLiteral += validation.response('af')\n\n\t\t\t\t\tfnLiteral += `c.response=af}`\n\t\t\t\t} else {\n\t\t\t\t\tfnLiteral += `if(af!==undefined){`\n\t\t\t\t\treporter.resolve()\n\n\t\t\t\t\tfnLiteral += `c.response=af}`\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treporter.resolve()\n\n\t\tfnLiteral += `r=c.response\\n`\n\n\t\tif (validator.response) fnLiteral += validation.response()\n\n\t\tfnLiteral += encodeCookie()\n\n\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\ttotal: hooks.mapResponse?.length\n\t\t})\n\t\tif (hooks.mapResponse?.length) {\n\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t)\n\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`mr=${\n\t\t\t\t\t\tisAsyncName(mapResponse) ? 'await ' : ''\n\t\t\t\t\t}e.mapResponse[${i}](c)\\n` +\n\t\t\t\t\t`if(mr!==undefined)r=c.response=mr\\n`\n\n\t\t\t\tendUnit()\n\t\t\t}\n\t\t}\n\t\tmapResponseReporter.resolve()\n\n\t\tfnLiteral += mapResponse()\n\t} else {\n\t\tconst handleReporter = report('handle', {\n\t\t\tname: isHandleFn ? (handler as Function).name : undefined\n\t\t})\n\n\t\tif (validator.response || hooks.mapResponse?.length) {\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r=await ${handle}\\n`\n\t\t\t\t: `let r=${handle}\\n`\n\n\t\t\thandleReporter.resolve()\n\n\t\t\tif (validator.response) fnLiteral += validation.response()\n\n\t\t\treport('afterHandle').resolve()\n\n\t\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\t\ttotal: hooks.mapResponse?.length\n\t\t\t})\n\n\t\t\tif (hooks.mapResponse?.length) {\n\t\t\t\tfnLiteral += '\\nc.response=r\\n'\n\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t\t)\n\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`\\nif(mr===undefined){` +\n\t\t\t\t\t\t`mr=${isAsyncName(mapResponse) ? 'await ' : ''}e.mapResponse[${i}](c)\\n` +\n\t\t\t\t\t\t`if(mr!==undefined)r=c.response=mr` +\n\t\t\t\t\t\t`}\\n`\n\n\t\t\t\t\tendUnit()\n\t\t\t\t}\n\t\t\t}\n\t\t\tmapResponseReporter.resolve()\n\n\t\t\tfnLiteral += encodeCookie()\n\n\t\t\tif (handler instanceof Response) {\n\t\t\t\tfnLiteral += inference.set\n\t\t\t\t\t? `if(` +\n\t\t\t\t\t\t`isNotEmpty(c.set.headers)||` +\n\t\t\t\t\t\t`c.set.status!==200||` +\n\t\t\t\t\t\t`c.set.redirect||` +\n\t\t\t\t\t\t`c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${\n\t\t\t\t\t\t\tmapResponseContext\n\t\t\t\t\t\t})` +\n\t\t\t\t\t\t`else return ${handle}.clone()`\n\t\t\t\t\t: `return ${handle}.clone()`\n\n\t\t\t\tfnLiteral += '\\n'\n\t\t\t} else fnLiteral += mapResponse()\n\t\t} else if (hasCookie || hasTrace) {\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r=await ${handle}\\n`\n\t\t\t\t: `let r=${handle}\\n`\n\n\t\t\thandleReporter.resolve()\n\n\t\t\treport('afterHandle').resolve()\n\n\t\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\t\ttotal: hooks.mapResponse?.length\n\t\t\t})\n\t\t\tif (hooks.mapResponse?.length) {\n\t\t\t\tfnLiteral += 'c.response= r\\n'\n\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t\t)\n\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`if(mr===undefined){` +\n\t\t\t\t\t\t`mr=${isAsyncName(mapResponse) ? 'await ' : ''}e.mapResponse[${i}](c)\\n` +\n\t\t\t\t\t\t`if(mr!==undefined)r=c.response=mr` +\n\t\t\t\t\t\t`}`\n\n\t\t\t\t\tendUnit()\n\t\t\t\t}\n\t\t\t}\n\t\t\tmapResponseReporter.resolve()\n\n\t\t\tfnLiteral += encodeCookie() + mapResponse()\n\t\t} else {\n\t\t\thandleReporter.resolve()\n\n\t\t\tconst handled = isAsyncHandler ? `await ${handle}` : handle\n\n\t\t\treport('afterHandle').resolve()\n\n\t\t\tif (handler instanceof Response) {\n\t\t\t\tfnLiteral += inference.set\n\t\t\t\t\t? `if(isNotEmpty(c.set.headers)||` +\n\t\t\t\t\t\t`c.set.status!==200||` +\n\t\t\t\t\t\t`c.set.redirect||` +\n\t\t\t\t\t\t`c.set.cookie)` +\n\t\t\t\t\t\t`return mapResponse(${saveResponse}${handle}.clone(),c.set${\n\t\t\t\t\t\t\tmapResponseContext\n\t\t\t\t\t\t})\\n` +\n\t\t\t\t\t\t`else return ${handle}.clone()\\n`\n\t\t\t\t\t: `return ${handle}.clone()\\n`\n\t\t\t} else fnLiteral += mapResponse(handled)\n\t\t}\n\t}\n\n\tfnLiteral += `\\n}catch(error){`\n\n\tif (!maybeAsync && hooks.error?.length) fnLiteral += `return(async()=>{`\n\tfnLiteral +=\n\t\t`const set=c.set\\n` +\n\t\t`if(!set.status||set.status<300)set.status=error?.status||500\\n`\n\n\tif (hasCookie) fnLiteral += encodeCookie()\n\n\tif (hasTrace && hooks.trace)\n\t\tfor (let i = 0; i < hooks.trace.length; i++)\n\t\t\t// There's a case where the error is thrown before any trace is called\n\t\t\tfnLiteral += `report${i}?.resolve(error);reportChild${i}?.(error)\\n`\n\n\tconst errorReporter = report('error', {\n\t\ttotal: hooks.error?.length\n\t})\n\n\tif (hooks.error?.length) {\n\t\tfnLiteral += `c.error=error\\n`\n\n\t\tif (hasValidation)\n\t\t\tfnLiteral +=\n\t\t\t\t`if(error instanceof TypeBoxError){` +\n\t\t\t\t'c.code=\"VALIDATION\"\\n' +\n\t\t\t\t'c.set.status=422' +\n\t\t\t\t'}else{' +\n\t\t\t\t`c.code=error.code??error[ERROR_CODE]??\"UNKNOWN\"}`\n\t\telse fnLiteral += `c.code=error.code??error[ERROR_CODE]??\"UNKNOWN\"\\n`\n\n\t\tfnLiteral += `let er\\n`\n\n\t\tfor (let i = 0; i < hooks.error.length; i++) {\n\t\t\tconst endUnit = errorReporter.resolveChild(hooks.error[i].fn.name)\n\n\t\t\tif (isAsync(hooks.error[i]))\n\t\t\t\tfnLiteral += `er=await e.error[${i}](c)\\n`\n\t\t\telse\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`er=e.error[${i}](c)\\n` +\n\t\t\t\t\t`if(er instanceof Promise)er=await er\\n`\n\n\t\t\tendUnit()\n\n\t\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\t\ttotal: hooks.mapResponse?.length\n\t\t\t})\n\n\t\t\tif (hooks.mapResponse?.length) {\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t\t)\n\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`c.response=er\\n` +\n\t\t\t\t\t\t`er=e.mapResponse[${i}](c)\\n` +\n\t\t\t\t\t\t`if(er instanceof Promise)er=await er\\n`\n\n\t\t\t\t\tendUnit()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmapResponseReporter.resolve()\n\n\t\t\tfnLiteral += `er=mapEarlyResponse(er,set${mapResponseContext})\\n`\n\t\t\tfnLiteral += `if(er){`\n\n\t\t\tif (hasTrace && hooks.trace) {\n\t\t\t\tfor (let i = 0; i < hooks.trace.length; i++)\n\t\t\t\t\tfnLiteral += `report${i}.resolve()\\n`\n\n\t\t\t\terrorReporter.resolve()\n\t\t\t}\n\n\t\t\tfnLiteral += `return er}`\n\t\t}\n\t}\n\n\terrorReporter.resolve()\n\n\tfnLiteral += `return handleError(c,error,true)`\n\tif (!maybeAsync && hooks.error?.length) fnLiteral += '})()'\n\tfnLiteral += '}'\n\n\tif (hasAfterResponse || hasTrace) {\n\t\tfnLiteral += `finally{ `\n\n\t\tif (!maybeAsync) fnLiteral += ';(async()=>{'\n\n\t\tconst reporter = report('afterResponse', {\n\t\t\ttotal: hooks.afterResponse?.length\n\t\t})\n\n\t\tif (hasAfterResponse && hooks.afterResponse) {\n\t\t\tfor (let i = 0; i < hooks.afterResponse.length; i++) {\n\t\t\t\tconst endUnit = reporter.resolveChild(\n\t\t\t\t\thooks.afterResponse[i].fn.name\n\t\t\t\t)\n\t\t\t\tfnLiteral += `\\nawait e.afterResponse[${i}](c)\\n`\n\t\t\t\tendUnit()\n\t\t\t}\n\t\t}\n\n\t\treporter.resolve()\n\n\t\tif (!maybeAsync) fnLiteral += '})()'\n\n\t\tfnLiteral += `}`\n\t}\n\n\tconst adapterVariables = adapter.inject\n\t\t? Object.keys(adapter.inject).join(',') + ','\n\t\t: ''\n\n\tlet init =\n\t\t`const {` +\n\t\t`handler,` +\n\t\t`handleError,` +\n\t\t`hooks:e, ` +\n\t\tallocateIf(`validator,`, hasValidation) +\n\t\t`mapResponse,` +\n\t\t`mapCompactResponse,` +\n\t\t`mapEarlyResponse,` +\n\t\t`isNotEmpty,` +\n\t\t`utils:{` +\n\t\tallocateIf(`parseQuery,`, hasBody) +\n\t\tallocateIf(`parseQueryFromURL,`, hasQuery) +\n\t\t`},` +\n\t\t`error:{` +\n\t\tallocateIf(`ValidationError,`, hasValidation) +\n\t\tallocateIf(`ParseError`, hasBody) +\n\t\t`},` +\n\t\t`validateFileExtension,` +\n\t\t`schema,` +\n\t\t`definitions,` +\n\t\t`ERROR_CODE,` +\n\t\tallocateIf(`parseCookie,`, hasCookie) +\n\t\tallocateIf(`signCookie,`, hasCookie) +\n\t\tallocateIf(`decodeURIComponent,`, hasQuery) +\n\t\t`ElysiaCustomStatusResponse,` +\n\t\tallocateIf(`ELYSIA_TRACE,`, hasTrace) +\n\t\tallocateIf(`ELYSIA_REQUEST_ID,`, hasTrace) +\n\t\tallocateIf('parser,', hooks.parse?.length) +\n\t\tallocateIf(`getServer,`, inference.server) +\n\t\tallocateIf(`fileUnions,`, fileUnions.length) +\n\t\tadapterVariables +\n\t\tallocateIf('TypeBoxError', hasValidation) +\n\t\t`}=hooks\\n` +\n\t\t`const trace=e.trace\\n` +\n\t\t`return ${maybeAsync ? 'async ' : ''}function handle(c){`\n\n\tif (hooks.beforeHandle?.length) init += 'let be\\n'\n\tif (hooks.afterHandle?.length) init += 'let af\\n'\n\tif (hooks.mapResponse?.length) init += 'let mr\\n'\n\tif (allowMeta) init += 'c.schema=schema\\nc.defs=definitions\\n'\n\n\tfnLiteral = init + fnLiteral + '}'\n\tinit = ''\n\n\ttry {\n\t\treturn Function(\n\t\t\t'hooks',\n\t\t\t'\"use strict\";\\n' + fnLiteral\n\t\t)({\n\t\t\thandler,\n\t\t\thooks: lifeCycleToFn({ ...hooks }),\n\t\t\tvalidator: hasValidation ? validator : undefined,\n\t\t\t// @ts-expect-error\n\t\t\thandleError: app.handleError,\n\t\t\tmapResponse: adapterHandler.mapResponse,\n\t\t\tmapCompactResponse: adapterHandler.mapCompactResponse,\n\t\t\tmapEarlyResponse: adapterHandler.mapEarlyResponse,\n\t\t\tisNotEmpty,\n\t\t\tutils: {\n\t\t\t\tparseQuery: hasBody ? parseQuery : undefined,\n\t\t\t\tparseQueryFromURL: hasQuery ? parseQueryFromURL : undefined\n\t\t\t},\n\t\t\terror: {\n\t\t\t\tValidationError: hasValidation ? ValidationError : undefined,\n\t\t\t\tParseError: hasBody ? ParseError : undefined\n\t\t\t},\n\t\t\tvalidateFileExtension,\n\t\t\tschema: app.router.history,\n\t\t\t// @ts-expect-error\n\t\t\tdefinitions: app.definitions.type,\n\t\t\tERROR_CODE,\n\t\t\tparseCookie: hasCookie ? parseCookie : undefined,\n\t\t\tsignCookie: hasCookie ? signCookie : undefined,\n\t\t\tdecodeURIComponent: hasQuery ? decode : undefined,\n\t\t\tElysiaCustomStatusResponse,\n\t\t\tELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined,\n\t\t\tELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined,\n\t\t\t// @ts-expect-error private property\n\t\t\tgetServer: () => app.getServer(),\n\t\t\tfileUnions: fileUnions.length ? fileUnions : undefined,\n\t\t\tTypeBoxError: hasValidation ? TypeBoxError : undefined,\n\t\t\tparser: app['~parser'],\n\t\t\t...adapter.inject\n\t\t})\n\t} catch (error) {\n\t\tconst debugHooks = lifeCycleToFn(hooks)\n\n\t\tconsole.log('[Composer] failed to generate optimized handler')\n\t\tconsole.log('---')\n\t\tconsole.log({\n\t\t\thandler:\n\t\t\t\ttypeof handler === 'function' ? handler.toString() : handler,\n\t\t\tinstruction: fnLiteral,\n\t\t\thooks: {\n\t\t\t\t...debugHooks,\n\t\t\t\t// @ts-ignore\n\t\t\t\ttransform: debugHooks?.transform?.map?.((x) => x.toString()),\n\t\t\t\t// @ts-ignore\n\t\t\t\tresolve: debugHooks?.resolve?.map?.((x) => x.toString()),\n\t\t\t\t// @ts-ignore\n\t\t\t\tbeforeHandle: debugHooks?.beforeHandle?.map?.((x) =>\n\t\t\t\t\tx.toString()\n\t\t\t\t),\n\t\t\t\t// @ts-ignore\n\t\t\t\tafterHandle: debugHooks?.afterHandle?.map?.((x) =>\n\t\t\t\t\tx.toString()\n\t\t\t\t),\n\t\t\t\t// @ts-ignore\n\t\t\t\tmapResponse: debugHooks?.mapResponse?.map?.((x) =>\n\t\t\t\t\tx.toString()\n\t\t\t\t),\n\t\t\t\t// @ts-ignore\n\t\t\t\tparse: debugHooks?.parse?.map?.((x) => x.toString()),\n\t\t\t\t// @ts-ignore\n\t\t\t\terror: debugHooks?.error?.map?.((x) => x.toString()),\n\t\t\t\t// @ts-ignore\n\t\t\t\tafterResponse: debugHooks?.afterResponse?.map?.((x) =>\n\t\t\t\t\tx.toString()\n\t\t\t\t),\n\t\t\t\t// @ts-ignore\n\t\t\t\tstop: debugHooks?.stop?.map?.((x) => x.toString())\n\t\t\t},\n\t\t\tvalidator,\n\t\t\t// @ts-expect-error\n\t\t\tdefinitions: app.definitions.type,\n\t\t\terror\n\t\t})\n\t\tconsole.log('---')\n\n\t\tprocess.exit(1)\n\t}\n}\n\nexport interface ComposerGeneralHandlerOptions {\n\t/**\n\t * optimization for standard internet hostname\n\t * this will assume hostname is always use a standard internet hostname\n\t * assuming hostname is at minimum of 11 length of string (http://a.bc)\n\t *\n\t * setting this to true will skip the first 11 character of the hostname\n\t *\n\t * @default true\n\t */\n\tstandardHostname?: boolean\n}\n\nexport const createOnRequestHandler = (\n\tapp: AnyElysia,\n\taddFn?: (word: string) => void\n) => {\n\tlet fnLiteral = ''\n\n\tconst report = createReport({\n\t\ttrace: app.event.trace,\n\t\taddFn:\n\t\t\taddFn ??\n\t\t\t((word) => {\n\t\t\t\tfnLiteral += word\n\t\t\t})\n\t})\n\n\tconst reporter = report('request', {\n\t\ttotal: app.event.request?.length\n\t})\n\n\tif (app.event.request?.length) {\n\t\tfnLiteral += `try{`\n\n\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\tconst hook = app.event.request[i]\n\t\t\tconst withReturn = hasReturn(hook)\n\t\t\tconst maybeAsync = isAsync(hook)\n\n\t\t\tconst endUnit = reporter.resolveChild(app.event.request[i].fn.name)\n\n\t\t\tif (withReturn) {\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`re=mapEarlyResponse(` +\n\t\t\t\t\t`${maybeAsync ? 'await ' : ''}onRequest[${i}](c),` +\n\t\t\t\t\t`c.set)\\n`\n\n\t\t\t\tendUnit('re')\n\t\t\t\tfnLiteral += `if(re!==undefined)return re\\n`\n\t\t\t} else {\n\t\t\t\tfnLiteral += `${maybeAsync ? 'await ' : ''}onRequest[${i}](c)\\n`\n\t\t\t\tendUnit()\n\t\t\t}\n\t\t}\n\n\t\tfnLiteral += `}catch(error){return app.handleError(c,error,false)}`\n\t}\n\n\treporter.resolve()\n\n\treturn fnLiteral\n}\n\nexport const createHoc = (app: AnyElysia, fnName = 'map') => {\n\t// @ts-expect-error private property\n\tconst hoc = app.extender.higherOrderFunctions\n\n\tif (!hoc.length) return 'return ' + fnName\n\n\tconst adapter = app['~adapter'].composeGeneralHandler\n\n\tlet handler = fnName\n\n\tfor (let i = 0; i < hoc.length; i++)\n\t\thandler = `hoc[${i}](${handler},${adapter.parameters})`\n\n\treturn `return function hocMap(${adapter.parameters}){return ${handler}(${adapter.parameters})}`\n}\n\nexport const composeGeneralHandler = (app: AnyElysia) => {\n\tconst adapter = app['~adapter'].composeGeneralHandler\n\tapp.router.http.build()\n\n\tconst error404 = adapter.error404(\n\t\t!!app.event.request?.length,\n\t\t!!app.event.error?.length\n\t)\n\n\tconst hasTrace = app.event.trace?.length\n\n\tlet fnLiteral = ''\n\n\tconst router = app.router\n\n\tlet findDynamicRoute = router.http.root.WS\n\t\t? `const route=router.find(r.method === \"GET\" && r.headers.get('upgrade')==='websocket'?'WS':r.method,p)`\n\t\t: `const route=router.find(r.method,p)`\n\n\tfindDynamicRoute += router.http.root.ALL ? '??router.find(\"ALL\",p)\\n' : '\\n'\n\n\tfindDynamicRoute += error404.code\n\n\tfindDynamicRoute +=\n\t\t`\\nc.params=route.params\\n` +\n\t\t`if(route.store.handler)return route.store.handler(c)\\n` +\n\t\t`return route.store.compile()(c)\\n`\n\n\tlet switchMap = ''\n\tfor (const [path, methods] of Object.entries(router.static)) {\n\t\tswitchMap += `case'${path}':`\n\n\t\tif (app.config.strictPath !== true)\n\t\t\tswitchMap += `case'${getLoosePath(path)}':`\n\n\t\tconst encoded = encodePath(path)\n\t\tif (path !== encoded) switchMap += `case'${encoded}':`\n\n\t\tswitchMap += 'switch(r.method){'\n\n\t\tif ('GET' in methods || 'WS' in methods) {\n\t\t\tswitchMap += `case 'GET':`\n\n\t\t\tif ('WS' in methods)\n\t\t\t\tswitchMap +=\n\t\t\t\t\t`if(r.headers.get('upgrade')==='websocket')` +\n\t\t\t\t\t`return ht[${methods.WS}].composed(c)\\n`\n\n\t\t\tif ('GET' in methods)\n\t\t\t\tswitchMap += `return ht[${methods.GET}].composed(c)\\n`\n\t\t}\n\n\t\tfor (const [method, index] of Object.entries(methods)) {\n\t\t\tif (method === 'ALL' || method === 'GET' || method === 'WS')\n\t\t\t\tcontinue\n\n\t\t\tswitchMap += `case '${method}':return ht[${index}].composed(c)\\n`\n\t\t}\n\n\t\tif ('ALL' in methods)\n\t\t\tswitchMap += `default:return ht[${methods.ALL}].composed(c)\\n`\n\t\telse switchMap += `default:break map\\n`\n\n\t\tswitchMap += '}'\n\t}\n\n\tconst maybeAsync = !!app.event.request?.some(isAsync)\n\n\tconst adapterVariables = adapter.inject\n\t\t? Object.keys(adapter.inject).join(',') + ','\n\t\t: ''\n\n\tfnLiteral +=\n\t\t`\\nconst {` +\n\t\t`app,` +\n\t\t`mapEarlyResponse,` +\n\t\t`NotFoundError,` +\n\t\t`randomId,` +\n\t\t`handleError,` +\n\t\t`status,` +\n\t\t`redirect,` +\n\t\tallocateIf(`ELYSIA_TRACE,`, hasTrace) +\n\t\tallocateIf(`ELYSIA_REQUEST_ID,`, hasTrace) +\n\t\tadapterVariables +\n\t\t`}=data\\n` +\n\t\t`const store=app.singleton.store\\n` +\n\t\t`const decorator=app.singleton.decorator\\n` +\n\t\t`const staticRouter=app.router.static.http\\n` +\n\t\t`const ht=app.router.history\\n` +\n\t\t`const router=app.router.http\\n` +\n\t\t`const trace=app.event.trace?.map(x=>typeof x==='function'?x:x.fn)??[]\\n` +\n\t\t`const notFound=new NotFoundError()\\n` +\n\t\t`const hoc=app.extender.higherOrderFunctions.map(x=>x.fn)\\n`\n\n\tif (app.event.request?.length)\n\t\tfnLiteral += `const onRequest=app.event.request.map(x=>x.fn)\\n`\n\n\tfnLiteral += error404.declare\n\n\tif (app.event.trace?.length)\n\t\tfnLiteral +=\n\t\t\t`const ` +\n\t\t\tapp.event.trace\n\t\t\t\t.map((_, i) => `tr${i}=app.event.trace[${i}].fn`)\n\t\t\t\t.join(',') +\n\t\t\t'\\n'\n\n\tfnLiteral += `${maybeAsync ? 'async ' : ''}function map(${adapter.parameters}){`\n\n\tif (app.event.request?.length) fnLiteral += `let re\\n`\n\n\tfnLiteral += adapter.createContext(app)\n\n\tif (app.event.trace?.length)\n\t\tfnLiteral +=\n\t\t\t`c[ELYSIA_TRACE]=[` +\n\t\t\tapp.event.trace.map((_, i) => `tr${i}(c)`).join(',') +\n\t\t\t`]\\n`\n\n\tfnLiteral += createOnRequestHandler(app)\n\n\tif (switchMap) fnLiteral += `\\nmap: switch(p){\\n` + switchMap + `}`\n\n\tfnLiteral += findDynamicRoute + `}\\n` + createHoc(app)\n\n\t// @ts-expect-error private property\n\tapp.handleError = composeErrorHandler(app) as any\n\n\tconst fn = Function(\n\t\t'data',\n\t\t'\"use strict\";\\n' + fnLiteral\n\t)({\n\t\tapp,\n\t\tmapEarlyResponse: app['~adapter']['handler'].mapEarlyResponse,\n\t\tNotFoundError,\n\t\trandomId,\n\t\t// @ts-expect-error private property\n\t\thandleError: app.handleError,\n\t\tstatus,\n\t\tredirect,\n\t\tELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined,\n\t\tELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined,\n\t\t...adapter.inject\n\t})\n\n\tif (isBun) Bun.gc(false)\n\n\treturn fn\n}\n\nexport const composeErrorHandler = (app: AnyElysia) => {\n\tconst hooks = app.event\n\tlet fnLiteral = ''\n\n\tconst adapter = app['~adapter'].composeError\n\tconst adapterVariables = adapter.inject\n\t\t? Object.keys(adapter.inject).join(',') + ','\n\t\t: ''\n\n\tconst hasTrace = !!app.event.trace?.length\n\n\tfnLiteral +=\n\t\t`const {` +\n\t\t`mapResponse,` +\n\t\t`ERROR_CODE,` +\n\t\t`ElysiaCustomStatusResponse,` +\n\t\tallocateIf(`onError,`, app.event.error) +\n\t\tallocateIf(`afterResponse,`, app.event.afterResponse) +\n\t\tallocateIf(`trace,`, app.event.trace) +\n\t\tallocateIf(`onMapResponse,`, app.event.mapResponse) +\n\t\tallocateIf(`ELYSIA_TRACE,`, hasTrace) +\n\t\tallocateIf(`ELYSIA_REQUEST_ID,`, hasTrace) +\n\t\tadapterVariables +\n\t\t`}=inject\\n`\n\n\tfnLiteral += `return ${\n\t\tapp.event.error?.find(isAsync) || app.event.mapResponse?.find(isAsync)\n\t\t\t? 'async '\n\t\t\t: ''\n\t}function(context,error,skipGlobal){`\n\n\tfnLiteral += ''\n\n\tif (hasTrace) fnLiteral += 'const id=context[ELYSIA_REQUEST_ID]\\n'\n\n\tconst report = createReport({\n\t\tcontext: 'context',\n\t\ttrace: hooks.trace,\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tfnLiteral +=\n\t\t`const set=context.set\\n` +\n\t\t`let _r\\n` +\n\t\t`if(!context.code)context.code=error.code??error[ERROR_CODE]\\n` +\n\t\t`if(!(context.error instanceof Error))context.error=error\\n` +\n\t\t`if(error instanceof ElysiaCustomStatusResponse){` +\n\t\t`set.status=error.status=error.code\\n` +\n\t\t`error.message=error.response` +\n\t\t`}`\n\n\tif (adapter.declare) fnLiteral += adapter.declare\n\n\tconst saveResponse =\n\t\thasTrace ||\n\t\t!!hooks.afterResponse?.length ||\n\t\t!!hooks.afterResponse?.length\n\t\t\t? 'context.response = '\n\t\t\t: ''\n\n\tif (app.event.error)\n\t\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\t\tconst handler = app.event.error[i]\n\n\t\t\tconst response = `${\n\t\t\t\tisAsync(handler) ? 'await ' : ''\n\t\t\t}onError[${i}](context)\\n`\n\n\t\t\tfnLiteral += 'if(skipGlobal!==true){'\n\n\t\t\tif (hasReturn(handler)) {\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`_r=${response}\\nif(_r!==undefined){` +\n\t\t\t\t\t`if(_r instanceof Response)return mapResponse(_r,set${adapter.mapResponseContext})\\n` +\n\t\t\t\t\t`if(_r instanceof ElysiaCustomStatusResponse){` +\n\t\t\t\t\t`error.status=error.code\\n` +\n\t\t\t\t\t`error.message = error.response` +\n\t\t\t\t\t`}` +\n\t\t\t\t\t`if(set.status===200||!set.status)set.status=error.status\\n`\n\n\t\t\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\t\t\ttotal: hooks.mapResponse?.length,\n\t\t\t\t\tname: 'context'\n\t\t\t\t})\n\n\t\t\t\tif (hooks.mapResponse?.length) {\n\t\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`context.response=_r` +\n\t\t\t\t\t\t\t`_r=${isAsyncName(mapResponse) ? 'await ' : ''}onMapResponse[${i}](context)\\n`\n\n\t\t\t\t\t\tendUnit()\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmapResponseReporter.resolve()\n\n\t\t\t\tfnLiteral += `return mapResponse(${saveResponse}_r,set${adapter.mapResponseContext})}`\n\t\t\t} else fnLiteral += response\n\n\t\t\tfnLiteral += '}'\n\t\t}\n\n\tfnLiteral +=\n\t\t`if(error.constructor.name===\"ValidationError\"||error.constructor.name===\"TransformDecodeError\"){\\n` +\n\t\t`if(error.error)error=error.error\\n` +\n\t\t`set.status=error.status??422\\n` +\n\t\tadapter.validationError +\n\t\t`\\n}\\n`\n\n\tfnLiteral +=\n\t\t`if(error instanceof Error){` +\n\t\t`\\nif(typeof error.toResponse==='function')return context.response=error.toResponse()\\n` +\n\t\tadapter.unknownError +\n\t\t`\\n}`\n\n\tconst mapResponseReporter = report('mapResponse', {\n\t\ttotal: hooks.mapResponse?.length,\n\t\tname: 'context'\n\t})\n\n\tfnLiteral +=\n\t\t'\\nif(!context.response)context.response=error.message??error\\n'\n\n\tif (hooks.mapResponse?.length) {\n\t\tfnLiteral += 'let mr\\n'\n\n\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\tmapResponse.fn.name\n\t\t\t)\n\n\t\t\tfnLiteral +=\n\t\t\t\t`if(mr===undefined){` +\n\t\t\t\t`mr=${isAsyncName(mapResponse) ? 'await ' : ''}onMapResponse[${i}](context)\\n` +\n\t\t\t\t`if(mr!==undefined)error=context.response=mr` +\n\t\t\t\t'}'\n\n\t\t\tendUnit()\n\t\t}\n\t}\n\n\tmapResponseReporter.resolve()\n\n\tfnLiteral += `\\nreturn mapResponse(${saveResponse}error,set${adapter.mapResponseContext})}`\n\n\tconst mapFn = (x: Function | HookContainer) =>\n\t\ttypeof x === 'function' ? x : x.fn\n\n\treturn Function(\n\t\t'inject',\n\t\t'\"use strict\";\\n' + fnLiteral\n\t)({\n\t\tmapResponse: app['~adapter'].handler.mapResponse,\n\t\tERROR_CODE,\n\t\tElysiaCustomStatusResponse,\n\t\tonError: app.event.error?.map(mapFn),\n\t\tafterResponse: app.event.afterResponse?.map(mapFn),\n\t\ttrace: app.event.trace?.map(mapFn),\n\t\tonMapResponse: app.event.mapResponse?.map(mapFn),\n\t\tELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined,\n\t\tELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined,\n\t\t...adapter.inject\n\t})\n}\n",
    "import decode from 'fast-decode-uri-component'\n\n// Parse query without array\nexport function parseQueryFromURL(\n\tinput: string,\n\tstartIndex: number = 0\n): Record<string, string> {\n\tconst result = Object.create(null)\n\n\t// bit flags\n\tconst KEY_PLUS_FLAG = 1\n\tconst KEY_DECODE_FLAG = 2\n\tconst VALUE_PLUS_FLAG = 4\n\tconst VALUE_DECODE_FLAG = 8\n\n\tlet flags = 0\n\tlet startingIndex = startIndex - 1\n\tlet equalityIndex = startingIndex\n\tconst inputLength = input.length\n\n\t// Main parsing loop\n\tfor (let i = startIndex; i < inputLength; i++)\n\t\tswitch (input.charCodeAt(i)) {\n\t\t\t// '&'\n\t\t\tcase 38:\n\t\t\t\tprocessKeyValuePair(i)\n\n\t\t\t\t// Reset for next pair\n\t\t\t\tstartingIndex = i\n\t\t\t\tequalityIndex = i\n\t\t\t\tflags = 0\n\n\t\t\t\tbreak\n\n\t\t\t// '='\n\t\t\tcase 61:\n\t\t\t\tif (equalityIndex <= startingIndex) equalityIndex = i\n\t\t\t\telse flags |= VALUE_DECODE_FLAG\n\n\t\t\t\tbreak\n\n\t\t\t// '+'\n\t\t\tcase 43:\n\t\t\t\tif (equalityIndex > startingIndex) flags |= VALUE_PLUS_FLAG\n\t\t\t\telse flags |= KEY_PLUS_FLAG\n\n\t\t\t\tbreak\n\n\t\t\t// '%'\n\t\t\tcase 37:\n\t\t\t\tif (equalityIndex > startingIndex) flags |= VALUE_DECODE_FLAG\n\t\t\t\telse flags |= KEY_DECODE_FLAG\n\n\t\t\t\tbreak\n\t\t}\n\n\t// Process the last pair if there is one\n\tprocessKeyValuePair(inputLength)\n\n\treturn result\n\n\tfunction processKeyValuePair(endIndex: number) {\n\t\tconst hasBothKeyValuePair = equalityIndex > startingIndex\n\t\tconst keyEndIndex = hasBothKeyValuePair ? equalityIndex : endIndex\n\n\t\t// Extract and process key only if the slice is not empty\n\t\tif (keyEndIndex <= startingIndex + 1) return\n\n\t\tlet keySlice = input.slice(startingIndex + 1, keyEndIndex)\n\t\tif (flags & KEY_PLUS_FLAG) keySlice = keySlice.replace(/\\+/g, ' ')\n\t\tif (flags & KEY_DECODE_FLAG) keySlice = decode(keySlice) || keySlice\n\n\t\t// Only add to result if this key doesn't already exist\n\t\tif (result[keySlice] !== undefined) return\n\n\t\t// Process value if it exists\n\t\tlet finalValue = ''\n\t\tif (hasBothKeyValuePair) {\n\t\t\tfinalValue = input.slice(equalityIndex + 1, endIndex)\n\n\t\t\tif (flags & VALUE_PLUS_FLAG)\n\t\t\t\tfinalValue = finalValue.replace(/\\+/g, ' ')\n\t\t\tif (flags & VALUE_DECODE_FLAG)\n\t\t\t\tfinalValue = decode(finalValue) || finalValue\n\t\t}\n\n\t\tresult[keySlice] = finalValue\n\t}\n}\n\n/**\n * @callback parse\n * @param {string} input\n */\nexport function parseQuery(input: string) {\n\tconst result = Object.create(null) as Record<string, string | string[]>\n\n\t// bit flags\n\tlet flags = 0\n\tconst KEY_HAS_PLUS = 1\n\tconst KEY_NEEDS_DECODE = 2\n\tconst VALUE_HAS_PLUS = 4\n\tconst VALUE_NEEDS_DECODE = 8\n\n\tconst inputLength = input.length\n\tlet startingIndex = -1\n\tlet equalityIndex = -1\n\n\tfor (let i = 0; i < inputLength; i++)\n\t\tswitch (input.charCodeAt(i)) {\n\t\t\t// '&'\n\t\t\tcase 38:\n\t\t\t\tprocessKeyValuePair(input, i)\n\n\t\t\t\t// Reset state variables\n\t\t\t\tstartingIndex = i\n\t\t\t\tequalityIndex = i\n\t\t\t\tflags = 0\n\n\t\t\t\tbreak\n\n\t\t\t// '='\n\t\t\tcase 61:\n\t\t\t\tif (equalityIndex <= startingIndex) equalityIndex = i\n\t\t\t\t// If '=' character occurs again, we should decode the input\n\t\t\t\telse flags |= VALUE_NEEDS_DECODE\n\n\t\t\t\tbreak\n\n\t\t\t// '+'\n\t\t\tcase 43:\n\t\t\t\tif (equalityIndex > startingIndex) flags |= VALUE_HAS_PLUS\n\t\t\t\telse flags |= KEY_HAS_PLUS\n\n\t\t\t\tbreak\n\n\t\t\t// '%'\n\t\t\tcase 37:\n\t\t\t\tif (equalityIndex > startingIndex) flags |= VALUE_NEEDS_DECODE\n\t\t\t\telse flags |= KEY_NEEDS_DECODE\n\n\t\t\t\tbreak\n\t\t}\n\n\t// Process the last pair if needed\n\tif (startingIndex < inputLength) processKeyValuePair(input, inputLength)\n\n\treturn result\n\n\tfunction processKeyValuePair(input: string, endIndex: number) {\n\t\tconst hasBothKeyValuePair = equalityIndex > startingIndex\n\t\tconst effectiveEqualityIndex = hasBothKeyValuePair\n\t\t\t? equalityIndex\n\t\t\t: endIndex\n\n\t\tconst keySlice = input.slice(startingIndex + 1, effectiveEqualityIndex)\n\n\t\t// Skip processing if key is empty\n\t\tif (!hasBothKeyValuePair && keySlice.length === 0) return\n\n\t\tlet finalKey = keySlice\n\t\tif (flags & KEY_HAS_PLUS) finalKey = finalKey.replace(/\\+/g, ' ')\n\t\tif (flags & KEY_NEEDS_DECODE) finalKey = decode(finalKey) || finalKey\n\n\t\tlet finalValue = ''\n\t\tif (hasBothKeyValuePair) {\n\t\t\tlet valueSlice = input.slice(equalityIndex + 1, endIndex)\n\t\t\tif (flags & VALUE_HAS_PLUS)\n\t\t\t\tvalueSlice = valueSlice.replace(/\\+/g, ' ')\n\t\t\tif (flags & VALUE_NEEDS_DECODE)\n\t\t\t\tvalueSlice = decode(valueSlice) || valueSlice\n\t\t\tfinalValue = valueSlice\n\t\t}\n\n\t\tconst currentValue = result[finalKey]\n\t\tif (currentValue === undefined) result[finalKey] = finalValue\n\t\telse if (Array.isArray(currentValue)) currentValue.push(finalValue)\n\t\telse result[finalKey] = [currentValue, finalValue]\n\t}\n}\n",
    "import { ELYSIA_REQUEST_ID } from './utils'\n\nimport type { Context } from './context'\nimport type { Prettify, RouteSchema, SingletonBase } from './types'\n\nexport type TraceEvent =\n\t| 'request'\n\t| 'parse'\n\t| 'transform'\n\t| 'beforeHandle'\n\t| 'handle'\n\t| 'afterHandle'\n\t| 'mapResponse'\n\t| 'afterResponse'\n\t| 'error'\n\nexport type TraceStream = {\n\tid: number\n\tevent: TraceEvent\n\ttype: 'begin' | 'end'\n\tbegin: number\n\tname?: string\n\ttotal?: number\n}\n\ntype TraceEndDetail = {\n\t/**\n\t * Timestamp of a function after it's executed since the server start\n\t */\n\tend: TraceProcess<'end'>\n\t/**\n\t * Error that was thrown in the lifecycle\n\t */\n\terror: Error | null\n\t/**\n\t * Elapsed time of the lifecycle\n\t */\n\telapsed: number\n}\n\nexport type TraceProcess<\n\tType extends 'begin' | 'end' = 'begin' | 'end',\n\tWithChildren extends boolean = true\n> = Type extends 'begin'\n\t? Prettify<\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * Function name\n\t\t\t\t */\n\t\t\t\tname: string\n\t\t\t\t/**\n\t\t\t\t * Timestamp of a function is called since the server start\n\t\t\t\t */\n\t\t\t\tbegin: number\n\t\t\t\t/**\n\t\t\t\t * Timestamp of a function after it's executed since the server start\n\t\t\t\t */\n\t\t\t\tend: Promise<number>\n\t\t\t\t/**\n\t\t\t\t * Error that was thrown in the lifecycle\n\t\t\t\t */\n\t\t\t\terror: Promise<Error | null>\n\t\t\t\t/**\n\t\t\t\t * Listener to intercept the end of the lifecycle\n\t\t\t\t *\n\t\t\t\t * If you want to mutate the context, you must do it in this function\n\t\t\t\t * as there's a lock mechanism to ensure the context is mutate successfully\n\t\t\t\t */\n\t\t\t\tonStop(\n\t\t\t\t\t/**\n\t\t\t\t\t * A callback function that will be called when the function ends\n\t\t\t\t\t *\n\t\t\t\t\t * If you want to mutate the context, you must do it in this function\n\t\t\t\t\t * as there's a lock mechanism to ensure the context is mutate successfully\n\t\t\t\t\t */\n\t\t\t\t\tcallback?: (detail: TraceEndDetail) => unknown\n\t\t\t\t): Promise<void>\n\t\t\t} & (WithChildren extends true\n\t\t\t\t? {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * total number of lifecycle's children and\n\t\t\t\t\t\t * total number of `onEvent` will be called\n\t\t\t\t\t\t * if there were no early exists or error thrown\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttotal: number\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Listener to intercept each child lifecycle\n\t\t\t\t\t\t */\n\t\t\t\t\t\tonEvent(\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * Callback function that will be called for when each child start\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tcallback?: (\n\t\t\t\t\t\t\t\tprocess: TraceProcess<'begin', false>\n\t\t\t\t\t\t\t) => unknown\n\t\t\t\t\t\t): Promise<void>\n\t\t\t\t\t}\n\t\t\t\t: {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Index of the child event\n\t\t\t\t\t\t */\n\t\t\t\t\t\tindex: number\n\t\t\t\t\t})\n\t\t>\n\t: number\n\nexport type TraceListener = (\n\tcallback?: (process: TraceProcess<'begin'>) => unknown\n) => Promise<TraceProcess<'begin'>>\n\nexport type TraceHandler<\n\tin out Route extends RouteSchema = {},\n\tin out Singleton extends SingletonBase = {\n\t\tdecorator: {}\n\t\tstore: {}\n\t\tderive: {}\n\t\tresolve: {}\n\t}\n> = {\n\t(\n\t\tlifecycle: Prettify<\n\t\t\t{\n\t\t\t\tid: number\n\t\t\t\tcontext: Context<Route, Singleton>\n\t\t\t\tset: Context['set']\n\t\t\t\ttime: number\n\t\t\t\tstore: Singleton['store']\n\t\t\t\tresponse: unknown\n\t\t\t} & {\n\t\t\t\t[x in `on${Capitalize<TraceEvent>}`]: TraceListener\n\t\t\t}\n\t\t>\n\t): unknown\n}\n\nexport const ELYSIA_TRACE = Symbol('ElysiaTrace')\n\nconst createProcess = () => {\n\tconst { promise, resolve } = Promise.withResolvers<TraceProcess>()\n\tconst { promise: end, resolve: resolveEnd } =\n\t\tPromise.withResolvers<number>()\n\tconst { promise: error, resolve: resolveError } =\n\t\tPromise.withResolvers<Error | null>()\n\n\tconst callbacks = <Function[]>[]\n\tconst callbacksEnd = <Function[]>[]\n\n\treturn [\n\t\t(callback?: Function) => {\n\t\t\tif (callback) callbacks.push(callback)\n\n\t\t\treturn promise\n\t\t},\n\t\t(process: TraceStream) => {\n\t\t\tconst processes = <((callback?: Function) => Promise<void>)[]>[]\n\t\t\tconst resolvers = <((process: TraceStream) => () => void)[]>[]\n\n\t\t\t// When error is return but not thrown\n\t\t\tlet groupError: Error | null = null\n\n\t\t\tfor (let i = 0; i < (process.total ?? 0); i++) {\n\t\t\t\tconst { promise, resolve } = Promise.withResolvers<void>()\n\t\t\t\tconst { promise: end, resolve: resolveEnd } =\n\t\t\t\t\tPromise.withResolvers<number>()\n\t\t\t\tconst { promise: error, resolve: resolveError } =\n\t\t\t\t\tPromise.withResolvers<Error | null>()\n\n\t\t\t\tconst callbacks = <Function[]>[]\n\t\t\t\tconst callbacksEnd = <Function[]>[]\n\n\t\t\t\tprocesses.push((callback?: Function) => {\n\t\t\t\t\tif (callback) callbacks.push(callback)\n\n\t\t\t\t\treturn promise\n\t\t\t\t})\n\n\t\t\t\tresolvers.push((process: TraceStream) => {\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\t...process,\n\t\t\t\t\t\tend,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tonStop(callback?: Function) {\n\t\t\t\t\t\t\tif (callback) callbacksEnd.push(callback)\n\n\t\t\t\t\t\t\treturn end\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any\n\n\t\t\t\t\tresolve(result)\n\t\t\t\t\tfor (let i = 0; i < callbacks.length; i++)\n\t\t\t\t\t\tcallbacks[i](result)\n\n\t\t\t\t\treturn (error: Error | null = null) => {\n\t\t\t\t\t\tconst end = performance.now()\n\n\t\t\t\t\t\t// Catch return error\n\t\t\t\t\t\tif (error) groupError = error\n\n\t\t\t\t\t\tconst detail = {\n\t\t\t\t\t\t\tend,\n\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\tget elapsed() {\n\t\t\t\t\t\t\t\treturn end - process.begin\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (let i = 0; i < callbacksEnd.length; i++)\n\t\t\t\t\t\t\tcallbacksEnd[i](detail)\n\n\t\t\t\t\t\tresolveEnd(end)\n\t\t\t\t\t\tresolveError(error)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tconst result = {\n\t\t\t\t...process,\n\t\t\t\tend,\n\t\t\t\terror,\n\t\t\t\tonEvent(callback?: Function) {\n\t\t\t\t\tfor (let i = 0; i < processes.length; i++)\n\t\t\t\t\t\tprocesses[i](callback)\n\t\t\t\t},\n\t\t\t\tonStop(callback?: Function) {\n\t\t\t\t\tif (callback) callbacksEnd.push(callback)\n\n\t\t\t\t\treturn end\n\t\t\t\t}\n\t\t\t} as any\n\n\t\t\tresolve(result)\n\t\t\tfor (let i = 0; i < callbacks.length; i++) callbacks[i](result)\n\n\t\t\treturn {\n\t\t\t\tresolveChild: resolvers,\n\t\t\t\tresolve(error: Error | null = null) {\n\t\t\t\t\tconst end = performance.now()\n\n\t\t\t\t\t// If error is return, parent group will not catch an error\n\t\t\t\t\t// but the child group will catch the error\n\t\t\t\t\tif (!error && groupError) error = groupError\n\n\t\t\t\t\tconst detail = {\n\t\t\t\t\t\tend,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tget elapsed() {\n\t\t\t\t\t\t\treturn end - process.begin\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < callbacksEnd.length; i++)\n\t\t\t\t\t\tcallbacksEnd[i](detail)\n\n\t\t\t\t\tresolveEnd(end)\n\t\t\t\t\tresolveError(error)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t] as const\n}\n\nexport const createTracer = (traceListener: TraceHandler) => {\n\treturn (context: Context) => {\n\t\tconst [onRequest, resolveRequest] = createProcess()\n\t\tconst [onParse, resolveParse] = createProcess()\n\t\tconst [onTransform, resolveTransform] = createProcess()\n\t\tconst [onBeforeHandle, resolveBeforeHandle] = createProcess()\n\t\tconst [onHandle, resolveHandle] = createProcess()\n\t\tconst [onAfterHandle, resolveAfterHandle] = createProcess()\n\t\tconst [onError, resolveError] = createProcess()\n\t\tconst [onMapResponse, resolveMapResponse] = createProcess()\n\t\tconst [onAfterResponse, resolveAfterResponse] = createProcess()\n\n\t\ttraceListener({\n\t\t\t// @ts-ignore\n\t\t\tid: context[ELYSIA_REQUEST_ID],\n\t\t\tcontext,\n\t\t\tset: context.set,\n\t\t\t// @ts-ignore\n\t\t\tonRequest,\n\t\t\t// @ts-ignore\n\t\t\tonParse,\n\t\t\t// @ts-ignore\n\t\t\tonTransform,\n\t\t\t// @ts-ignore\n\t\t\tonBeforeHandle,\n\t\t\t// @ts-ignore\n\t\t\tonHandle,\n\t\t\t// @ts-ignore\n\t\t\tonAfterHandle,\n\t\t\t// @ts-ignore\n\t\t\tonMapResponse,\n\t\t\t// @ts-ignore\n\t\t\tonAfterResponse,\n\t\t\t// @ts-ignore\n\t\t\tonError,\n\t\t\ttime: Date.now(),\n\t\t\tstore: context.store\n\t\t})\n\n\t\t// ? This is pass to compiler\n\t\treturn {\n\t\t\trequest: resolveRequest,\n\t\t\tparse: resolveParse,\n\t\t\ttransform: resolveTransform,\n\t\t\tbeforeHandle: resolveBeforeHandle,\n\t\t\thandle: resolveHandle,\n\t\t\tafterHandle: resolveAfterHandle,\n\t\t\terror: resolveError,\n\t\t\tmapResponse: resolveMapResponse,\n\t\t\tafterResponse: resolveAfterResponse\n\t\t}\n\t}\n}\n",
    "/* eslint-disable sonarjs/no-duplicate-string */\nimport {\n\tKind,\n\tOptionalKind,\n\tTModule,\n\tTObject,\n\tTransformKind,\n\tTSchema,\n\ttype TAnySchema\n} from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\n\nimport {\n\tcreateMirror,\n\ttype Instruction as ExactMirrorInstruction\n} from 'exact-mirror'\n\nimport { t, type TypeCheck } from './type-system'\n\nimport { mergeCookie, randomId } from './utils'\nimport { mapValueError } from './error'\n\nimport type { CookieOptions } from './cookies'\nimport type {\n\tElysiaConfig,\n\tInputSchema,\n\tMaybeArray,\n\tStandaloneInputSchema\n} from './types'\n\ntype MapValueError = ReturnType<typeof mapValueError>\n\nexport interface ElysiaTypeCheck<T extends TSchema>\n\textends Omit<TypeCheck<T>, 'schema'> {\n\tschema: T\n\tconfig: Object\n\tClean?(v: unknown): T\n\tparse(v: unknown): T\n\tsafeParse(v: unknown):\n\t\t| { success: true; data: T; error: null }\n\t\t| {\n\t\t\t\tsuccess: false\n\t\t\t\tdata: null\n\t\t\t\terror: string | undefined\n\t\t\t\terrors: MapValueError[]\n\t\t  }\n\thasAdditionalProperties: boolean\n\t'~hasAdditionalProperties'?: boolean\n\thasDefault: boolean\n\t'~hasDefault'?: boolean\n\tisOptional: boolean\n\t'~isOptional'?: boolean\n\thasTransform: boolean\n\t'~hasTransform'?: boolean\n\thasRef: boolean\n\t'~hasRef'?: boolean\n}\n\nexport const isOptional = (\n\tschema?: TSchema | TypeCheck<any> | ElysiaTypeCheck<any>\n) => {\n\tif (!schema) return false\n\n\t// @ts-ignore\n\tif (schema?.[Kind] === 'Import' && schema.References)\n\t\treturn schema.References().some(isOptional as any)\n\n\t// @ts-expect-error private property\n\tif (schema.schema)\n\t\t// @ts-expect-error private property\n\t\tschema = schema.schema\n\n\treturn !!schema && OptionalKind in schema\n}\n\nexport const hasAdditionalProperties = (\n\t_schema: TAnySchema | TypeCheck<any> | ElysiaTypeCheck<any>\n): boolean => {\n\tif (!_schema) return false\n\n\t// @ts-expect-error private property\n\tconst schema: TAnySchema = (_schema as TypeCheck<any>)?.schema ?? _schema\n\n\tif (schema[Kind] === 'Import' && _schema.References)\n\t\treturn _schema.References().some(hasAdditionalProperties)\n\n\tif (schema.anyOf) return schema.anyOf.some(hasAdditionalProperties)\n\tif (schema.someOf) return schema.someOf.some(hasAdditionalProperties)\n\tif (schema.allOf) return schema.allOf.some(hasAdditionalProperties)\n\tif (schema.not) return schema.not.some(hasAdditionalProperties)\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\n\t\tif ('additionalProperties' in schema) return schema.additionalProperties\n\t\tif ('patternProperties' in schema) return false\n\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasAdditionalProperties(property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasAdditionalProperties(property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\treturn property.additionalProperties\n\t\t}\n\n\t\treturn false\n\t}\n\n\tif (schema.type === 'array' && schema.items && !Array.isArray(schema.items))\n\t\treturn hasAdditionalProperties(schema.items)\n\n\treturn false\n}\n\nexport const hasType = (type: string, schema: TAnySchema) => {\n\tif (!schema) return false\n\n\tif (Kind in schema && schema[Kind] === type) return true\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tif (!properties) return false\n\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasType(type, property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasType(type, property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tif (Kind in property && property[Kind] === type) return true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\t!!schema.properties &&\n\t\tKind in schema.properties &&\n\t\tschema.properties[Kind] === type\n\t)\n}\n\nexport const hasProperty = (\n\texpectedProperty: string,\n\t_schema: TAnySchema | TypeCheck<any> | ElysiaTypeCheck<any>\n) => {\n\tif (!_schema) return\n\n\t// @ts-expect-error private property\n\tconst schema = _schema.schema ?? _schema\n\n\tif (schema[Kind] === 'Import' && _schema.References)\n\t\treturn _schema\n\t\t\t.References()\n\t\t\t.some((schema: TAnySchema) => hasProperty(expectedProperty, schema))\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\n\t\tif (!properties) return false\n\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (expectedProperty in property) return true\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasProperty(expectedProperty, property)) return true\n\t\t\t} else if (property.anyOf)\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasProperty(expectedProperty, property.anyOf[i]))\n\t\t\t\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn expectedProperty in schema\n}\n\nexport const hasRef = (schema: TAnySchema): boolean => {\n\tif (!schema) return false\n\n\tif (schema.oneOf)\n\t\tfor (let i = 0; i < schema.oneOf.length; i++)\n\t\t\tif (hasRef(schema.oneOf[i])) return true\n\n\tif (schema.anyOf)\n\t\tfor (let i = 0; i < schema.anyOf.length; i++)\n\t\t\tif (hasRef(schema.anyOf[i])) return true\n\n\tif (schema.oneOf)\n\t\tfor (let i = 0; i < schema.oneOf.length; i++)\n\t\t\tif (hasRef(schema.oneOf[i])) return true\n\n\tif (schema.allOf)\n\t\tfor (let i = 0; i < schema.allOf.length; i++)\n\t\t\tif (hasRef(schema.allOf[i])) return true\n\n\tif (schema.not && hasRef(schema.not)) return true\n\n\tif (schema.type === 'object' && schema.properties) {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (hasRef(property)) return true\n\n\t\t\tif (\n\t\t\t\tproperty.type === 'array' &&\n\t\t\t\tproperty.items &&\n\t\t\t\thasRef(property.items)\n\t\t\t)\n\t\t\t\treturn true\n\t\t}\n\t}\n\n\tif (schema.type === 'array' && schema.items && hasRef(schema.items))\n\t\treturn true\n\n\treturn schema[Kind] === 'Ref' && '$ref' in schema\n}\n\nexport const hasTransform = (schema: TAnySchema): boolean => {\n\tif (!schema) return false\n\n\tif (\n\t\tschema.$ref &&\n\t\tschema.$defs &&\n\t\tschema.$ref in schema.$defs &&\n\t\thasTransform(schema.$defs[schema.$ref])\n\t)\n\t\treturn true\n\n\tif (schema.oneOf)\n\t\tfor (let i = 0; i < schema.oneOf.length; i++)\n\t\t\tif (hasTransform(schema.oneOf[i])) return true\n\n\tif (schema.anyOf)\n\t\tfor (let i = 0; i < schema.anyOf.length; i++)\n\t\t\tif (hasTransform(schema.anyOf[i])) return true\n\n\tif (schema.allOf)\n\t\tfor (let i = 0; i < schema.allOf.length; i++)\n\t\t\tif (hasTransform(schema.allOf[i])) return true\n\n\tif (schema.not && hasTransform(schema.not)) return true\n\n\tif (schema.type === 'object' && schema.properties) {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (hasTransform(property)) return true\n\n\t\t\tif (\n\t\t\t\tproperty.type === 'array' &&\n\t\t\t\tproperty.items &&\n\t\t\t\thasTransform(property.items)\n\t\t\t)\n\t\t\t\treturn true\n\t\t}\n\t}\n\n\tif (schema.type === 'array' && schema.items && hasTransform(schema.items))\n\t\treturn true\n\n\treturn TransformKind in schema\n}\n\ninterface ReplaceSchemaTypeOptions {\n\tfrom: TSchema\n\tto(options: Object): TSchema | null\n\texcludeRoot?: boolean\n\trootOnly?: boolean\n\toriginal?: TAnySchema\n\t/**\n\t * Traverse until object is found except root object\n\t **/\n\tuntilObjectFound?: boolean\n}\n\ninterface ReplaceSchemaTypeConfig {\n\troot: boolean\n\tdefinitions?: Record<string, TSchema> | undefined\n}\n\nexport const replaceSchemaType = (\n\tschema: TSchema,\n\toptions: MaybeArray<ReplaceSchemaTypeOptions>,\n\t_config: Partial<Omit<ReplaceSchemaTypeConfig, 'root'>> = {}\n) => {\n\tconst config = _config as ReplaceSchemaTypeConfig\n\tconfig.root = true\n\n\t// if (schema.$defs)\n\t// \tconfig.definitions = {\n\t// \t\t...config.definitions,\n\t// \t\t...schema.$defs\n\t// \t}\n\n\t// const corceDefinitions = (option: ReplaceSchemaTypeOptions) => {\n\t// \tif (!config.definitions) return\n\n\t// \tfor (const [key, value] of Object.entries(config.definitions)) {\n\t// \t\tconst fromSymbol = option.from[Kind]\n\n\t// \t\tif (fromSymbol === 'Ref') continue\n\n\t// \t\tconfig.definitions[key] = _replaceSchemaType(value, option, config)\n\t// \t}\n\t// }\n\n\tif (!Array.isArray(options)) {\n\t\toptions.original = schema\n\n\t\t// corceDefinitions(options)\n\n\t\treturn _replaceSchemaType(schema, options, config)\n\t}\n\n\tfor (const option of options) {\n\t\toption.original = schema\n\n\t\t// corceDefinitions(option)\n\n\t\tschema = _replaceSchemaType(schema, option, config)\n\t}\n\n\treturn schema\n}\n\nconst _replaceSchemaType = (\n\tschema: TSchema,\n\toptions: ReplaceSchemaTypeOptions,\n\tconfig: ReplaceSchemaTypeConfig\n): TSchema => {\n\tif (!schema) return schema\n\n\tconst root = config.root\n\n\tif (options.untilObjectFound && !root && schema.type === 'object')\n\t\treturn schema\n\n\tconst fromSymbol = options.from[Kind]\n\n\t// if (schema.$ref) {\n\t// \tif (schema.$defs && schema.$ref in schema.$defs) {\n\t// \t\tconst definitions: Record<string, TSchema> = {}\n\n\t// \t\tfor (const [key, value] of Object.entries(schema.$defs))\n\t// \t\t\tdefinitions[key] = _replaceSchemaType(\n\t// \t\t\t\tvalue as TSchema,\n\t// \t\t\t\toptions,\n\t// \t\t\t\tconfig\n\t// \t\t\t)\n\n\t// \t\tconfig.definitions = { ...config.definitions, ...definitions }\n\t// \t}\n\n\t// \treturn schema\n\t// }\n\n\tif (schema.oneOf) {\n\t\tfor (let i = 0; i < schema.oneOf.length; i++)\n\t\t\tschema.oneOf[i] = _replaceSchemaType(\n\t\t\t\tschema.oneOf[i],\n\t\t\t\toptions,\n\t\t\t\tconfig\n\t\t\t)\n\n\t\treturn schema\n\t}\n\n\tif (schema.anyOf) {\n\t\tfor (let i = 0; i < schema.anyOf.length; i++)\n\t\t\tschema.anyOf[i] = _replaceSchemaType(\n\t\t\t\tschema.anyOf[i],\n\t\t\t\toptions,\n\t\t\t\tconfig\n\t\t\t)\n\n\t\treturn schema\n\t}\n\n\tif (schema.allOf) {\n\t\tfor (let i = 0; i < schema.allOf.length; i++)\n\t\t\tschema.allOf[i] = _replaceSchemaType(\n\t\t\t\tschema.allOf[i],\n\t\t\t\toptions,\n\t\t\t\tconfig\n\t\t\t)\n\n\t\treturn schema\n\t}\n\n\tif (schema.not) return _replaceSchemaType(schema.not, options, config)\n\n\tconst isRoot = root && !!options.excludeRoot\n\n\tif (schema[Kind] === fromSymbol) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tconst { anyOf, oneOf, allOf, not, properties, items, ...rest } = schema\n\n\t\tconst to = options.to(rest)\n\n\t\tif (!to) return schema\n\n\t\t// If t.Transform is used, we need to re-calculate Encode, Decode\n\t\tlet transform\n\n\t\tconst composeProperties = (schema: TSchema) => {\n\t\t\tconst v = _composeProperties(schema)\n\n\t\t\t// $id is removed because it's used in Union inside an Import\n\t\t\tif (v.$id) delete v.$id\n\n\t\t\treturn v\n\t\t}\n\n\t\tconst _composeProperties = (v: TSchema) => {\n\t\t\tif (properties && v.type === 'object') {\n\t\t\t\tconst newProperties = <Record<string, unknown>>{}\n\t\t\t\tfor (const [key, value] of Object.entries(properties))\n\t\t\t\t\tnewProperties[key] = _replaceSchemaType(\n\t\t\t\t\t\tvalue as TSchema,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t...config,\n\t\t\t\t\t\t\troot: false\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\n\t\t\t\treturn {\n\t\t\t\t\t...rest,\n\t\t\t\t\t...v,\n\t\t\t\t\tproperties: newProperties\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (items && v.type === 'array')\n\t\t\t\treturn {\n\t\t\t\t\t...rest,\n\t\t\t\t\t...v,\n\t\t\t\t\titems: _replaceSchemaType(items, options, {\n\t\t\t\t\t\t...config,\n\t\t\t\t\t\troot: false\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\tconst value = {\n\t\t\t\t...rest,\n\t\t\t\t...v\n\t\t\t}\n\n\t\t\t// Remove required as it's not object\n\t\t\tdelete value['required']\n\n\t\t\t// Create default value for ObjectString\n\t\t\tif (\n\t\t\t\tproperties &&\n\t\t\t\tv.type === 'string' &&\n\t\t\t\tv.format === 'ObjectString' &&\n\t\t\t\tv.default === '{}'\n\t\t\t) {\n\t\t\t\ttransform = t.ObjectString(properties, rest)\n\t\t\t\tvalue.default = JSON.stringify(\n\t\t\t\t\tValue.Create(t.Object(properties))\n\t\t\t\t)\n\t\t\t\tvalue.properties = properties\n\t\t\t}\n\n\t\t\t// Create default value for ArrayString\n\t\t\tif (\n\t\t\t\titems &&\n\t\t\t\tv.type === 'string' &&\n\t\t\t\tv.format === 'ArrayString' &&\n\t\t\t\tv.default === '[]'\n\t\t\t) {\n\t\t\t\ttransform = t.ArrayString(items, rest)\n\t\t\t\tvalue.default = JSON.stringify(Value.Create(t.Array(items)))\n\t\t\t\tvalue.items = items\n\t\t\t}\n\n\t\t\treturn value\n\t\t}\n\n\t\tif (isRoot) {\n\t\t\tif (properties) {\n\t\t\t\tconst newProperties = <Record<string, unknown>>{}\n\t\t\t\tfor (const [key, value] of Object.entries(properties))\n\t\t\t\t\tnewProperties[key] = _replaceSchemaType(\n\t\t\t\t\t\tvalue as TSchema,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t...config,\n\t\t\t\t\t\t\troot: false\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\n\t\t\t\treturn {\n\t\t\t\t\t...rest,\n\t\t\t\t\tproperties: newProperties\n\t\t\t\t}\n\t\t\t} else if (items?.map)\n\t\t\t\treturn {\n\t\t\t\t\t...rest,\n\t\t\t\t\titems: items.map((v: TSchema) =>\n\t\t\t\t\t\t_replaceSchemaType(v, options, {\n\t\t\t\t\t\t\t...config,\n\t\t\t\t\t\t\troot: false\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\treturn rest\n\t\t}\n\n\t\tif (to.anyOf)\n\t\t\tfor (let i = 0; i < to.anyOf.length; i++)\n\t\t\t\tto.anyOf[i] = composeProperties(to.anyOf[i])\n\t\telse if (to.oneOf)\n\t\t\tfor (let i = 0; i < to.oneOf.length; i++)\n\t\t\t\tto.oneOf[i] = composeProperties(to.oneOf[i])\n\t\telse if (to.allOf)\n\t\t\tfor (let i = 0; i < to.allOf.length; i++)\n\t\t\t\tto.allOf[i] = composeProperties(to.allOf[i])\n\t\telse if (to.not) to.not = composeProperties(to.not)\n\n\t\tif (transform) to[TransformKind as any] = transform[TransformKind]\n\n\t\tif (to.anyOf || to.oneOf || to.allOf || to.not) return to\n\n\t\tif (properties) {\n\t\t\tconst newProperties = <Record<string, unknown>>{}\n\t\t\tfor (const [key, value] of Object.entries(properties))\n\t\t\t\tnewProperties[key] = _replaceSchemaType(\n\t\t\t\t\tvalue as TSchema,\n\t\t\t\t\toptions,\n\t\t\t\t\t{\n\t\t\t\t\t\t...config,\n\t\t\t\t\t\troot: false\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\treturn {\n\t\t\t\t...rest,\n\t\t\t\t...to,\n\t\t\t\tproperties: newProperties\n\t\t\t}\n\t\t} else if (items?.map)\n\t\t\treturn {\n\t\t\t\t...rest,\n\t\t\t\t...to,\n\t\t\t\titems: items.map((v: TSchema) =>\n\t\t\t\t\t_replaceSchemaType(v, options, {\n\t\t\t\t\t\t...config,\n\t\t\t\t\t\troot: false\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\n\t\treturn {\n\t\t\t...rest,\n\t\t\t...to\n\t\t}\n\t}\n\n\tconst properties = schema?.properties as Record<string, TSchema>\n\n\tif (properties && root && options.rootOnly !== true)\n\t\tfor (const [key, value] of Object.entries(properties)) {\n\t\t\tswitch (value[Kind]) {\n\t\t\t\tcase fromSymbol:\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\t\tconst { anyOf, oneOf, allOf, not, type, ...rest } = value\n\t\t\t\t\tconst to = options.to(rest)\n\n\t\t\t\t\tif (!to) return schema\n\n\t\t\t\t\tif (to.anyOf)\n\t\t\t\t\t\tfor (let i = 0; i < to.anyOf.length; i++)\n\t\t\t\t\t\t\tto.anyOf[i] = { ...rest, ...to.anyOf[i] }\n\t\t\t\t\telse if (to.oneOf)\n\t\t\t\t\t\tfor (let i = 0; i < to.oneOf.length; i++)\n\t\t\t\t\t\t\tto.oneOf[i] = { ...rest, ...to.oneOf[i] }\n\t\t\t\t\telse if (to.allOf)\n\t\t\t\t\t\tfor (let i = 0; i < to.allOf.length; i++)\n\t\t\t\t\t\t\tto.allOf[i] = { ...rest, ...to.allOf[i] }\n\t\t\t\t\telse if (to.not) to.not = { ...rest, ...to.not }\n\n\t\t\t\t\tproperties[key] = {\n\t\t\t\t\t\t...rest,\n\t\t\t\t\t\t..._replaceSchemaType(rest, options, {\n\t\t\t\t\t\t\t...config,\n\t\t\t\t\t\t\troot: false\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'Object':\n\t\t\t\tcase 'Union':\n\t\t\t\t\tproperties[key] = _replaceSchemaType(value, options, {\n\t\t\t\t\t\t...config,\n\t\t\t\t\t\troot: false\n\t\t\t\t\t})\n\t\t\t\t\tbreak\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (Array.isArray(value.items)) {\n\t\t\t\t\t\tfor (let i = 0; i < value.items.length; i++) {\n\t\t\t\t\t\t\tvalue.items[i] = _replaceSchemaType(\n\t\t\t\t\t\t\t\tvalue.items[i],\n\t\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t...config,\n\t\t\t\t\t\t\t\t\troot: false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tvalue.anyOf ||\n\t\t\t\t\t\tvalue.oneOf ||\n\t\t\t\t\t\tvalue.allOf ||\n\t\t\t\t\t\tvalue.not\n\t\t\t\t\t)\n\t\t\t\t\t\tproperties[key] = _replaceSchemaType(value, options, {\n\t\t\t\t\t\t\t...config,\n\t\t\t\t\t\t\troot: false\n\t\t\t\t\t\t})\n\t\t\t\t\telse if (value.type === 'array') {\n\t\t\t\t\t\tvalue.items = _replaceSchemaType(value.items, options, {\n\t\t\t\t\t\t\t...config,\n\t\t\t\t\t\t\troot: false\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\treturn schema\n}\n\nconst createCleaner = (schema: TAnySchema) => (value: unknown) => {\n\tif (typeof value === 'object')\n\t\ttry {\n\t\t\treturn Value.Clean(schema, value)\n\t\t} catch {\n\t\t\ttry {\n\t\t\t\treturn Value.Clean(schema, value)\n\t\t\t} catch {\n\t\t\t\treturn value\n\t\t\t}\n\t\t}\n\n\treturn value\n}\n\n// const caches = <Record<string, ElysiaTypeCheck<any>>>{}\n\nexport const getSchemaValidator = <T extends TSchema | string | undefined>(\n\ts: T,\n\t{\n\t\tmodels = {},\n\t\tdynamic = false,\n\t\tmodules,\n\t\tnormalize = false,\n\t\tadditionalProperties = false,\n\t\tcoerce = false,\n\t\tadditionalCoerce = [],\n\t\tvalidators,\n\t\tsanitize\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tmodules?: TModule<any, any>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t\tnormalize?: ElysiaConfig<''>['normalize']\n\t\tcoerce?: boolean\n\t\tadditionalCoerce?: MaybeArray<ReplaceSchemaTypeOptions>\n\t\tvalidators?: InputSchema['body'][]\n\t\tsanitize?: () => ExactMirrorInstruction['sanitize']\n\t} = {}\n): T extends TSchema ? ElysiaTypeCheck<TSchema> : undefined => {\n\tvalidators = validators?.filter((x) => x)\n\n\tif (!s) {\n\t\tif (!validators?.length) return undefined as any\n\n\t\ts = validators[0] as any\n\t\tvalidators = validators.slice(1)\n\t}\n\n\tlet doesHaveRef: boolean | undefined = undefined\n\n\tconst replaceSchema = (schema: TAnySchema): TAnySchema => {\n\t\tif (coerce)\n\t\t\treturn replaceSchemaType(schema, [\n\t\t\t\t{\n\t\t\t\t\tfrom: t.Number(),\n\t\t\t\t\tto: (options) => t.Numeric(options),\n\t\t\t\t\tuntilObjectFound: true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfrom: t.Boolean(),\n\t\t\t\t\tto: (options) => t.BooleanString(options),\n\t\t\t\t\tuntilObjectFound: true\n\t\t\t\t},\n\t\t\t\t...(Array.isArray(additionalCoerce)\n\t\t\t\t\t? additionalCoerce\n\t\t\t\t\t: [additionalCoerce])\n\t\t\t])\n\n\t\treturn replaceSchemaType(schema, additionalCoerce)\n\t}\n\n\tconst mapSchema = (s: string | TSchema | undefined): TSchema => {\n\t\tlet schema: TSchema\n\n\t\tif (!s) return undefined as any\n\n\t\tif (typeof s !== 'string') schema = s\n\t\telse {\n\t\t\t// if (s in caches) return caches[s] as any\n\n\t\t\tconst isArray = s.endsWith('[]')\n\t\t\tconst key = isArray ? s.substring(0, s.length - 2) : s\n\n\t\t\tschema =\n\t\t\t\t(modules as TModule<{}, {}> | undefined)?.Import(\n\t\t\t\t\tkey as never\n\t\t\t\t) ?? models[key]\n\n\t\t\tif (isArray) schema = t.Array(schema)\n\t\t}\n\n\t\tif (!schema) return undefined as any\n\n\t\tlet _doesHaveRef: boolean\n\t\tif (schema[Kind] !== 'Import' && (_doesHaveRef = hasRef(schema))) {\n\t\t\tconst id = randomId()\n\n\t\t\tif (doesHaveRef === undefined) doesHaveRef = _doesHaveRef\n\n\t\t\tconst model: any = t.Module({\n\t\t\t\t// @ts-expect-error private property\n\t\t\t\t...modules?.$defs,\n\t\t\t\t[id]: schema\n\t\t\t})\n\n\t\t\tschema = model.Import(id)\n\t\t}\n\n\t\tif (schema[Kind] === 'Import') {\n\t\t\tconst newDefs: Record<string, TSchema> = {}\n\n\t\t\tfor (const [key, value] of Object.entries(schema.$defs))\n\t\t\t\tnewDefs[key] = replaceSchema(value as TSchema)\n\n\t\t\tconst key = schema.$ref\n\t\t\tschema = t.Module(newDefs).Import(key)\n\t\t} else if (coerce || additionalCoerce) schema = replaceSchema(schema)\n\n\t\treturn schema\n\t}\n\n\tlet schema = mapSchema(s)\n\n\tif (validators?.length) {\n\t\tlet hasAdditional = false\n\n\t\tconst { schema: mergedObjectSchema, notObjects } = mergeObjectSchemas([\n\t\t\tschema,\n\t\t\t...validators.map(mapSchema)\n\t\t])\n\n\t\tif (notObjects) {\n\t\t\tschema = t.Intersect([\n\t\t\t\t...(mergedObjectSchema ? [mergedObjectSchema] : []),\n\t\t\t\t...notObjects.map((x) => {\n\t\t\t\t\tconst schema = mapSchema(x)\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tschema.type === 'object' &&\n\t\t\t\t\t\t'additionalProperties' in schema\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!hasAdditional &&\n\t\t\t\t\t\t\tschema.additionalProperties === false\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\thasAdditional = true\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete schema.additionalProperties\n\t\t\t\t\t}\n\n\t\t\t\t\treturn schema\n\t\t\t\t})\n\t\t\t])\n\n\t\t\tif (schema.type === 'object' && hasAdditional)\n\t\t\t\tschema.additionalProperties = false\n\t\t}\n\t} else {\n\t\tif (\n\t\t\tschema.type === 'object' &&\n\t\t\t'additionalProperties' in schema === false\n\t\t)\n\t\t\tschema.additionalProperties = additionalProperties\n\t}\n\n\tif (dynamic) {\n\t\tconst validator: ElysiaTypeCheck<any> = {\n\t\t\tschema,\n\t\t\treferences: '',\n\t\t\tcheckFunc: () => {},\n\t\t\tcode: '',\n\t\t\t// @ts-expect-error\n\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\tCode: () => '',\n\t\t\tClean: createCleaner(schema),\n\t\t\tDecode: (value: unknown) => Value.Decode(schema, value),\n\t\t\tEncode: (value: unknown) => Value.Encode(schema, value),\n\t\t\tget hasAdditionalProperties() {\n\t\t\t\tif ('~hasAdditionalProperties' in this)\n\t\t\t\t\treturn this['~hasAdditionalProperties'] as boolean\n\n\t\t\t\treturn (this['~hasAdditionalProperties'] =\n\t\t\t\t\thasAdditionalProperties(schema))\n\t\t\t},\n\t\t\tget hasDefault() {\n\t\t\t\tif ('~hasDefault' in this) return this['~hasDefault']\n\n\t\t\t\treturn (this['~hasDefault'] = hasProperty('default', schema))\n\t\t\t},\n\t\t\tget isOptional() {\n\t\t\t\tif ('~isOptional' in this) return this['~isOptional']!\n\n\t\t\t\treturn (this['~isOptional'] = isOptional(schema))\n\t\t\t},\n\t\t\tget hasTransform() {\n\t\t\t\tif ('~hasTransform' in this) return this['~hasTransform']!\n\n\t\t\t\treturn (this['~hasTransform'] = hasTransform(schema))\n\t\t\t},\n\t\t\t'~hasRef': doesHaveRef,\n\t\t\tget hasRef() {\n\t\t\t\tif ('~hasRef' in this) return this['~hasRef']!\n\n\t\t\t\treturn (this['~hasRef'] = hasTransform(schema))\n\t\t\t}\n\t\t}\n\n\t\tif (schema.config) {\n\t\t\tvalidator.config = schema.config\n\n\t\t\tif (validator?.schema?.config) delete validator.schema.config\n\t\t}\n\n\t\tif (normalize && schema.additionalProperties === false) {\n\t\t\tif (normalize === true || normalize === 'exactMirror') {\n\t\t\t\ttry {\n\t\t\t\t\tvalidator.Clean = createMirror(schema, {\n\t\t\t\t\t\tTypeCompiler,\n\t\t\t\t\t\tsanitize: sanitize?.(),\n\t\t\t\t\t\tmodules\n\t\t\t\t\t})\n\t\t\t\t} catch {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t'Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues'\n\t\t\t\t\t)\n\t\t\t\t\tconsole.warn(schema)\n\t\t\t\t\tvalidator.Clean = createCleaner(schema)\n\t\t\t\t}\n\t\t\t} else validator.Clean = createCleaner(schema)\n\t\t}\n\n\t\tvalidator.parse = (v) => {\n\t\t\ttry {\n\t\t\t\treturn validator.Decode(v)\n\t\t\t} catch (error) {\n\t\t\t\tthrow [...validator.Errors(v)].map(mapValueError)\n\t\t\t}\n\t\t}\n\n\t\tvalidator.safeParse = (v) => {\n\t\t\ttry {\n\t\t\t\treturn { success: true, data: validator.Decode(v), error: null }\n\t\t\t} catch (error) {\n\t\t\t\tconst errors = [...compiled.Errors(v)].map(mapValueError)\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tdata: null,\n\t\t\t\t\terror: errors[0]?.summary,\n\t\t\t\t\terrors\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if (cacheKey) caches[cacheKey] = validator\n\n\t\treturn validator as any\n\t}\n\n\tconst compiled = TypeCompiler.Compile(\n\t\tschema,\n\t\tObject.values(models)\n\t) as any as ElysiaTypeCheck<any>\n\n\tif (schema.config) {\n\t\tcompiled.config = schema.config\n\n\t\tif (compiled?.schema?.config) delete compiled.schema.config\n\t}\n\n\tif (normalize === true || normalize === 'exactMirror') {\n\t\ttry {\n\t\t\tcompiled.Clean = createMirror(schema, {\n\t\t\t\tTypeCompiler,\n\t\t\t\tsanitize: sanitize?.(),\n\t\t\t\tmodules\n\t\t\t})\n\t\t} catch (error) {\n\t\t\tconsole.warn(\n\t\t\t\t'Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues'\n\t\t\t)\n\t\t\tconsole.warn(schema)\n\n\t\t\tcompiled.Clean = createCleaner(schema)\n\t\t}\n\t} else compiled.Clean = createCleaner(schema)\n\n\tcompiled.parse = (v) => {\n\t\ttry {\n\t\t\treturn compiled.Decode(v)\n\t\t} catch (error) {\n\t\t\tthrow [...compiled.Errors(v)].map(mapValueError)\n\t\t}\n\t}\n\n\tcompiled.safeParse = (v) => {\n\t\ttry {\n\t\t\treturn { success: true, data: compiled.Decode(v), error: null }\n\t\t} catch (error) {\n\t\t\tconst errors = [...compiled.Errors(v)].map(mapValueError)\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tdata: null,\n\t\t\t\terror: errors[0]?.summary,\n\t\t\t\terrors\n\t\t\t}\n\t\t}\n\t}\n\n\tObject.assign(compiled, {\n\t\tget hasAdditionalProperties() {\n\t\t\tif ('~hasAdditionalProperties' in this)\n\t\t\t\treturn this['~hasAdditionalProperties']\n\n\t\t\treturn (this['~hasAdditionalProperties'] =\n\t\t\t\thasAdditionalProperties(compiled))\n\t\t},\n\t\tget hasDefault() {\n\t\t\tif ('~hasDefault' in this) return this['~hasDefault']\n\n\t\t\treturn (this['~hasDefault'] = hasProperty('default', compiled))\n\t\t},\n\t\tget isOptional() {\n\t\t\tif ('~isOptional' in this) return this['~isOptional']!\n\n\t\t\treturn (this['~isOptional'] = isOptional(compiled))\n\t\t},\n\t\tget hasTransform() {\n\t\t\tif ('~hasTransform' in this) return this['~hasTransform']!\n\n\t\t\treturn (this['~hasTransform'] = hasTransform(schema))\n\t\t},\n\t\tget hasRef() {\n\t\t\tif ('~hasRef' in this) return this['~hasRef']!\n\n\t\t\treturn (this['~hasRef'] = hasRef(schema))\n\t\t},\n\t\t'~hasRef': doesHaveRef\n\t} as ElysiaTypeCheck<any>)\n\n\t// if (cacheKey) caches[cacheKey] = compiled\n\n\treturn compiled as any\n}\n\nexport const isUnion = (schema: TSchema) =>\n\tschema[Kind] === 'Union' || (!schema.schema && !!schema.anyOf)\n\nexport const mergeObjectSchemas = (\n\tschemas: TSchema[]\n): {\n\tschema: TObject | undefined\n\tnotObjects: TSchema[]\n} => {\n\tif (schemas.length === 0) {\n\t\treturn {\n\t\t\tschema: undefined,\n\t\t\tnotObjects: []\n\t\t}\n\t}\n\tif (schemas.length === 1)\n\t\treturn schemas[0].type === 'object'\n\t\t\t? {\n\t\t\t\t\tschema: schemas[0] as TObject,\n\t\t\t\t\tnotObjects: []\n\t\t\t\t}\n\t\t\t: {\n\t\t\t\t\tschema: undefined,\n\t\t\t\t\tnotObjects: schemas\n\t\t\t\t}\n\n\tlet newSchema: TObject\n\tconst notObjects = <TSchema[]>[]\n\n\tlet additionalPropertiesIsTrue = false\n\tlet additionalPropertiesIsFalse = false\n\n\tfor (const schema of schemas) {\n\t\tif (schema.type !== 'object') {\n\t\t\tnotObjects.push(schema)\n\t\t\tcontinue\n\t\t}\n\n\t\tif ('additionalProperties' in schema) {\n\t\t\tif (schema.additionalProperties === true)\n\t\t\t\tadditionalPropertiesIsTrue = true\n\t\t\telse if (schema.additionalProperties === false)\n\t\t\t\tadditionalPropertiesIsFalse = true\n\t\t}\n\n\t\tif (!newSchema!) {\n\t\t\tnewSchema = schema as TObject\n\t\t\tcontinue\n\t\t}\n\n\t\tnewSchema = {\n\t\t\t...newSchema,\n\t\t\t...schema,\n\t\t\tproperties: {\n\t\t\t\t...newSchema.properties,\n\t\t\t\t...schema.properties\n\t\t\t},\n\t\t\trequired: [...(newSchema?.required ?? []), ...schema.required]\n\t\t} as TObject\n\t}\n\n\tif (newSchema!) {\n\t\tif (newSchema.required)\n\t\t\tnewSchema.required = [...new Set(newSchema.required)]\n\n\t\tif (additionalPropertiesIsFalse) newSchema.additionalProperties = false\n\t\telse if (additionalPropertiesIsTrue)\n\t\t\tnewSchema.additionalProperties = true\n\t}\n\n\treturn {\n\t\tschema: newSchema!,\n\t\tnotObjects\n\t}\n}\n\nexport const getResponseSchemaValidator = (\n\ts: InputSchema['response'] | undefined,\n\t{\n\t\tmodels = {},\n\t\tmodules,\n\t\tdynamic = false,\n\t\tnormalize = false,\n\t\tadditionalProperties = false,\n\t\tvalidators = [],\n\t\tsanitize\n\t}: {\n\t\tmodules: TModule<any, any>\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t\tnormalize?: ElysiaConfig<''>['normalize']\n\t\tvalidators?: StandaloneInputSchema['response'][]\n\t\tsanitize?: () => ExactMirrorInstruction['sanitize']\n\t}\n): Record<number, ElysiaTypeCheck<any>> | undefined => {\n\tvalidators = validators.filter((x) => x)\n\n\tif (!s) {\n\t\tif (!validators?.length) return undefined as any\n\n\t\ts = validators[0] as any\n\t\tvalidators = validators.slice(1)\n\t}\n\n\tlet maybeSchemaOrRecord: TSchema | Record<number, string | TSchema>\n\n\tif (typeof s !== 'string') maybeSchemaOrRecord = s!\n\telse {\n\t\tconst isArray = s.endsWith('[]')\n\t\tconst key = isArray ? s.substring(0, s.length - 2) : s\n\n\t\tmaybeSchemaOrRecord =\n\t\t\t(modules as TModule<{}, {}>).Import(key as never) ?? models[key]\n\n\t\tif (isArray)\n\t\t\tmaybeSchemaOrRecord = t.Array(maybeSchemaOrRecord as TSchema)\n\t}\n\n\tif (!maybeSchemaOrRecord) return\n\n\tif (Kind in maybeSchemaOrRecord) {\n\t\treturn {\n\t\t\t200: getSchemaValidator(maybeSchemaOrRecord, {\n\t\t\t\tmodules,\n\t\t\t\tmodels,\n\t\t\t\tadditionalProperties,\n\t\t\t\tdynamic,\n\t\t\t\tnormalize,\n\t\t\t\tcoerce: false,\n\t\t\t\tadditionalCoerce: [],\n\t\t\t\tvalidators: validators.map((x) => x![200]),\n\t\t\t\tsanitize\n\t\t\t})\n\t\t}\n\t}\n\n\tconst record: Record<number, ElysiaTypeCheck<any>> = {}\n\n\tObject.keys(maybeSchemaOrRecord).forEach((status): TSchema | undefined => {\n\t\tif (isNaN(+status)) return\n\n\t\tconst maybeNameOrSchema = maybeSchemaOrRecord[+status]\n\n\t\tif (typeof maybeNameOrSchema === 'string') {\n\t\t\tif (maybeNameOrSchema in models) {\n\t\t\t\tconst schema = models[maybeNameOrSchema]\n\n\t\t\t\t// Inherits model maybe already compiled\n\t\t\t\trecord[+status] =\n\t\t\t\t\tKind in schema\n\t\t\t\t\t\t? getSchemaValidator(schema, {\n\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\tadditionalProperties,\n\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\tnormalize,\n\t\t\t\t\t\t\t\tcoerce: false,\n\t\t\t\t\t\t\t\tadditionalCoerce: [],\n\t\t\t\t\t\t\t\tvalidators: validators.map((x) => x![+status]),\n\t\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t: schema\n\t\t\t}\n\n\t\t\treturn undefined\n\t\t}\n\n\t\t// Inherits model maybe already compiled\n\t\trecord[+status] =\n\t\t\tKind in maybeNameOrSchema\n\t\t\t\t? getSchemaValidator(maybeNameOrSchema as TSchema, {\n\t\t\t\t\t\tmodules,\n\t\t\t\t\t\tmodels,\n\t\t\t\t\t\tadditionalProperties,\n\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\tnormalize,\n\t\t\t\t\t\tcoerce: false,\n\t\t\t\t\t\tadditionalCoerce: [],\n\t\t\t\t\t\tvalidators: validators.map((x) => x![+status]),\n\t\t\t\t\t\tsanitize\n\t\t\t\t\t})\n\t\t\t\t: maybeNameOrSchema\n\t})\n\n\treturn record\n}\n\nlet _stringToStructureCoercions: ReplaceSchemaTypeOptions[]\n\nexport const stringToStructureCoercions = () => {\n\tif (!_stringToStructureCoercions) {\n\t\t_stringToStructureCoercions = [\n\t\t\t{\n\t\t\t\tfrom: t.Object({}),\n\t\t\t\tto: () => t.ObjectString({}),\n\t\t\t\texcludeRoot: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tfrom: t.Array(t.Any()),\n\t\t\t\tto: () => t.ArrayString(t.Any())\n\t\t\t}\n\t\t] satisfies ReplaceSchemaTypeOptions[]\n\t}\n\n\treturn _stringToStructureCoercions\n}\n\nlet _coercePrimitiveRoot: ReplaceSchemaTypeOptions[]\n\nexport const coercePrimitiveRoot = () => {\n\tif (!_coercePrimitiveRoot)\n\t\t_coercePrimitiveRoot = [\n\t\t\t{\n\t\t\t\tfrom: t.Number(),\n\t\t\t\tto: (options) => t.Numeric(options),\n\t\t\t\trootOnly: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tfrom: t.Boolean(),\n\t\t\t\tto: (options) => t.BooleanString(options),\n\t\t\t\trootOnly: true\n\t\t\t}\n\t\t] satisfies ReplaceSchemaTypeOptions[]\n\n\treturn _coercePrimitiveRoot\n}\n\nexport const getCookieValidator = ({\n\tvalidator,\n\tmodules,\n\tdefaultConfig = {},\n\tconfig,\n\tdynamic,\n\tmodels,\n\tvalidators,\n\tsanitize\n}: {\n\tvalidator: TSchema | string | undefined\n\tmodules: TModule<any, any>\n\tdefaultConfig: CookieOptions | undefined\n\tconfig: CookieOptions\n\tdynamic: boolean\n\tmodels: Record<string, TSchema> | undefined\n\tvalidators?: InputSchema['cookie'][]\n\tsanitize?: () => ExactMirrorInstruction['sanitize']\n}) => {\n\tlet cookieValidator = getSchemaValidator(validator, {\n\t\tmodules,\n\t\tdynamic,\n\t\tmodels,\n\t\tadditionalProperties: true,\n\t\tcoerce: true,\n\t\tadditionalCoerce: stringToStructureCoercions(),\n\t\tvalidators,\n\t\tsanitize\n\t})\n\n\tif (cookieValidator)\n\t\tcookieValidator.config = mergeCookie(cookieValidator.config, config)\n\telse {\n\t\tcookieValidator = getSchemaValidator(t.Cookie(t.Any()), {\n\t\t\tmodules,\n\t\t\tdynamic,\n\t\t\tmodels,\n\t\t\tadditionalProperties: true,\n\t\t\tvalidators,\n\t\t\tsanitize\n\t\t})\n\n\t\tcookieValidator.config = defaultConfig\n\t}\n\n\treturn cookieValidator\n}\n\n/**\n * This function will return the type of unioned if all unioned type is the same.\n * It's intent to use for content-type mapping only\n *\n * ```ts\n * t.Union([\n *   t.Object({\n *     password: t.String()\n *   }),\n *   t.Object({\n *     token: t.String()\n *   })\n * ])\n * ```\n */\n// const getUnionedType = (validator: TypeCheck<any> | undefined) => {\n// \tif (!validator) return\n\n// \t// @ts-ignore\n// \tconst schema = validator?.schema ?? validator\n\n// \tif (schema && 'anyOf' in schema) {\n// \t\tlet foundDifference = false\n// \t\tconst type: string = schema.anyOf[0].type\n\n// \t\tfor (const validator of schema.anyOf as { type: string }[]) {\n// \t\t\tif (validator.type !== type) {\n// \t\t\t\tfoundDifference = true\n// \t\t\t\tbreak\n// \t\t\t}\n// \t\t}\n\n// \t\tif (!foundDifference) return type\n// \t}\n\n// \t// @ts-ignore\n// \treturn validator.schema?.type\n// }\n",
    "// src/index.ts\nimport { TypeCompiler } from \"@sinclair/typebox/compiler\";\nvar Kind = Symbol.for(\"TypeBox.Kind\");\nvar Hint = Symbol.for(\"TypeBox.Hint\");\nvar isSpecialProperty = (name) => /(\\ |-|\\t|\\n)/.test(name);\nvar joinProperty = (v1, v2, isOptional = false) => {\n  if (typeof v2 === \"number\") return `${v1}[${v2}]`;\n  if (isSpecialProperty(v2)) return `${v1}${isOptional ? \"?.\" : \"\"}[\"${v2}\"]`;\n  return `${v1}${isOptional ? \"?\" : \"\"}.${v2}`;\n};\nvar encodeProperty = (v) => isSpecialProperty(v) ? `\"${v}\"` : v;\nvar sanitize = (key, sanitize2 = 0, schema) => {\n  if (schema.type !== \"string\" || schema.const || schema.trusted) return key;\n  let hof = \"\";\n  for (let i = sanitize2 - 1; i >= 0; i--) hof += `d.h${i}(`;\n  return hof + key + \")\".repeat(sanitize2);\n};\nvar mergeObjectIntersection = (schema) => {\n  if (!schema.allOf || Kind in schema && (schema[Kind] !== \"Intersect\" || schema.type !== \"object\"))\n    return schema;\n  const { allOf, ...newSchema } = schema;\n  newSchema.properties = {};\n  if (Kind in newSchema) newSchema[Kind] = \"Object\";\n  for (const type of allOf) {\n    if (type.type !== \"object\") continue;\n    const { properties, required, type: _, [Kind]: __, ...rest } = type;\n    if (required)\n      newSchema.required = newSchema.required ? newSchema.required.concat(required) : required;\n    Object.assign(newSchema, rest);\n    for (const property in type.properties)\n      newSchema.properties[property] = mergeObjectIntersection(\n        type.properties[property]\n      );\n  }\n  return newSchema;\n};\nvar handleRecord = (schema, property, instruction) => {\n  const child = schema.patternProperties[\"^(.*)$\"] ?? schema.patternProperties[Object.keys(schema.patternProperties)[0]];\n  if (!child) return property;\n  const i = instruction.array;\n  instruction.array++;\n  return `(()=>{const ar${i}s=Object.keys(${property}),ar${i}v={};for(let i=0;i<ar${i}s.length;i++){const ar${i}p=${property}[ar${i}s[i]];ar${i}v[ar${i}s[i]]=${mirror(child, `ar${i}p`, instruction)}}return ar${i}v})()`;\n};\nvar handleTuple = (schema, property, instruction) => {\n  const i = instruction.array;\n  instruction.array++;\n  const isRoot = property === \"v\" && !instruction.unions.length;\n  let v = \"\";\n  if (!isRoot) v = `(()=>{`;\n  v += `const ar${i}v=[`;\n  for (let i2 = 0; i2 < schema.length; i2++) {\n    if (i2 !== 0) v += \",\";\n    v += mirror(\n      schema[i2],\n      joinProperty(property, i2, instruction.parentIsOptional),\n      instruction\n    );\n  }\n  v += `];`;\n  if (!isRoot) v += `return ar${i}v})()`;\n  return v;\n};\nfunction deepClone(source, weak = /* @__PURE__ */ new WeakMap()) {\n  if (source === null || typeof source !== \"object\" || typeof source === \"function\")\n    return source;\n  if (weak.has(source)) return weak.get(source);\n  if (Array.isArray(source)) {\n    const copy = new Array(source.length);\n    weak.set(source, copy);\n    for (let i = 0; i < source.length; i++)\n      copy[i] = deepClone(source[i], weak);\n    return copy;\n  }\n  if (typeof source === \"object\") {\n    const keys = Object.keys(source).concat(\n      Object.getOwnPropertySymbols(source)\n    );\n    const cloned = {};\n    for (const key of keys)\n      cloned[key] = deepClone(source[key], weak);\n    return cloned;\n  }\n  return source;\n}\nvar handleUnion = (schemas, property, instruction) => {\n  if (instruction.TypeCompiler === void 0) {\n    if (!instruction.typeCompilerWanred) {\n      console.warn(\n        new Error(\n          \"[exact-mirror] TypeBox's TypeCompiler is required to use Union\"\n        )\n      );\n      instruction.typeCompilerWanred = true;\n    }\n    return property;\n  }\n  instruction.unionKeys[property] = 1;\n  const ui = instruction.unions.length;\n  const typeChecks = instruction.unions[ui] = [];\n  let v = `(()=>{\n`;\n  const unwrapRef = (type) => {\n    if (!(Kind in type) || !type.$ref) return type;\n    if (type[Kind] === \"This\") {\n      return deepClone(instruction.definitions[type.$ref]);\n    } else if (type[Kind] === \"Ref\") {\n      if (!instruction.modules)\n        console.warn(\n          new Error(\n            \"[exact-mirror] modules is required when using nested cyclic reference\"\n          )\n        );\n      else\n        return instruction.modules.Import(\n          type.$ref\n        );\n    }\n    return type;\n  };\n  for (let i = 0; i < schemas.length; i++) {\n    let type = unwrapRef(schemas[i]);\n    if (Array.isArray(type.anyOf))\n      for (let i2 = 0; i2 < type.anyOf.length; i2++)\n        type.anyOf[i2] = unwrapRef(type.anyOf[i2]);\n    else if (type.items) {\n      if (Array.isArray(type.items))\n        for (let i2 = 0; i2 < type.items.length; i2++)\n          type.items[i2] = unwrapRef(type.items[i2]);\n      else type.items = unwrapRef(type.items);\n    }\n    typeChecks.push(TypeCompiler.Compile(type));\n    v += `if(d.unions[${ui}][${i}].Check(${property})){return ${mirror(\n      type,\n      property,\n      {\n        ...instruction,\n        recursion: instruction.recursion + 1,\n        parentIsOptional: true\n      }\n    )}}\n`;\n  }\n  v += `return ${instruction.removeUnknownUnionType ? \"undefined\" : property}})()`;\n  return v;\n};\nvar mirror = (schema, property, instruction) => {\n  if (!schema) return \"\";\n  const isRoot = property === \"v\" && !instruction.unions.length;\n  if (Kind in schema && schema[Kind] === \"Import\" && schema.$ref in schema.$defs)\n    return mirror(schema.$defs[schema.$ref], property, {\n      ...instruction,\n      definitions: Object.assign(instruction.definitions, schema.$defs)\n    });\n  if (isRoot && schema.type !== \"object\" && schema.type !== \"array\" && !schema.anyOf)\n    return `return ${sanitize(\"v\", instruction.sanitize?.length, schema)}`;\n  if (instruction.recursion >= instruction.recursionLimit) return property;\n  let v = \"\";\n  if (schema.$id && Hint in schema)\n    instruction.definitions[schema.$id] = schema;\n  switch (schema.type) {\n    case \"object\":\n      if (schema[Kind] === \"Record\") {\n        v = handleRecord(schema, property, instruction);\n        break;\n      }\n      schema = mergeObjectIntersection(schema);\n      v += \"{\";\n      if (schema.additionalProperties) v += `...${property}`;\n      const keys = Object.keys(schema.properties);\n      for (let i2 = 0; i2 < keys.length; i2++) {\n        const key = keys[i2];\n        let isOptional = schema.required && !schema.required.includes(key) || Array.isArray(schema.properties[key].anyOf);\n        const name = joinProperty(\n          property,\n          key,\n          instruction.parentIsOptional\n        );\n        if (isOptional) {\n          const index = instruction.array;\n          if (property.startsWith(\"ar\")) {\n            const refName = name.slice(name.indexOf(\".\") + 1);\n            const array = instruction.optionalsInArray;\n            if (array[index]) array[index].push(refName);\n            else array[index] = [refName];\n          } else {\n            instruction.optionals.push(name);\n          }\n        }\n        const child = schema.properties[key];\n        if (schema.additionalProperties && child.type !== \"object\")\n          continue;\n        if (i2 !== 0) v += \",\";\n        v += `${encodeProperty(key)}:${isOptional ? `${name}===undefined?undefined:` : \"\"}${mirror(\n          child,\n          name,\n          {\n            ...instruction,\n            recursion: instruction.recursion + 1,\n            parentIsOptional: isOptional\n          }\n        )}`;\n      }\n      v += \"}\";\n      break;\n    case \"array\":\n      if (schema.items.type !== \"object\" && schema.items.type !== \"array\") {\n        if (Array.isArray(schema.items)) {\n          v = handleTuple(schema.items, property, instruction);\n          break;\n        } else if (isRoot) return \"return v\";\n        else if (Kind in schema.items && schema.items.$ref && (schema.items[Kind] === \"Ref\" || schema.items[Kind] === \"This\"))\n          v = mirror(\n            deepClone(instruction.definitions[schema.items.$ref]),\n            property,\n            {\n              ...instruction,\n              parentIsOptional: true,\n              recursion: instruction.recursion + 1\n            }\n          );\n        else {\n          v = property;\n          break;\n        }\n      }\n      const i = instruction.array;\n      instruction.array++;\n      let reference = property;\n      if (isRoot) v = `const ar${i}v=new Array(${property}.length);`;\n      else {\n        reference = `ar${i}s`;\n        v = `((${reference})=>{const ar${i}v=new Array(${reference}.length);`;\n      }\n      v += `for(let i=0;i<${reference}.length;i++){const ar${i}p=${reference}[i];ar${i}v[i]=${mirror(schema.items, `ar${i}p`, instruction)}`;\n      const optionals = instruction.optionalsInArray[i + 1];\n      if (optionals) {\n        for (let oi = 0; oi < optionals.length; oi++) {\n          const target = `ar${i}v[i].${optionals[oi]}`;\n          v += `;if(${target}===undefined)delete ${target}`;\n        }\n      }\n      v += `}`;\n      if (!isRoot) v += `return ar${i}v})(${property})`;\n      break;\n    default:\n      if (schema.$ref && schema.$ref in instruction.definitions)\n        return mirror(\n          instruction.definitions[schema.$ref],\n          property,\n          instruction\n        );\n      if (Array.isArray(schema.anyOf)) {\n        v = handleUnion(schema.anyOf, property, instruction);\n        break;\n      }\n      v = sanitize(property, instruction.sanitize?.length, schema);\n      break;\n  }\n  if (!isRoot) return v;\n  if (schema.type === \"array\") return `${v}return ar0v`;\n  v = `const x=${v}\n`;\n  for (let i = 0; i < instruction.optionals.length; i++) {\n    const key = instruction.optionals[i];\n    const prop = key.slice(1);\n    v += `if(${key}===undefined`;\n    if (instruction.unionKeys[key]) v += `||x${prop}===undefined`;\n    v += `)delete x${prop.charCodeAt(0) !== 63 ? \"?\" : \"\"}${prop}\n`;\n  }\n  return `${v}return x`;\n};\nvar createMirror = (schema, {\n  TypeCompiler: TypeCompiler2,\n  modules,\n  definitions,\n  sanitize: sanitize2,\n  recursionLimit = 8,\n  removeUnknownUnionType = false\n} = {}) => {\n  const unions = [];\n  if (typeof sanitize2 === \"function\") sanitize2 = [sanitize2];\n  const f = mirror(schema, \"v\", {\n    optionals: [],\n    optionalsInArray: [],\n    array: 0,\n    parentIsOptional: false,\n    unions,\n    unionKeys: {},\n    TypeCompiler: TypeCompiler2,\n    modules,\n    // @ts-ignore private property\n    definitions: definitions ?? modules?.$defs ?? {},\n    sanitize: sanitize2,\n    recursion: 0,\n    recursionLimit,\n    removeUnknownUnionType\n  });\n  if (!unions.length && !sanitize2?.length) return Function(\"v\", f);\n  let hof;\n  if (sanitize2?.length) {\n    hof = {};\n    for (let i = 0; i < sanitize2.length; i++) hof[`h${i}`] = sanitize2[i];\n  }\n  return Function(\n    \"d\",\n    `return function mirror(v){${f}}`\n  )({\n    unions,\n    ...hof\n  });\n};\nvar index_default = createMirror;\nexport {\n  createMirror,\n  deepClone,\n  index_default as default,\n  mergeObjectIntersection\n};\n",
    "// Similar to adapter/web-standard/handler but\n// string case is omitted header out\n// (this has a significant performance difference on Bun)\n\n/* eslint-disable sonarjs/no-nested-switch */\n/* eslint-disable sonarjs/no-duplicate-string */\nimport {\n\tcreateResponseHandler,\n\tcreateStreamHandler,\n\thandleFile,\n\thandleSet,\n\tresponseToSetHeaders,\n\tstreamResponse\n} from '../utils'\n\nimport { ElysiaFile } from '../../universal/file'\nimport { isNotEmpty } from '../../utils'\nimport { Cookie } from '../../cookies'\nimport { ElysiaCustomStatusResponse } from '../../error'\n\nimport type { Context } from '../../context'\nimport type { AnyLocalHook } from '../../types'\n\nexport const mapResponse = (\n\tresponse: unknown,\n\tset: Context['set'],\n\trequest?: Request\n): Response => {\n\tif (isNotEmpty(set.headers) || set.status !== 200 || set.cookie) {\n\t\thandleSet(set)\n\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string, set as any)\n\n\t\t\tcase 'Array':\n\t\t\tcase 'Object':\n\t\t\t\tset.headers['content-type'] = 'application/json'\n\t\t\t\treturn new Response(JSON.stringify(response), set as any)\n\n\t\t\tcase 'ElysiaFile':\n\t\t\t\treturn handleFile((response as ElysiaFile).value as File)\n\n\t\t\tcase 'File':\n\t\t\t\treturn handleFile(response as File, set as any)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as Blob, set as any)\n\n\t\t\tcase 'ElysiaCustomStatusResponse':\n\t\t\t\tset.status = (response as ElysiaCustomStatusResponse<200>).code\n\n\t\t\t\treturn mapResponse(\n\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\tset,\n\t\t\t\t\trequest\n\t\t\t\t)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\tif (\n\t\t\t\t\t!set.headers['content-type']?.startsWith(\n\t\t\t\t\t\t'text/event-stream'\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\tset.headers['content-type'] =\n\t\t\t\t\t\t'text/event-stream; charset=utf-8'\n\n\t\t\t\trequest?.signal?.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t{\n\t\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\t\tif (request?.signal && !request?.signal?.aborted)\n\t\t\t\t\t\t\t\t(response as ReadableStream).cancel()\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn new Response(response as ReadableStream, set as any)\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('', set as any)\n\n\t\t\t\treturn new Response(JSON.stringify(response), set as any)\n\n\t\t\tcase 'Response':\n\t\t\t\treturn handleResponse(response as Response, set, request)\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Promise':\n\t\t\t\treturn (response as Promise<any>).then((x) =>\n\t\t\t\t\tmapResponse(x, set, request)\n\t\t\t\t) as any\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapResponse((response as Function)(), set, request)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response(\n\t\t\t\t\t(response as number | boolean).toString(),\n\t\t\t\t\tset as any\n\t\t\t\t)\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as any)\n\n\t\t\t\treturn new Response(response?.toString(), set as any)\n\n\t\t\tcase 'FormData':\n\t\t\t\treturn new Response(response as FormData, set as any)\n\n\t\t\tdefault:\n\t\t\t\t// recheck Response, Promise, Error because some library may extends Response\n\t\t\t\tif (response instanceof Response)\n\t\t\t\t\treturn handleResponse(response as Response, set, request)\n\n\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\treturn response.then((x) => mapResponse(x, set)) as any\n\n\t\t\t\tif (response instanceof Error)\n\t\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\t\tif (response instanceof ElysiaCustomStatusResponse) {\n\t\t\t\t\tset.status = (\n\t\t\t\t\t\tresponse as ElysiaCustomStatusResponse<200>\n\t\t\t\t\t).code\n\n\t\t\t\t\treturn mapResponse(\n\t\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\t\tset,\n\t\t\t\t\t\trequest\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.next === 'function')\n\t\t\t\t\treturn handleStream(response as any, set, request) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.then === 'function')\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\treturn response.then((x) => mapResponse(x, set)) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.toResponse === 'function')\n\t\t\t\t\treturn mapResponse((response as any).toResponse(), set)\n\n\t\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t\tset as any\n\t\t\t\t\t\t) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as any, set as any)\n\t\t}\n\t}\n\n\tif (\n\t\tresponse instanceof Response &&\n\t\t!(response as Response).headers.has('content-length') &&\n\t\t(response as Response).headers.get('transfer-encoding') === 'chunked'\n\t)\n\t\treturn handleStream(\n\t\t\tstreamResponse(response),\n\t\t\tresponseToSetHeaders(response as Response, set),\n\t\t\trequest\n\t\t) as any\n\n\t// Stream response defers a 'set' API, assume that it may include 'set'\n\tif (\n\t\t// @ts-expect-error\n\t\ttypeof response?.next === 'function' ||\n\t\tresponse instanceof ReadableStream\n\t)\n\t\treturn handleStream(response as any, set, request) as any\n\n\treturn mapCompactResponse(response, request)\n}\n\nexport const mapEarlyResponse = (\n\tresponse: unknown,\n\tset: Context['set'],\n\trequest?: Request\n): Response | undefined => {\n\tif (response === undefined || response === null) return\n\n\tif (isNotEmpty(set.headers) || set.status !== 200 || set.cookie) {\n\t\thandleSet(set)\n\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string, set as any)\n\n\t\t\tcase 'Array':\n\t\t\tcase 'Object':\n\t\t\t\tset.headers['content-type'] = 'application/json'\n\t\t\t\treturn new Response(JSON.stringify(response), set as any)\n\n\t\t\tcase 'ElysiaFile':\n\t\t\t\treturn handleFile((response as ElysiaFile).value as File)\n\n\t\t\tcase 'File':\n\t\t\t\treturn handleFile(response as File, set as any)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'ElysiaCustomStatusResponse':\n\t\t\t\tset.status = (response as ElysiaCustomStatusResponse<200>).code\n\n\t\t\t\treturn mapEarlyResponse(\n\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\tset,\n\t\t\t\t\trequest\n\t\t\t\t)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\tif (\n\t\t\t\t\t!set.headers['content-type']?.startsWith(\n\t\t\t\t\t\t'text/event-stream'\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\tset.headers['content-type'] =\n\t\t\t\t\t\t'text/event-stream; charset=utf-8'\n\n\t\t\t\trequest?.signal?.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t{\n\t\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\t\tif (request?.signal && !request?.signal?.aborted)\n\t\t\t\t\t\t\t\t(response as ReadableStream).cancel()\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn new Response(response as ReadableStream, set as any)\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return\n\n\t\t\t\treturn new Response(JSON.stringify(response), set as any)\n\n\t\t\tcase 'Response':\n\t\t\t\treturn handleResponse(response as Response, set, request)\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as Promise<unknown>).then((x) =>\n\t\t\t\t\tmapEarlyResponse(x, set)\n\t\t\t\t)\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapEarlyResponse((response as Function)(), set)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response(\n\t\t\t\t\t(response as number | boolean).toString(),\n\t\t\t\t\tset as any\n\t\t\t\t)\n\n\t\t\tcase 'FormData':\n\t\t\t\treturn new Response(response as FormData)\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as any)\n\n\t\t\t\treturn new Response(response?.toString(), set as any)\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response)\n\t\t\t\t\treturn handleResponse(response, set, request)\n\n\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\treturn response.then((x) => mapEarlyResponse(x, set)) as any\n\n\t\t\t\tif (response instanceof Error)\n\t\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\t\tif (response instanceof ElysiaCustomStatusResponse) {\n\t\t\t\t\tset.status = (\n\t\t\t\t\t\tresponse as ElysiaCustomStatusResponse<200>\n\t\t\t\t\t).code\n\n\t\t\t\t\treturn mapEarlyResponse(\n\t\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\t\tset,\n\t\t\t\t\t\trequest\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.next === 'function')\n\t\t\t\t\treturn handleStream(response as any, set, request) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.then === 'function')\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\treturn response.then((x) => mapEarlyResponse(x, set)) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.toResponse === 'function')\n\t\t\t\t\treturn mapEarlyResponse((response as any).toResponse(), set)\n\n\t\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t\tset as any\n\t\t\t\t\t\t) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as any, set as any)\n\t\t}\n\t} else\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string)\n\n\t\t\tcase 'Array':\n\t\t\tcase 'Object':\n\t\t\t\tset.headers['content-type'] = 'application/json'\n\t\t\t\treturn new Response(JSON.stringify(response), set as any)\n\n\t\t\tcase 'ElysiaFile':\n\t\t\t\treturn handleFile((response as ElysiaFile).value as File)\n\n\t\t\tcase 'File':\n\t\t\t\treturn handleFile(response as File, set as any)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'ElysiaCustomStatusResponse':\n\t\t\t\tset.status = (response as ElysiaCustomStatusResponse<200>).code\n\n\t\t\t\treturn mapEarlyResponse(\n\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\tset,\n\t\t\t\t\trequest\n\t\t\t\t)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\trequest?.signal?.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t{\n\t\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\t\tif (request?.signal && !request?.signal?.aborted)\n\t\t\t\t\t\t\t\t(response as ReadableStream).cancel()\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('')\n\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'Response':\n\t\t\t\tif (\n\t\t\t\t\t!(response as Response).headers.has('content-length') &&\n\t\t\t\t\t(response as Response).headers.get('transfer-encoding') ===\n\t\t\t\t\t\t'chunked'\n\t\t\t\t)\n\t\t\t\t\treturn handleStream(\n\t\t\t\t\t\tstreamResponse(response as Response),\n\t\t\t\t\t\tresponseToSetHeaders(response as Response),\n\t\t\t\t\t\trequest\n\t\t\t\t\t) as any\n\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapEarlyResponse(x, set)\n\t\t\t\t\tif (r !== undefined) return r\n\t\t\t\t})\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapCompactResponse((response as Function)(), request)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as any)\n\n\t\t\t\treturn new Response(response?.toString(), set as any)\n\n\t\t\tcase 'FormData':\n\t\t\t\treturn new Response(response as FormData)\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response) return response\n\n\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\treturn response.then((x) => mapEarlyResponse(x, set)) as any\n\n\t\t\t\tif (response instanceof Error)\n\t\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\t\tif (response instanceof ElysiaCustomStatusResponse) {\n\t\t\t\t\tset.status = (\n\t\t\t\t\t\tresponse as ElysiaCustomStatusResponse<200>\n\t\t\t\t\t).code\n\n\t\t\t\t\treturn mapEarlyResponse(\n\t\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\t\tset,\n\t\t\t\t\t\trequest\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.next === 'function')\n\t\t\t\t\treturn handleStream(response as any, set, request) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.then === 'function')\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\treturn response.then((x) => mapEarlyResponse(x, set)) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.toResponse === 'function')\n\t\t\t\t\treturn mapEarlyResponse((response as any).toResponse(), set)\n\n\t\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t\tset as any\n\t\t\t\t\t\t) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as any)\n\t\t}\n}\n\nexport const mapCompactResponse = (\n\tresponse: unknown,\n\trequest?: Request\n): Response => {\n\tswitch (response?.constructor?.name) {\n\t\tcase 'String':\n\t\t\treturn new Response(response as string)\n\n\t\tcase 'Object':\n\t\tcase 'Array':\n\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase 'ElysiaFile':\n\t\t\treturn handleFile((response as ElysiaFile).value as File)\n\n\t\tcase 'File':\n\t\t\treturn handleFile(response as File)\n\n\t\tcase 'Blob':\n\t\t\treturn handleFile(response as File | Blob)\n\n\t\tcase 'ElysiaCustomStatusResponse':\n\t\t\treturn mapResponse(\n\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t{\n\t\t\t\t\tstatus: (response as ElysiaCustomStatusResponse<200>).code,\n\t\t\t\t\theaders: {}\n\t\t\t\t}\n\t\t\t)\n\n\t\tcase 'ReadableStream':\n\t\t\trequest?.signal?.addEventListener(\n\t\t\t\t'abort',\n\t\t\t\t{\n\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\tif (request?.signal && !request?.signal?.aborted)\n\t\t\t\t\t\t\t(response as ReadableStream).cancel()\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tonce: true\n\t\t\t\t}\n\t\t\t)\n\n\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase undefined:\n\t\t\tif (!response) return new Response('')\n\n\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\theaders: {\n\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase 'Response':\n\t\t\tif (\n\t\t\t\t(response as Response).headers.get('transfer-encoding') ===\n\t\t\t\t'chunked'\n\t\t\t)\n\t\t\t\treturn handleStream(\n\t\t\t\t\tstreamResponse(response as Response),\n\t\t\t\t\tresponseToSetHeaders(response as Response),\n\t\t\t\t\trequest\n\t\t\t\t) as any\n\n\t\t\treturn response as Response\n\n\t\tcase 'Error':\n\t\t\treturn errorToResponse(response as Error)\n\n\t\tcase 'Promise':\n\t\t\treturn (response as any as Promise<unknown>).then((x) =>\n\t\t\t\tmapCompactResponse(x, request)\n\t\t\t) as any\n\n\t\t// ? Maybe response or Blob\n\t\tcase 'Function':\n\t\t\treturn mapCompactResponse((response as Function)(), request)\n\n\t\tcase 'Number':\n\t\tcase 'Boolean':\n\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\tcase 'FormData':\n\t\t\treturn new Response(response as FormData)\n\n\t\tdefault:\n\t\t\tif (response instanceof Response) return response\n\n\t\t\tif (response instanceof Promise)\n\t\t\t\treturn response.then((x) =>\n\t\t\t\t\tmapCompactResponse(x, request)\n\t\t\t\t) as any\n\n\t\t\tif (response instanceof Error)\n\t\t\t\treturn errorToResponse(response as Error)\n\n\t\t\tif (response instanceof ElysiaCustomStatusResponse)\n\t\t\t\treturn mapResponse(\n\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\t{\n\t\t\t\t\t\tstatus: (response as ElysiaCustomStatusResponse<200>)\n\t\t\t\t\t\t\t.code,\n\t\t\t\t\t\theaders: {}\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t// @ts-expect-error\n\t\t\tif (typeof response?.next === 'function')\n\t\t\t\treturn handleStream(response as any, undefined, request) as any\n\n\t\t\t// @ts-expect-error\n\t\t\tif (typeof response?.then === 'function')\n\t\t\t\t// @ts-expect-error\n\t\t\t\treturn response.then((x) => mapResponse(x, set)) as any\n\n\t\t\t// @ts-expect-error\n\t\t\tif (typeof response?.toResponse === 'function')\n\t\t\t\treturn mapCompactResponse((response as any).toResponse())\n\n\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t}\n\t\t\t\t\t}) as any\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new Response(response as any)\n\t}\n}\n\nexport const errorToResponse = (error: Error, set?: Context['set']) =>\n\tnew Response(\n\t\tJSON.stringify({\n\t\t\tname: error?.name,\n\t\t\tmessage: error?.message,\n\t\t\tcause: error?.cause\n\t\t}),\n\t\t{\n\t\t\tstatus:\n\t\t\t\tset?.status !== 200 ? ((set?.status as number) ?? 500) : 500,\n\t\t\theaders: set?.headers as any\n\t\t}\n\t)\n\nexport const createStaticHandler = (\n\thandle: unknown,\n\thooks: Partial<AnyLocalHook>,\n\tsetHeaders: Context['set']['headers'] = {}\n): (() => Response) | undefined => {\n\tif (typeof handle === 'function') return\n\n\tconst response = mapResponse(handle, {\n\t\theaders: setHeaders\n\t})\n\n\tif (\n\t\t!hooks.parse?.length &&\n\t\t!hooks.transform?.length &&\n\t\t!hooks.beforeHandle?.length &&\n\t\t!hooks.afterHandle?.length\n\t)\n\t\treturn response.clone.bind(response) as any\n}\n\nconst handleResponse = createResponseHandler({\n\tmapResponse,\n\tmapCompactResponse\n})\n\nconst handleStream = createStreamHandler({\n\tmapResponse,\n\tmapCompactResponse\n})\n",
    "import { sucrose, type Sucrose } from '../../sucrose'\nimport { createHoc, createOnRequestHandler, isAsync } from '../../compose'\n\nimport { randomId, ELYSIA_REQUEST_ID, redirect, isNotEmpty } from '../../utils'\nimport { status } from '../../error'\nimport { ELYSIA_TRACE } from '../../trace'\n\nimport type { AnyElysia } from '../..'\nimport type { InternalRoute } from '../../types'\nimport { mapEarlyResponse } from './handler'\n\nconst allocateIf = (value: string, condition: unknown) =>\n\tcondition ? value : ''\n\nconst createContext = (\n\tapp: AnyElysia,\n\troute: InternalRoute,\n\tinference: Sucrose.Inference,\n\tisInline = false\n) => {\n\tlet fnLiteral = ''\n\n\t// @ts-expect-error private\n\tconst defaultHeaders = app.setHeaders\n\n\tconst hasTrace = !!app.event.trace?.length\n\tif (hasTrace) fnLiteral += `const id=randomId()\\n`\n\n\tconst isDynamic = /[:*]/.test(route.path)\n\n\tconst standardHostname = app.config.handler?.standardHostname ?? true\n\n\tconst getQi =\n\t\t`const u=request.url,` +\n\t\t`s=u.indexOf('/',${standardHostname ? 11 : 7}),` +\n\t\t`qi=u.indexOf('?', s + 1)\\n`\n\n\tif (inference.query) fnLiteral += getQi\n\n\tconst getPath = !inference.path\n\t\t? ''\n\t\t: !isDynamic\n\t\t\t? `path:'${route.path}',`\n\t\t\t: `get path(){` +\n\t\t\t\t(inference.query ? '' : getQi) +\n\t\t\t\t`if(qi===-1)return u.substring(s)\\n` +\n\t\t\t\t`return u.substring(s,qi)\\n` +\n\t\t\t\t`},`\n\n\tfnLiteral +=\n\t\tallocateIf(`const c=`, !isInline) +\n\t\t`{request,` +\n\t\t`store,` +\n\t\tallocateIf(`qi,`, inference.query) +\n\t\tallocateIf(`params:request.params,`, isDynamic) +\n\t\tgetPath +\n\t\tallocateIf(\n\t\t\t`url:request.url,`,\n\t\t\thasTrace || inference.url || inference.query\n\t\t) +\n\t\t`redirect,` +\n\t\t`error:status,` +\n\t\t`status,` +\n\t\t`set:{headers:` +\n\t\t(isNotEmpty(defaultHeaders)\n\t\t\t? 'Object.assign({},app.setHeaders)'\n\t\t\t: 'Object.create(null)') +\n\t\t`,status:200}`\n\n\tif (inference.server) fnLiteral += `,get server(){return app.getServer()}`\n\n\tif (hasTrace) fnLiteral += ',[ELYSIA_REQUEST_ID]:id'\n\n\t{\n\t\tlet decoratorsLiteral = ''\n\t\t// @ts-expect-error private\n\t\tfor (const key of Object.keys(app.singleton.decorator))\n\t\t\tdecoratorsLiteral += `,'${key}':decorator['${key}']`\n\n\t\tfnLiteral += decoratorsLiteral\n\t}\n\n\tfnLiteral += `}\\n`\n\n\treturn fnLiteral\n}\n\nexport const createBunRouteHandler = (app: AnyElysia, route: InternalRoute) => {\n\tconst hasTrace = !!app.event.trace?.length\n\t// @ts-expect-error private property\n\tconst hasHoc = !!app.extender.higherOrderFunctions.length\n\n\tlet inference = sucrose(\n\t\troute.hooks,\n\t\t// @ts-expect-error\n\t\tapp.inference\n\t)\n\tinference = sucrose(\n\t\t{\n\t\t\thandler: route.handler\n\t\t},\n\t\tinference\n\t)\n\n\tlet fnLiteral =\n\t\t'const handler=data.handler,' +\n\t\t`app=data.app,` +\n\t\t'store=data.store,' +\n\t\t`decorator=data.decorator,` +\n\t\t'redirect=data.redirect,' +\n\t\t'route=data.route,' +\n\t\t'mapEarlyResponse=data.mapEarlyResponse,' +\n\t\tallocateIf('randomId=data.randomId,', hasTrace) +\n\t\tallocateIf(`ELYSIA_REQUEST_ID=data.ELYSIA_REQUEST_ID,`, hasTrace) +\n\t\tallocateIf(`ELYSIA_TRACE=data.ELYSIA_TRACE,`, hasTrace) +\n\t\tallocateIf(`trace=data.trace,`, hasTrace) +\n\t\tallocateIf(`hoc=data.hoc,`, hasHoc) +\n\t\t'status=data.status\\n'\n\n\tif (app.event.request?.length)\n\t\tfnLiteral += `const onRequest=app.event.request.map(x=>x.fn)\\n`\n\n\tfnLiteral += `${app.event.request?.find(isAsync) ? 'async' : ''} function map(request){`\n\n\t// inference.query require declaring const 'qi'\n\tif (hasTrace || inference.query || app.event.request?.length) {\n\t\tfnLiteral += createContext(app, route, inference)\n\t\tfnLiteral += createOnRequestHandler(app)\n\n\t\tfnLiteral += 'return handler(c)}'\n\t} else\n\t\tfnLiteral += `return handler(${createContext(app, route, inference, true)})}`\n\n\tfnLiteral += createHoc(app)\n\n\treturn Function(\n\t\t'data',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\thandler: route.compile?.() ?? route.composed,\n\t\tredirect,\n\t\tstatus,\n\t\t// @ts-expect-error private property\n\t\thoc: app.extender.higherOrderFunctions.map((x) => x.fn),\n\t\tstore: app.store,\n\t\tdecorator: app.decorator,\n\t\troute: route.path,\n\t\trandomId: hasTrace ? randomId : undefined,\n\t\tELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined,\n\t\tELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined,\n\t\ttrace: hasTrace ? app.event.trace?.map((x) => x?.fn ?? x) : undefined,\n\t\tmapEarlyResponse: mapEarlyResponse\n\t})\n}\n",
    "import type { Context } from '../../context'\nimport type { AnyLocalHook, MaybePromise } from '../../types'\n\nimport { mapResponse } from './handler'\n\nexport const createNativeStaticHandler = (\n\thandle: unknown,\n\thooks: AnyLocalHook,\n\tsetHeaders: Context['set']['headers'] = {}\n): (() => MaybePromise<Response>) | undefined => {\n\tif (typeof handle === 'function' || handle instanceof Blob) return\n\n\tif (\n\t\ttypeof handle === 'object' &&\n\t\thandle?.toString() === '[object HTMLBundle]'\n\t)\n\t\t// Bun HTMLBundle\n\t\treturn () => handle as any\n\n\tconst response = mapResponse(handle, {\n\t\theaders: setHeaders\n\t})\n\n\tif (\n\t\t!hooks.parse?.length &&\n\t\t!hooks.transform?.length &&\n\t\t!hooks.beforeHandle?.length &&\n\t\t!hooks.afterHandle?.length\n\t) {\n\t\tif (response instanceof Promise)\n\t\t\treturn response.then((response) => {\n\t\t\t\tif (!response) return\n\n\t\t\t\tif (!response.headers.has('content-type'))\n\t\t\t\t\tresponse.headers.append('content-type', 'text/plain')\n\n\t\t\t\treturn response.clone()\n\t\t\t}) as any as () => Promise<Response>\n\n\t\tif (!response.headers.has('content-type'))\n\t\t\tresponse.headers.append('content-type', 'text/plain')\n\n\t\treturn response.clone.bind(response) as any\n\t}\n}\n",
    "import { isNumericString } from '../utils'\n\nimport type {\n\tServerWebSocket,\n\tServerWebSocketSendStatus,\n\tBufferSource,\n\tWebSocketHandler\n} from './bun'\n\nimport type { TSchema } from '@sinclair/typebox'\nimport type { TypeCheck } from '../type-system'\nimport type { ElysiaTypeCheck } from '../schema'\n\nimport type { FlattenResponse, WSParseHandler } from './types'\nimport type { MaybeArray, Prettify, RouteSchema } from '../types'\nimport { ValidationError } from '../error'\n\nexport const websocket: WebSocketHandler<any> = {\n\topen(ws) {\n\t\tws.data.open?.(ws)\n\t},\n\tmessage(ws, message) {\n\t\tws.data.message?.(ws, message)\n\t},\n\tdrain(ws) {\n\t\tws.data.drain?.(ws)\n\t},\n\tclose(ws, code, reason) {\n\t\tws.data.close?.(ws, code, reason)\n\t}\n}\n\ntype ElysiaServerWebSocket = Omit<\n\tServerWebSocket<unknown>,\n\t'send' | 'ping' | 'pong' | 'publish'\n>\n\nexport class ElysiaWS<Context = unknown, Route extends RouteSchema = {}>\n\timplements ElysiaServerWebSocket\n{\n\tvalidator?: TypeCheck<TSchema>;\n\t['~types']?: {\n\t\tvalidator: Prettify<Route>\n\t}\n\n\tget id() {\n\t\t// @ts-ignore\n\t\treturn this.data.id\n\t}\n\n\tconstructor(\n\t\tpublic raw: ServerWebSocket<{\n\t\t\tid?: string\n\t\t\tvalidator?: TypeCheck<TSchema>\n\t\t}>,\n\t\tpublic data: Prettify<\n\t\t\tOmit<Context, 'body' | 'error' | 'status' | 'redirect'>\n\t\t>,\n\t\tpublic body: Route['body'] = undefined\n\t) {\n\t\tthis.validator = raw.data?.validator\n\n\t\tthis.sendText = raw.sendText.bind(raw)\n\t\tthis.sendBinary = raw.sendBinary.bind(raw)\n\t\tthis.close = raw.close.bind(raw)\n\t\tthis.terminate = raw.terminate.bind(raw)\n\t\tthis.publishText = raw.publishText.bind(raw)\n\t\tthis.publishBinary = raw.publishBinary.bind(raw)\n\t\tthis.subscribe = raw.subscribe.bind(raw)\n\t\tthis.unsubscribe = raw.unsubscribe.bind(raw)\n\t\tthis.isSubscribed = raw.isSubscribed.bind(raw)\n\t\tthis.cork = raw.cork.bind(raw)\n\t\tthis.remoteAddress = raw.remoteAddress\n\t\tthis.binaryType = raw.binaryType\n\t\tthis.data = raw.data as any\n\n\t\tthis.send = this.send.bind(this)\n\t\tthis.ping = this.ping.bind(this)\n\t\tthis.pong = this.pong.bind(this)\n\t\tthis.publish = this.publish.bind(this)\n\t}\n\n\t/**\n\t * Sends a message to the client.\n\t *\n\t * @param data The data to send.\n\t * @param compress Should the data be compressed? If the client does not support compression, this is ignored.\n\t * @example\n\t * ws.send(\"Hello!\");\n\t * ws.send(\"Compress this.\", true);\n\t * ws.send(new Uint8Array([1, 2, 3, 4]));\n\t */\n\tsend(\n\t\tdata: FlattenResponse<Route['response']> | BufferSource,\n\t\tcompress?: boolean\n\t): ServerWebSocketSendStatus {\n\t\tif (Buffer.isBuffer(data))\n\t\t\treturn this.raw.send(data as unknown as BufferSource, compress)\n\n\t\tif (this.validator?.Check(data) === false)\n\t\t\treturn this.raw.send(\n\t\t\t\tnew ValidationError('message', this.validator, data).message\n\t\t\t)\n\n\t\tif (typeof data === 'object') data = JSON.stringify(data) as any\n\n\t\treturn this.raw.send(data as unknown as string, compress)\n\t}\n\n\t/**\n\t * Sends a ping.\n\t *\n\t * @param data The data to send\n\t */\n\tping(\n\t\tdata?: FlattenResponse<Route['response']> | BufferSource\n\t): ServerWebSocketSendStatus {\n\t\tif (Buffer.isBuffer(data))\n\t\t\treturn this.raw.ping(data as unknown as BufferSource)\n\n\t\tif (this.validator?.Check(data) === false)\n\t\t\treturn this.raw.send(\n\t\t\t\tnew ValidationError('message', this.validator, data).message\n\t\t\t)\n\n\t\tif (typeof data === 'object') data = JSON.stringify(data) as any\n\n\t\treturn this.raw.ping(data as string)\n\t}\n\n\t/**\n\t * Sends a pong.\n\t *\n\t * @param data The data to send\n\t */\n\tpong(\n\t\tdata?: FlattenResponse<Route['response']> | BufferSource\n\t): ServerWebSocketSendStatus {\n\t\tif (Buffer.isBuffer(data))\n\t\t\treturn this.raw.pong(data as unknown as BufferSource)\n\n\t\tif (this.validator?.Check(data) === false)\n\t\t\treturn this.raw.send(\n\t\t\t\tnew ValidationError('message', this.validator, data).message\n\t\t\t)\n\n\t\tif (typeof data === 'object') data = JSON.stringify(data) as any\n\n\t\treturn this.raw.pong(data as string)\n\t}\n\n\t/**\n\t * Sends a message to subscribers of the topic.\n\t *\n\t * @param topic The topic name.\n\t * @param data The data to send.\n\t * @param compress Should the data be compressed? If the client does not support compression, this is ignored.\n\t * @example\n\t * ws.publish(\"chat\", \"Hello!\");\n\t * ws.publish(\"chat\", \"Compress this.\", true);\n\t * ws.publish(\"chat\", new Uint8Array([1, 2, 3, 4]));\n\t */\n\tpublish(\n\t\ttopic: string,\n\t\tdata: FlattenResponse<Route['response']> | BufferSource,\n\t\tcompress?: boolean\n\t): ServerWebSocketSendStatus {\n\t\tif (Buffer.isBuffer(data))\n\t\t\treturn this.raw.publish(\n\t\t\t\ttopic,\n\t\t\t\tdata as unknown as BufferSource,\n\t\t\t\tcompress\n\t\t\t)\n\n\t\tif (this.validator?.Check(data) === false)\n\t\t\treturn this.raw.send(\n\t\t\t\tnew ValidationError('message', this.validator, data).message\n\t\t\t)\n\n\t\tif (typeof data === 'object') data = JSON.stringify(data) as any\n\n\t\treturn this.raw.publish(topic, data as unknown as string, compress)\n\t}\n\n\tsendText: ServerWebSocket['sendText']\n\tsendBinary: ServerWebSocket['sendBinary']\n\tclose: ServerWebSocket['close']\n\tterminate: ServerWebSocket['terminate']\n\tpublishText: ServerWebSocket['publishText']\n\tpublishBinary: ServerWebSocket['publishBinary']\n\tsubscribe: ServerWebSocket['subscribe']\n\tunsubscribe: ServerWebSocket['unsubscribe']\n\tisSubscribed: ServerWebSocket['isSubscribed']\n\tcork: ServerWebSocket['cork']\n\tremoteAddress: ServerWebSocket['remoteAddress']\n\tbinaryType: ServerWebSocket['binaryType']\n\n\tget readyState() {\n\t\treturn this.raw.readyState\n\t}\n}\n\nexport const createWSMessageParser = (\n\tparse: MaybeArray<WSParseHandler<any>>\n) => {\n\tconst parsers = typeof parse === 'function' ? [parse] : parse\n\n\treturn async function parseMessage(ws: ServerWebSocket<any>, message: any) {\n\t\tif (typeof message === 'string') {\n\t\t\tconst start = message?.charCodeAt(0)\n\n\t\t\tif (start === 34 || start === 47 || start === 91 || start === 123)\n\t\t\t\ttry {\n\t\t\t\t\tmessage = JSON.parse(message)\n\t\t\t\t} catch {\n\t\t\t\t\t// Not empty\n\t\t\t\t}\n\t\t\telse if (isNumericString(message)) message = +message\n\t\t\telse if (message === 'true') message = true\n\t\t\telse if (message === 'false') message = false\n\t\t\telse if (message === 'null') message = null\n\t\t}\n\n\t\tif (parsers)\n\t\t\tfor (let i = 0; i < parsers.length; i++) {\n\t\t\t\tlet temp = parsers[i](ws as any, message)\n\t\t\t\tif (temp instanceof Promise) temp = await temp\n\n\t\t\t\tif (temp !== undefined) return temp\n\t\t\t}\n\n\t\treturn message\n\t}\n}\n\nexport const createHandleWSResponse = (\n\tvalidateResponse: TypeCheck<any> | ElysiaTypeCheck<any> | undefined\n) => {\n\tconst handleWSResponse = (\n\t\tws: ServerWebSocket<any>,\n\t\tdata: unknown\n\t): unknown => {\n\t\tif (data instanceof Promise)\n\t\t\treturn data.then((data) => handleWSResponse(ws, data))\n\n\t\tif (Buffer.isBuffer(data)) return ws.send(data.toString())\n\n\t\tif (data === undefined) return\n\n\t\tconst send = (datum: unknown) => {\n\t\t\tif (validateResponse?.Check(datum) === false)\n\t\t\t\treturn ws.send(\n\t\t\t\t\tnew ValidationError('message', validateResponse, datum)\n\t\t\t\t\t\t.message\n\t\t\t\t)\n\n\t\t\tif (typeof datum === 'object') return ws.send(JSON.stringify(datum))\n\n\t\t\tws.send(datum)\n\t\t}\n\n\t\tif (typeof (data as Generator)?.next !== 'function')\n\t\t\treturn void send(data)\n\n\t\tconst init = (data as Generator | AsyncGenerator).next()\n\n\t\tif (init instanceof Promise)\n\t\t\treturn (async () => {\n\t\t\t\tconst first = await init\n\n\t\t\t\tif (validateResponse?.Check(first) === false)\n\t\t\t\t\treturn ws.send(\n\t\t\t\t\t\tnew ValidationError('message', validateResponse, first)\n\t\t\t\t\t\t\t.message\n\t\t\t\t\t)\n\n\t\t\t\tsend(first.value as any)\n\n\t\t\t\tif (!first.done)\n\t\t\t\t\tfor await (const datum of data as Generator) send(datum)\n\t\t\t})()\n\n\t\tsend(init.value)\n\n\t\tif (!init.done) for (const datum of data as Generator) send(datum)\n\t}\n\n\treturn handleWSResponse\n}\n\nexport type { WSLocalHook } from './types'\n",
    "/* eslint-disable sonarjs/no-duplicate-string */\nimport { Memoirist } from 'memoirist'\nimport type { TSchema } from '@sinclair/typebox'\n\nimport { WebStandardAdapter } from '../web-standard/index'\nimport { parseSetCookies } from '../utils'\nimport type { ElysiaAdapter } from '../types'\nimport type { Serve } from '../../universal/server'\n\nimport { createBunRouteHandler } from './compose'\nimport { createNativeStaticHandler } from './handler-native'\n\nimport { serializeCookie } from '../../cookies'\nimport { isProduction, ValidationError } from '../../error'\nimport { getSchemaValidator } from '../../schema'\nimport {\n\thasHeaderShorthand,\n\tisNotEmpty,\n\tisNumericString,\n\trandomId,\n\tsupportPerMethodInlineHandler\n} from '../../utils'\n\nimport {\n\tmapResponse,\n\tmapEarlyResponse,\n\tmapCompactResponse,\n\tcreateStaticHandler\n} from './handler'\n\nimport {\n\tcreateHandleWSResponse,\n\tcreateWSMessageParser,\n\tElysiaWS,\n\twebsocket\n} from '../../ws/index'\nimport type { ServerWebSocket } from '../../ws/bun'\nimport { AnyElysia } from '../..'\nimport { Static } from '@sinclair/typebox/parser'\n\nconst optionalParam = /:.+?\\?(?=\\/|$)/\n\nconst getPossibleParams = (path: string) => {\n\tconst match = optionalParam.exec(path)\n\n\tif (!match) return [path]\n\n\tconst routes: string[] = []\n\n\tconst head = path.slice(0, match.index)\n\tconst param = match[0].slice(0, -1)\n\tconst tail = path.slice(match.index + match[0].length)\n\n\troutes.push(head.slice(0, -1))\n\troutes.push(head + param)\n\n\tfor (const fragment of getPossibleParams(tail)) {\n\t\tif (!fragment) continue\n\n\t\tif (!fragment.startsWith('/:'))\n\t\t\troutes.push(head.slice(0, -1) + fragment)\n\n\t\troutes.push(head + param + fragment)\n\t}\n\n\treturn routes\n}\n\nconst supportedMethods = {\n\tGET: true,\n\tHEAD: true,\n\tOPTIONS: true,\n\tDELETE: true,\n\tPATCH: true,\n\tPOST: true,\n\tPUT: true\n} as const\n\nconst mapRoutes = (app: AnyElysia) => {\n\tif (!app.config.aot || !app.config.systemRouter) return undefined\n\n\tconst routes = <Record<string, Function | Record<string, unknown>>>{}\n\n\tconst add = (\n\t\troute: {\n\t\t\tpath: string\n\t\t\tmethod: string\n\t\t},\n\t\thandler: Function\n\t) => {\n\t\tif (routes[route.path]) {\n\t\t\t// @ts-ignore\n\t\t\tif (!routes[route.path][route.method])\n\t\t\t\t// @ts-ignore\n\t\t\t\troutes[route.path][route.method] = handler\n\t\t} else\n\t\t\troutes[route.path] = {\n\t\t\t\t[route.method]: handler\n\t\t\t}\n\t}\n\n\t// @ts-expect-error\n\tconst tree = app.routeTree\n\n\tfor (const route of app.router.history) {\n\t\tif (typeof route.handler !== 'function') continue\n\n\t\tconst method = route.method\n\n\t\tif (\n\t\t\t(method === 'GET' && `WS_${route.path}` in tree) ||\n\t\t\tmethod === 'WS' ||\n\t\t\troute.path.charCodeAt(route.path.length - 1) === 42 ||\n\t\t\t!(method in supportedMethods)\n\t\t)\n\t\t\tcontinue\n\n\t\tif (method === 'ALL') {\n\t\t\tif (!(`WS_${route.path}` in tree))\n\t\t\t\troutes[route.path] = route.hooks?.config?.mount\n\t\t\t\t\t? route.hooks.trace ||\n\t\t\t\t\t\tapp.event.trace ||\n\t\t\t\t\t\t// @ts-expect-error private property\n\t\t\t\t\t\tapp.extender.higherOrderFunctions\n\t\t\t\t\t\t? createBunRouteHandler(app, route)\n\t\t\t\t\t\t: route.hooks.mount || route.handler\n\t\t\t\t\t: route.handler\n\n\t\t\tcontinue\n\t\t}\n\n\t\tlet compiled: Function\n\n\t\tconst handler = app.config.precompile\n\t\t\t? createBunRouteHandler(app, route)\n\t\t\t: (request: Request) => {\n\t\t\t\t\tif (compiled) return compiled(request)\n\n\t\t\t\t\treturn (compiled = createBunRouteHandler(app, route))(\n\t\t\t\t\t\trequest\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\tfor (const path of getPossibleParams(route.path))\n\t\t\tadd(\n\t\t\t\t{\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath\n\t\t\t\t},\n\t\t\t\thandler\n\t\t\t)\n\t}\n\n\treturn routes\n}\n\ntype Routes = Record<string, Function | Response | Record<string, unknown>>\n\nconst mergeRoutes = (r1: Routes, r2?: Routes) => {\n\tif (!r2) return r1\n\n\tfor (const key of Object.keys(r2)) {\n\t\tif (r1[key] === r2[key]) continue\n\n\t\tif (!r1[key]) {\n\t\t\tr1[key] = r2[key]\n\t\t\tcontinue\n\t\t}\n\n\t\tif (r1[key] && r2[key]) {\n\t\t\tif (typeof r1[key] === 'function' || r1[key] instanceof Response) {\n\t\t\t\tr1[key] = r2[key]\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tr1[key] = {\n\t\t\t\t...r1[key],\n\t\t\t\t...r2[key]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn r1\n}\n\nexport const BunAdapter: ElysiaAdapter = {\n\t...WebStandardAdapter,\n\tname: 'bun',\n\thandler: {\n\t\tmapResponse,\n\t\tmapEarlyResponse,\n\t\tmapCompactResponse,\n\t\tcreateStaticHandler,\n\t\tcreateNativeStaticHandler\n\t},\n\tcomposeHandler: {\n\t\t...WebStandardAdapter.composeHandler,\n\t\theaders: hasHeaderShorthand\n\t\t\t? 'c.headers=c.request.headers.toJSON()\\n'\n\t\t\t: 'c.headers={}\\n' +\n\t\t\t\t'for(const [k,v] of c.request.headers.entries())' +\n\t\t\t\t'c.headers[k]=v\\n'\n\t},\n\tlisten(app) {\n\t\treturn (options, callback) => {\n\t\t\tif (typeof Bun === 'undefined')\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'.listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch'\n\t\t\t\t)\n\n\t\t\tapp.compile()\n\n\t\t\tif (typeof options === 'string') {\n\t\t\t\tif (!isNumericString(options))\n\t\t\t\t\tthrow new Error('Port must be a numeric value')\n\n\t\t\t\toptions = parseInt(options)\n\t\t\t}\n\n\t\t\tconst createStaticRoute = <\n\t\t\t\tWithAsync extends boolean | undefined = false\n\t\t\t>(\n\t\t\t\titerator: AnyElysia['router']['response'],\n\t\t\t\t{ withAsync = false }: { withAsync?: WithAsync } = {}\n\t\t\t): true extends WithAsync\n\t\t\t\t? Promise<{\n\t\t\t\t\t\t[path: string]:\n\t\t\t\t\t\t\t| Response\n\t\t\t\t\t\t\t| { [method: string]: Response }\n\t\t\t\t\t}>\n\t\t\t\t: {\n\t\t\t\t\t\t[path: string]:\n\t\t\t\t\t\t\t| Response\n\t\t\t\t\t\t\t| { [method: string]: Response }\n\t\t\t\t\t} => {\n\t\t\t\tconst staticRoutes = <\n\t\t\t\t\t{\n\t\t\t\t\t\t[path: string]:\n\t\t\t\t\t\t\t| Response\n\t\t\t\t\t\t\t| { [method: string]: Response }\n\t\t\t\t\t}\n\t\t\t\t>{}\n\t\t\t\tconst ops = <Promise<any>[]>[]\n\n\t\t\t\tfor (const [path, route] of Object.entries(iterator)) {\n\t\t\t\t\tif (supportPerMethodInlineHandler) {\n\t\t\t\t\t\tif (!route) continue\n\n\t\t\t\t\t\tfor (const [method, value] of Object.entries(route)) {\n\t\t\t\t\t\t\tif (!value || !(method in supportedMethods))\n\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\tif (value instanceof Promise) {\n\t\t\t\t\t\t\t\tif (withAsync) {\n\t\t\t\t\t\t\t\t\tif (!staticRoutes[path])\n\t\t\t\t\t\t\t\t\t\tstaticRoutes[path] = {}\n\n\t\t\t\t\t\t\t\t\tops.push(\n\t\t\t\t\t\t\t\t\t\tvalue.then((awaited) => {\n\t\t\t\t\t\t\t\t\t\t\tif (awaited instanceof Response)\n\t\t\t\t\t\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\t\t\t\t\t\tstaticRoutes[path][method] =\n\t\t\t\t\t\t\t\t\t\t\t\t\tawaited\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!(value instanceof Response)) continue\n\n\t\t\t\t\t\t\tif (!staticRoutes[path]) staticRoutes[path] = {}\n\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tstaticRoutes[path][method] = value\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!route) continue\n\n\t\t\t\t\t\tif (route instanceof Promise) {\n\t\t\t\t\t\t\tif (withAsync) {\n\t\t\t\t\t\t\t\tif (!staticRoutes[path]) staticRoutes[path] = {}\n\n\t\t\t\t\t\t\t\tops.push(\n\t\t\t\t\t\t\t\t\troute.then((awaited) => {\n\t\t\t\t\t\t\t\t\t\tif (awaited instanceof Response)\n\t\t\t\t\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\t\t\t\t\tstaticRoutes[path] = awaited\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!(route instanceof Response)) continue\n\n\t\t\t\t\t\tstaticRoutes[path] = route\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (withAsync)\n\t\t\t\t\treturn Promise.all(ops).then(() => staticRoutes) as any\n\n\t\t\t\treturn staticRoutes as any\n\t\t\t}\n\n\t\t\tconst serve =\n\t\t\t\ttypeof options === 'object'\n\t\t\t\t\t? ({\n\t\t\t\t\t\t\tdevelopment: !isProduction,\n\t\t\t\t\t\t\treusePort: true,\n\t\t\t\t\t\t\t...(app.config.serve || {}),\n\t\t\t\t\t\t\t...(options || {}),\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\troutes: mergeRoutes(\n\t\t\t\t\t\t\t\tmergeRoutes(\n\t\t\t\t\t\t\t\t\tcreateStaticRoute(app.router.response),\n\t\t\t\t\t\t\t\t\tmapRoutes(app)\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t// @ts-expect-error private property\n\t\t\t\t\t\t\t\tapp.config.serve?.routes\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\twebsocket: {\n\t\t\t\t\t\t\t\t...(app.config.websocket || {}),\n\t\t\t\t\t\t\t\t...(websocket || {})\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfetch: app.fetch\n\t\t\t\t\t\t\t// error: outerErrorHandler\n\t\t\t\t\t\t} as Serve)\n\t\t\t\t\t: ({\n\t\t\t\t\t\t\tdevelopment: !isProduction,\n\t\t\t\t\t\t\treusePort: true,\n\t\t\t\t\t\t\t...(app.config.serve || {}),\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\troutes: mergeRoutes(\n\t\t\t\t\t\t\t\tmergeRoutes(\n\t\t\t\t\t\t\t\t\tcreateStaticRoute(app.router.response),\n\t\t\t\t\t\t\t\t\tmapRoutes(app)\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t// @ts-expect-error private property\n\t\t\t\t\t\t\t\tapp.config.serve?.routes\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\twebsocket: {\n\t\t\t\t\t\t\t\t...(app.config.websocket || {}),\n\t\t\t\t\t\t\t\t...(websocket || {})\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tport: options,\n\t\t\t\t\t\t\tfetch: app.fetch\n\t\t\t\t\t\t\t// error: outerErrorHandler\n\t\t\t\t\t\t} as Serve)\n\n\t\t\tapp.server = Bun.serve(serve as any) as any\n\n\t\t\tif (app.event.start)\n\t\t\t\tfor (let i = 0; i < app.event.start.length; i++)\n\t\t\t\t\tapp.event.start[i].fn(app)\n\n\t\t\tif (callback) callback(app.server!)\n\n\t\t\tprocess.on('beforeExit', () => {\n\t\t\t\tif (app.server) {\n\t\t\t\t\tapp.server.stop?.()\n\t\t\t\t\tapp.server = null\n\n\t\t\t\t\tif (app.event.stop)\n\t\t\t\t\t\tfor (let i = 0; i < app.event.stop.length; i++)\n\t\t\t\t\t\t\tapp.event.stop[i].fn(app)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// @ts-expect-error private\n\t\t\tapp.promisedModules.then(async () => {\n\t\t\t\tapp.server?.reload({\n\t\t\t\t\t...serve,\n\t\t\t\t\tfetch: app.fetch,\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\troutes: mergeRoutes(\n\t\t\t\t\t\tmergeRoutes(\n\t\t\t\t\t\t\tawait createStaticRoute(app.router.response, {\n\t\t\t\t\t\t\t\twithAsync: true\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\tmapRoutes(app)\n\t\t\t\t\t\t),\n\t\t\t\t\t\t// @ts-expect-error private property\n\t\t\t\t\t\tapp.config.serve?.routes\n\t\t\t\t\t)\n\t\t\t\t})\n\n\t\t\t\tBun?.gc(false)\n\t\t\t})\n\t\t}\n\t},\n\tws(app, path, options) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tconst { parse, body, response, ...rest } = options\n\n\t\tconst validateMessage = getSchemaValidator(body, {\n\t\t\t// @ts-expect-error private property\n\t\t\tmodules: app.definitions.typebox,\n\t\t\t// @ts-expect-error private property\n\t\t\tmodels: app.definitions.type as Record<string, TSchema>,\n\t\t\tnormalize: app.config.normalize\n\t\t})\n\n\t\tconst validateResponse = getSchemaValidator(response as any, {\n\t\t\t// @ts-expect-error private property\n\t\t\tmodules: app.definitions.typebox,\n\t\t\t// @ts-expect-error private property\n\t\t\tmodels: app.definitions.type as Record<string, TSchema>,\n\t\t\tnormalize: app.config.normalize\n\t\t})\n\n\t\tapp.route(\n\t\t\t'WS',\n\t\t\tpath as any,\n\t\t\tasync (context: any) => {\n\t\t\t\t// @ts-expect-error private property\n\t\t\t\tconst server = app.getServer()\n\n\t\t\t\t// ! Enable static code analysis just in case resolveUnknownFunction doesn't work, do not remove\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\tconst { set, path, qi, headers, query, params } = context\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tcontext.validator = validateResponse\n\n\t\t\t\tif (options.upgrade) {\n\t\t\t\t\tif (typeof options.upgrade === 'function') {\n\t\t\t\t\t\tconst temp = options.upgrade(context as any)\n\t\t\t\t\t\tif (temp instanceof Promise) await temp\n\t\t\t\t\t} else if (options.upgrade)\n\t\t\t\t\t\tObject.assign(\n\t\t\t\t\t\t\tset.headers,\n\t\t\t\t\t\t\toptions.upgrade as Record<string, any>\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (set.cookie && isNotEmpty(set.cookie)) {\n\t\t\t\t\tconst cookie = serializeCookie(set.cookie)\n\n\t\t\t\t\tif (cookie) set.headers['set-cookie'] = cookie\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tset.headers['set-cookie'] &&\n\t\t\t\t\tArray.isArray(set.headers['set-cookie'])\n\t\t\t\t)\n\t\t\t\t\tset.headers = parseSetCookies(\n\t\t\t\t\t\tnew Headers(set.headers as any) as Headers,\n\t\t\t\t\t\tset.headers['set-cookie']\n\t\t\t\t\t) as any\n\n\t\t\t\tconst handleResponse = createHandleWSResponse(validateResponse)\n\t\t\t\tconst parseMessage = createWSMessageParser(parse)\n\n\t\t\t\tlet _id: string | undefined\n\n\t\t\t\tconst errorHandlers = [\n\t\t\t\t\t...(Array.isArray(options.error)\n\t\t\t\t\t\t? options.error\n\t\t\t\t\t\t: [options.error]),\n\t\t\t\t\t...(app.event.error ?? []).map((x) =>\n\t\t\t\t\t\ttypeof x === 'function' ? x : x.fn\n\t\t\t\t\t)\n\t\t\t\t].filter((x) => x)\n\n\t\t\t\tconst handleErrors = !errorHandlers.length\n\t\t\t\t\t? () => {}\n\t\t\t\t\t: async (ws: ServerWebSocket<any>, error: unknown) => {\n\t\t\t\t\t\t\tfor (const handleError of errorHandlers) {\n\t\t\t\t\t\t\t\tlet response = handleError(\n\t\t\t\t\t\t\t\t\tObject.assign(context, { error })\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\t\t\t\t\tresponse = await response\n\n\t\t\t\t\t\t\t\tawait handleResponse(ws, response)\n\n\t\t\t\t\t\t\t\tif (response) break\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tserver?.upgrade<any>(context.request, {\n\t\t\t\t\t\theaders: isNotEmpty(set.headers)\n\t\t\t\t\t\t\t? (set.headers as Record<string, string>)\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t...context,\n\t\t\t\t\t\t\tget id() {\n\t\t\t\t\t\t\t\tif (_id) return _id\n\n\t\t\t\t\t\t\t\treturn (_id = randomId())\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalidator: validateResponse,\n\t\t\t\t\t\t\tping(data?: unknown) {\n\t\t\t\t\t\t\t\toptions.ping?.(data)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpong(data?: unknown) {\n\t\t\t\t\t\t\t\toptions.pong?.(data)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\topen(ws: ServerWebSocket<any>) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\thandleResponse(\n\t\t\t\t\t\t\t\t\t\tws,\n\t\t\t\t\t\t\t\t\t\toptions.open?.(\n\t\t\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t\thandleErrors(ws, error)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessage: async (\n\t\t\t\t\t\t\t\tws: ServerWebSocket<any>,\n\t\t\t\t\t\t\t\t_message: any\n\t\t\t\t\t\t\t) => {\n\t\t\t\t\t\t\t\tconst message = await parseMessage(ws, _message)\n\n\t\t\t\t\t\t\t\tif (validateMessage?.Check(message) === false)\n\t\t\t\t\t\t\t\t\treturn void ws.send(\n\t\t\t\t\t\t\t\t\t\tnew ValidationError(\n\t\t\t\t\t\t\t\t\t\t\t'message',\n\t\t\t\t\t\t\t\t\t\t\tvalidateMessage,\n\t\t\t\t\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\t\t\t\t).message as string\n\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\thandleResponse(\n\t\t\t\t\t\t\t\t\t\tws,\n\t\t\t\t\t\t\t\t\t\toptions.message?.(\n\t\t\t\t\t\t\t\t\t\t\tnew ElysiaWS(\n\t\t\t\t\t\t\t\t\t\t\t\tws,\n\t\t\t\t\t\t\t\t\t\t\t\tcontext as any,\n\t\t\t\t\t\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\tmessage as any\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t\thandleErrors(ws, error)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdrain(ws: ServerWebSocket<any>) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\thandleResponse(\n\t\t\t\t\t\t\t\t\t\tws,\n\t\t\t\t\t\t\t\t\t\toptions.drain?.(\n\t\t\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t\thandleErrors(ws, error)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tclose(\n\t\t\t\t\t\t\t\tws: ServerWebSocket<any>,\n\t\t\t\t\t\t\t\tcode: number,\n\t\t\t\t\t\t\t\treason: string\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\thandleResponse(\n\t\t\t\t\t\t\t\t\t\tws,\n\t\t\t\t\t\t\t\t\t\toptions.close?.(\n\t\t\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any),\n\t\t\t\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\t\t\t\treason\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t\thandleErrors(ws, error)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t\t\treturn\n\n\t\t\t\tset.status = 400\n\t\t\t\treturn 'Expected a websocket connection'\n\t\t\t},\n\t\t\t{\n\t\t\t\t...rest,\n\t\t\t\twebsocket: options\n\t\t\t} as any\n\t\t)\n\t}\n}\n",
    "import { isBun } from './utils'\n\nexport const env = isBun\n\t? Bun.env\n\t: typeof process !== 'undefined' && process?.env\n\t\t? process.env\n\t\t: {}\n",
    "import type { AnyElysia } from '.'\n\nimport { TransformDecodeError } from '@sinclair/typebox/value'\nimport { TypeCheck } from './type-system'\n\nimport type { Context } from './context'\nimport type { ElysiaTypeCheck } from './schema'\n\nimport {\n\tElysiaCustomStatusResponse,\n\tElysiaErrors,\n\tstatus,\n\tNotFoundError,\n\tValidationError\n} from './error'\n\nimport { parseQuery } from './parse-query'\n\nimport { redirect, signCookie, StatusMap } from './utils'\nimport { parseCookie } from './cookies'\n\nimport type { Handler, LifeCycleStore, SchemaValidator } from './types'\n\n// JIT Handler\nexport type DynamicHandler = {\n\thandle: unknown | Handler<any, any>\n\tcontent?: string\n\thooks: Partial<LifeCycleStore>\n\tvalidator?: SchemaValidator\n\troute: string\n}\n\nconst injectDefaultValues = (\n\ttypeChecker: TypeCheck<any> | ElysiaTypeCheck<any>,\n\tobj: Record<string, any>\n) => {\n\tfor (const [key, keySchema] of Object.entries(\n\t\t// @ts-expect-error private\n\t\ttypeChecker.schema.properties\n\t)) {\n\t\t// @ts-expect-error private\n\t\tobj[key] ??= keySchema.default\n\t}\n}\n\nexport const createDynamicHandler = (app: AnyElysia) => {\n\tconst { mapResponse, mapEarlyResponse } = app['~adapter'].handler\n\n\treturn async (request: Request): Promise<Response> => {\n\t\tconst url = request.url,\n\t\t\ts = url.indexOf('/', 11),\n\t\t\tqi = url.indexOf('?', s + 1),\n\t\t\tpath = qi === -1 ? url.substring(s) : url.substring(s, qi)\n\n\t\tconst set: Context['set'] = {\n\t\t\tcookie: {},\n\t\t\tstatus: 200,\n\t\t\theaders: {}\n\t\t}\n\n\t\tconst context = Object.assign(\n\t\t\t{},\n\t\t\t// @ts-expect-error\n\t\t\tapp.singleton.decorator,\n\t\t\t{\n\t\t\t\tset,\n\t\t\t\t// @ts-expect-error\n\t\t\t\tstore: app.singleton.store,\n\t\t\t\trequest,\n\t\t\t\tpath,\n\t\t\t\tqi,\n\t\t\t\terror: status,\n\t\t\t\tstatus,\n\t\t\t\tredirect\n\t\t\t}\n\t\t) as unknown as Context & {\n\t\t\tresponse: unknown\n\t\t}\n\n\t\ttry {\n\t\t\tif (app.event.request)\n\t\t\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\t\t\tconst onRequest = app.event.request[i].fn\n\t\t\t\t\tlet response = onRequest(context as any)\n\t\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\t\tresponse = mapEarlyResponse(response, set)\n\t\t\t\t\tif (response) return (context.response = response)\n\t\t\t\t}\n\n\t\t\tconst handler =\n\t\t\t\tapp.router.dynamic.find(request.method, path) ??\n\t\t\t\tapp.router.dynamic.find('ALL', path)\n\n\t\t\tif (!handler) throw new NotFoundError()\n\n\t\t\tconst { handle, hooks, validator, content, route } = handler.store\n\n\t\t\tlet body: string | Record<string, any> | undefined\n\t\t\tif (request.method !== 'GET' && request.method !== 'HEAD') {\n\t\t\t\tif (content) {\n\t\t\t\t\tswitch (content) {\n\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\tbody = (await request.json()) as any\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1) body[key] = value[0]\n\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet contentType = request.headers.get('content-type')\n\n\t\t\t\t\tif (contentType) {\n\t\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\t\tif (index !== -1)\n\t\t\t\t\t\t\tcontentType = contentType.slice(0, index)\n\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tcontext.contentType = contentType\n\n\t\t\t\t\t\tif (hooks.parse)\n\t\t\t\t\t\t\tfor (let i = 0; i < hooks.parse.length; i++) {\n\t\t\t\t\t\t\t\tconst hook = hooks.parse[i].fn\n\t\t\t\t\t\t\t\tlet temp = hook(context as any, contentType)\n\t\t\t\t\t\t\t\tif (temp instanceof Promise) temp = await temp\n\n\t\t\t\t\t\t\t\tif (temp) {\n\t\t\t\t\t\t\t\t\tbody = temp\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tdelete context.contentType\n\n\t\t\t\t\t\t// body might be empty string thus can't use !body\n\t\t\t\t\t\tif (body === undefined) {\n\t\t\t\t\t\t\tswitch (contentType) {\n\t\t\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\t\t\tbody = (await request.json()) as any\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\t\t\tbody[key] = value[0]\n\t\t\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext.route = route\n\t\t\tcontext.body = body\n\t\t\tcontext.params = handler?.params || undefined\n\n\t\t\t// @ts-ignore\n\t\t\tcontext.query = qi === -1 ? {} : parseQuery(url.substring(qi + 1))\n\n\t\t\tcontext.headers = {}\n\t\t\tfor (const [key, value] of request.headers.entries())\n\t\t\t\tcontext.headers[key] = value\n\n\t\t\tconst cookieMeta = Object.assign(\n\t\t\t\t{},\n\t\t\t\tapp.config?.cookie,\n\t\t\t\tvalidator?.cookie?.config\n\t\t\t) as {\n\t\t\t\tsecrets?: string | string[]\n\t\t\t\tsign: string[] | true\n\t\t\t\tproperties: { [x: string]: Object }\n\t\t\t}\n\n\t\t\tconst cookieHeaderValue = request.headers.get('cookie')\n\n\t\t\tcontext.cookie = (await parseCookie(\n\t\t\t\tcontext.set,\n\t\t\t\tcookieHeaderValue,\n\t\t\t\tcookieMeta\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tsecrets:\n\t\t\t\t\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t\t\t\t\t\t: cookieMeta.secrets.join(',')\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\tsign:\n\t\t\t\t\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t\t\t\t\t? true\n\t\t\t\t\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t\t\t\t\t\t? typeof cookieMeta.sign === 'string'\n\t\t\t\t\t\t\t\t\t\t\t? cookieMeta.sign\n\t\t\t\t\t\t\t\t\t\t\t: cookieMeta.sign.join(',')\n\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined\n\t\t\t)) as any\n\n\t\t\tconst headerValidator = validator?.createHeaders?.()\n\t\t\tif (headerValidator)\n\t\t\t\tinjectDefaultValues(headerValidator, context.headers)\n\n\t\t\tconst paramsValidator = validator?.createParams?.()\n\t\t\tif (paramsValidator)\n\t\t\t\tinjectDefaultValues(paramsValidator, context.params)\n\n\t\t\tconst queryValidator = validator?.createQuery?.()\n\t\t\tif (queryValidator)\n\t\t\t\tinjectDefaultValues(queryValidator, context.query)\n\n\t\t\tif (hooks.transform)\n\t\t\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\t\t\tconst hook = hooks.transform[i]\n\t\t\t\t\tconst operation = hook.fn(context)\n\n\t\t\t\t\tif (hook.subType === 'derive') {\n\t\t\t\t\t\tif (operation instanceof Promise)\n\t\t\t\t\t\t\tObject.assign(context, await operation)\n\t\t\t\t\t\telse Object.assign(context, operation)\n\t\t\t\t\t} else if (operation instanceof Promise) await operation\n\t\t\t\t}\n\n\t\t\tif (validator) {\n\t\t\t\tif (headerValidator) {\n\t\t\t\t\tconst _header = structuredClone(context.headers)\n\t\t\t\t\tfor (const [key, value] of request.headers)\n\t\t\t\t\t\t_header[key] = value\n\n\t\t\t\t\tif (validator.headers!.Check(_header) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'header',\n\t\t\t\t\t\t\tvalidator.headers!,\n\t\t\t\t\t\t\t_header\n\t\t\t\t\t\t)\n\t\t\t\t} else if (validator.headers?.Decode)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tcontext.headers = validator.headers.Decode(context.headers)\n\n\t\t\t\tif (paramsValidator?.Check(context.params) === false) {\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'params',\n\t\t\t\t\t\tvalidator.params!,\n\t\t\t\t\t\tcontext.params\n\t\t\t\t\t)\n\t\t\t\t} else if (validator.params?.Decode)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tcontext.params = validator.params.Decode(context.params)\n\n\t\t\t\tif (queryValidator?.Check(context.query) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'query',\n\t\t\t\t\t\tvalidator.query!,\n\t\t\t\t\t\tcontext.query\n\t\t\t\t\t)\n\t\t\t\telse if (validator.query?.Decode)\n\t\t\t\t\tcontext.query = validator.query.Decode(context.query) as any\n\n\t\t\t\tif (validator.createCookie?.()) {\n\t\t\t\t\tlet cookieValue: Record<string, unknown> = {}\n\t\t\t\t\tfor (const [key, value] of Object.entries(context.cookie))\n\t\t\t\t\t\tcookieValue[key] = value.value\n\n\t\t\t\t\tif (validator.cookie!.Check(cookieValue) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'cookie',\n\t\t\t\t\t\t\tvalidator.cookie!,\n\t\t\t\t\t\t\tcookieValue\n\t\t\t\t\t\t)\n\t\t\t\t\telse if (validator.cookie?.Decode)\n\t\t\t\t\t\tcookieValue = validator.cookie.Decode(\n\t\t\t\t\t\t\tcookieValue\n\t\t\t\t\t\t) as any\n\t\t\t\t}\n\n\t\t\t\tif (validator.createBody?.()?.Check(body) === false)\n\t\t\t\t\tthrow new ValidationError('body', validator.body!, body)\n\t\t\t\telse if (validator.body?.Decode)\n\t\t\t\t\tcontext.body = validator.body.Decode(body) as any\n\t\t\t}\n\n\t\t\tif (hooks.beforeHandle)\n\t\t\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\t\t\tconst hook = hooks.beforeHandle[i]\n\t\t\t\t\tlet response = hook.fn(context)\n\n\t\t\t\t\tif (hook.subType === 'resolve') {\n\t\t\t\t\t\tif (response instanceof ElysiaCustomStatusResponse) {\n\t\t\t\t\t\t\tconst result = mapEarlyResponse(\n\t\t\t\t\t\t\t\tresponse,\n\t\t\t\t\t\t\t\tcontext.set\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tif (result)\n\t\t\t\t\t\t\t\treturn (context.response = result) as Response\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\t\t\tObject.assign(context, await response)\n\t\t\t\t\t\telse Object.assign(context, response)\n\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t} else if (response instanceof Promise)\n\t\t\t\t\t\tresponse = await response\n\n\t\t\t\t\t// `false` is a falsey value, check for undefined instead\n\t\t\t\t\tif (response !== undefined) {\n\t\t\t\t\t\t;(\n\t\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t).response = response\n\n\t\t\t\t\t\tif (hooks.afterHandle)\n\t\t\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\t\t\tlet newResponse = hooks.afterHandle[i].fn(\n\t\t\t\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\t\t\t\tif (newResponse) response = newResponse\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst result = mapEarlyResponse(response, context.set)\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tif (result) return (context.response = result)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tlet response =\n\t\t\t\ttypeof handle === 'function' ? handle(context) : handle\n\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\tif (hooks.afterHandle)\n\t\t\t\tif (!hooks.afterHandle.length) {\n\t\t\t\t\tconst status =\n\t\t\t\t\t\tresponse instanceof ElysiaCustomStatusResponse\n\t\t\t\t\t\t\t? response.code\n\t\t\t\t\t\t\t: set.status\n\t\t\t\t\t\t\t\t? typeof set.status === 'string'\n\t\t\t\t\t\t\t\t\t? StatusMap[set.status]\n\t\t\t\t\t\t\t\t\t: set.status\n\t\t\t\t\t\t\t\t: 200\n\n\t\t\t\t\tconst responseValidator =\n\t\t\t\t\t\tvalidator?.createResponse?.()?.[status]\n\n\t\t\t\t\tif (responseValidator?.Check(response) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'response',\n\t\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\t\tresponse\n\t\t\t\t\t\t)\n\t\t\t\t\telse if (responseValidator?.Decode)\n\t\t\t\t\t\tresponse = responseValidator.Decode(response)\n\t\t\t\t} else {\n\t\t\t\t\t;(\n\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t}\n\t\t\t\t\t).response = response\n\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tlet newResponse = hooks.afterHandle[i].fn(\n\t\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\t\tconst result = mapEarlyResponse(\n\t\t\t\t\t\t\tnewResponse,\n\t\t\t\t\t\t\tcontext.set\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\t\tconst responseValidator =\n\t\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\t\tvalidator?.response?.[result.status]\n\n\t\t\t\t\t\t\tif (responseValidator?.Check(result) === false)\n\t\t\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t\t\t'response',\n\t\t\t\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\telse if (responseValidator?.Decode)\n\t\t\t\t\t\t\t\tresponse = responseValidator.Decode(response)\n\n\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\treturn (context.response = result)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tif (context.set.cookie && cookieMeta?.sign) {\n\t\t\t\tconst secret = !cookieMeta.secrets\n\t\t\t\t\t? undefined\n\t\t\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t\t: cookieMeta.secrets[0]\n\n\t\t\t\tif (cookieMeta.sign === true)\n\t\t\t\t\tfor (const [key, cookie] of Object.entries(\n\t\t\t\t\t\tcontext.set.cookie\n\t\t\t\t\t))\n\t\t\t\t\t\tcontext.set.cookie[key].value = await signCookie(\n\t\t\t\t\t\t\tcookie.value as any,\n\t\t\t\t\t\t\t'${secret}'\n\t\t\t\t\t\t)\n\t\t\t\telse {\n\t\t\t\t\tconst properties = validator?.cookie?.schema?.properties\n\n\t\t\t\t\tfor (const name of cookieMeta.sign) {\n\t\t\t\t\t\tif (!(name in properties)) continue\n\n\t\t\t\t\t\tif (context.set.cookie[name]?.value) {\n\t\t\t\t\t\t\tcontext.set.cookie[name].value = await signCookie(\n\t\t\t\t\t\t\t\tcontext.set.cookie[name].value as any,\n\t\t\t\t\t\t\t\tsecret as any\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// @ts-expect-error\n\t\t\treturn mapResponse((context.response = response), context.set)\n\t\t} catch (error) {\n\t\t\tconst reportedError =\n\t\t\t\terror instanceof TransformDecodeError && error.error\n\t\t\t\t\t? error.error\n\t\t\t\t\t: error\n\n\t\t\t// ? Since error is reconciled in mergeResponseWithHeaders, this is not needed (if I'm not drunk)\n\t\t\t// if ((reportedError as ElysiaErrors).status)\n\t\t\t// \tset.status = (reportedError as ElysiaErrors).status\n\n\t\t\t// @ts-expect-error private\n\t\t\treturn app.handleError(context, reportedError)\n\t\t} finally {\n\t\t\tif (app.event.afterResponse)\n\t\t\t\tfor (const afterResponse of app.event.afterResponse)\n\t\t\t\t\tawait afterResponse.fn(context as any)\n\t\t}\n\t}\n}\n\nexport const createDynamicErrorHandler = (app: AnyElysia) => {\n\tconst { mapResponse } = app['~adapter'].handler\n\n\treturn async (\n\t\tcontext: Context & {\n\t\t\tresponse: unknown\n\t\t},\n\t\terror: ElysiaErrors\n\t) => {\n\t\tconst errorContext = Object.assign(context, { error, code: error.code })\n\t\terrorContext.set = context.set\n\n\t\tif (app.event.error)\n\t\t\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\t\t\tconst hook = app.event.error[i]\n\t\t\t\tlet response = hook.fn(errorContext as any)\n\t\t\t\tif (response instanceof Promise) response = await response\n\t\t\t\tif (response !== undefined && response !== null)\n\t\t\t\t\treturn (context.response = mapResponse(\n\t\t\t\t\t\tresponse,\n\t\t\t\t\t\tcontext.set\n\t\t\t\t\t))\n\t\t\t}\n\n\t\treturn new Response(\n\t\t\ttypeof error.cause === 'string' ? error.cause : error.message,\n\t\t\t{\n\t\t\t\theaders: context.set.headers as any,\n\t\t\t\tstatus: error.status ?? 500\n\t\t\t}\n\t\t)\n\t}\n}\n"
  ],
  "mappings": ";8oBACA,OAAO,eAAe,QAAS,aAAc,CAAE,MAAO,EAAK,CAAC,EACpD,cAAQ,MACR,kBAAY,UAepB,IAAM,iBAAmB,wCAanB,kBAAoB,kCAwBpB,kBAAoB,sFAQpB,gBAAkB,kCAClB,WAAa,OAAO,UAAU,SAC9B,YAA8B,IAAM,CACtC,IAAM,EAAI,QAAS,EAAG,GAEtB,OADA,EAAE,UAAY,OAAO,OAAO,IAAI,EACzB,IACR,EAOH,SAAS,KAAK,CAAC,IAAK,QAAS,CACzB,IAAM,IAAM,IAAI,WACV,IAAM,IAAI,OAEhB,GAAI,IAAM,EACN,OAAO,IACX,IAAM,IAAM,SAAS,QAAU,OAC3B,MAAQ,EACZ,EAAG,CACC,IAAM,MAAQ,IAAI,QAAQ,IAAK,KAAK,EACpC,GAAI,QAAU,GACV,MACJ,IAAM,SAAW,IAAI,QAAQ,IAAK,KAAK,EACjC,OAAS,WAAa,GAAK,IAAM,SACvC,GAAI,MAAQ,OAAQ,CAEhB,MAAQ,IAAI,YAAY,IAAK,MAAQ,CAAC,EAAI,EAC1C,SAEJ,IAAM,YAAc,WAAW,IAAK,MAAO,KAAK,EAC1C,UAAY,SAAS,IAAK,MAAO,WAAW,EAC5C,IAAM,IAAI,MAAM,YAAa,SAAS,EAE5C,GAAI,IAAI,OAAS,OAAW,CACxB,IAAI,YAAc,WAAW,IAAK,MAAQ,EAAG,MAAM,EAC/C,UAAY,SAAS,IAAK,OAAQ,WAAW,EAC3C,MAAQ,IAAI,IAAI,MAAM,YAAa,SAAS,CAAC,EACnD,IAAI,KAAO,MAEf,MAAQ,OAAS,QACZ,MAAQ,KACjB,OAAO,IAEX,SAAS,UAAU,CAAC,IAAK,MAAO,IAAK,CACjC,EAAG,CACC,IAAM,KAAO,IAAI,WAAW,KAAK,EACjC,GAAI,OAAS,IAAgB,OAAS,EAClC,OAAO,cACJ,MAAQ,KACnB,OAAO,IAEX,SAAS,QAAQ,CAAC,IAAK,MAAO,IAAK,CAC/B,MAAO,MAAQ,IAAK,CAChB,IAAM,KAAO,IAAI,aAAa,KAAK,EACnC,GAAI,OAAS,IAAgB,OAAS,EAClC,OAAO,MAAQ,EAEvB,OAAO,IAWX,SAAS,SAAS,CAAC,KAAM,IAAK,QAAS,CACnC,IAAM,IAAM,SAAS,QAAU,mBAC/B,IAAK,iBAAiB,KAAK,IAAI,EAC3B,MAAM,IAAI,UAAU,6BAA6B,MAAM,EAE3D,IAAM,MAAQ,IAAI,GAAG,EACrB,IAAK,kBAAkB,KAAK,KAAK,EAC7B,MAAM,IAAI,UAAU,4BAA4B,KAAK,EAEzD,IAAI,IAAM,KAAO,IAAM,MACvB,IAAK,QACD,OAAO,IACX,GAAI,QAAQ,SAAW,OAAW,CAC9B,IAAK,OAAO,UAAU,QAAQ,MAAM,EAChC,MAAM,IAAI,UAAU,6BAA6B,QAAQ,QAAQ,EAErE,KAAO,aAAe,QAAQ,OAElC,GAAI,QAAQ,OAAQ,CAChB,IAAK,kBAAkB,KAAK,QAAQ,MAAM,EACtC,MAAM,IAAI,UAAU,6BAA6B,QAAQ,QAAQ,EAErE,KAAO,YAAc,QAAQ,OAEjC,GAAI,QAAQ,KAAM,CACd,IAAK,gBAAgB,KAAK,QAAQ,IAAI,EAClC,MAAM,IAAI,UAAU,2BAA2B,QAAQ,MAAM,EAEjE,KAAO,UAAY,QAAQ,KAE/B,GAAI,QAAQ,QAAS,CACjB,IAAK,OAAO,QAAQ,OAAO,IACtB,OAAO,SAAS,QAAQ,QAAQ,QAAQ,CAAC,EAC1C,MAAM,IAAI,UAAU,8BAA8B,QAAQ,SAAS,EAEvE,KAAO,aAAe,QAAQ,QAAQ,YAAY,EAEtD,GAAI,QAAQ,SACR,KAAO,aAEX,GAAI,QAAQ,OACR,KAAO,WAEX,GAAI,QAAQ,YACR,KAAO,gBAEX,GAAI,QAAQ,SAIR,OAHiB,OAAO,QAAQ,WAAa,SACvC,QAAQ,SAAS,YAAY,EAC7B,YAEG,MACD,KAAO,iBACP,UACC,SACD,KAAO,oBACP,UACC,OACD,KAAO,kBACP,cAEA,MAAM,IAAI,UAAU,+BAA+B,QAAQ,UAAU,EAGjF,GAAI,QAAQ,SAIR,OAHiB,OAAO,QAAQ,WAAa,SACvC,QAAQ,SAAS,YAAY,EAC7B,QAAQ,cAEL,OACA,SACD,KAAO,oBACP,UACC,MACD,KAAO,iBACP,UACC,OACD,KAAO,kBACP,cAEA,MAAM,IAAI,UAAU,+BAA+B,QAAQ,UAAU,EAGjF,OAAO,IAKX,SAAS,MAAM,CAAC,IAAK,CACjB,GAAI,IAAI,QAAQ,GAAG,IAAM,GACrB,OAAO,IACX,GAAI,CACA,OAAO,mBAAmB,GAAG,EAEjC,MAAO,EAAG,CACN,OAAO,KAMf,SAAS,MAAM,CAAC,IAAK,CACjB,OAAO,WAAW,KAAK,GAAG,IAAM,uFC1OpC,IAAI,YAAc,GACd,YAAc,EACd,UAAY,CAEd,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAI/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACjC,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GACxC,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACpC,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAClC,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACpC,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACnC,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACpC,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACnC,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAIlC,IAAM,GAAM,GAAM,GAAM,EAAM,GAAM,GAAM,GAAM,GAAM,EAAM,EAAM,CACpE,EAEA,SAAS,mBAAmB,CAAC,KAAK,CAChC,IAAI,gBAAkB,KAAI,QAAQ,GAAG,EACrC,GAAI,kBAAoB,GAAI,OAAO,KAEnC,IAAI,OAAS,KAAI,OACb,QAAU,GACV,KAAO,EACP,UAAY,EACZ,cAAgB,gBAChB,MAAQ,YAEZ,MAAO,gBAAkB,IAAM,gBAAkB,OAAQ,CACvD,IAAI,KAAO,aAAa,KAAI,gBAAkB,GAAI,CAAC,EAC/C,IAAM,aAAa,KAAI,gBAAkB,GAAI,CAAC,EAC9C,MAAO,KAAO,IACd,KAAO,UAAU,OAIrB,GAHA,MAAQ,UAAU,IAAM,MAAQ,MAChC,UAAa,WAAa,EAAM,MAAO,UAAU,IAAM,MAEnD,QAAU,YACZ,SAAW,KAAI,MAAM,KAAM,aAAa,EAExC,SAAY,WAAa,MACrB,OAAO,aAAa,SAAS,EAC7B,OAAO,aACN,OAAU,WAAa,IACvB,OAAU,UAAY,KACzB,EAEF,UAAY,EACZ,KAAO,gBAAkB,EACzB,gBAAkB,cAAgB,KAAI,QAAQ,IAAK,IAAI,EAClD,QAAI,QAAU,YACnB,OAAO,KACF,KAEL,GADA,iBAAmB,EACf,gBAAkB,QAAU,KAAI,WAAW,eAAe,IAAM,GAAI,SACxE,OAAO,MAIX,OAAO,QAAU,KAAI,MAAM,IAAI,EAGjC,IAAI,IAAM,CACR,IAAK,EACL,IAAK,EACL,IAAK,EACL,IAAK,EACL,IAAK,EACL,IAAK,EACL,IAAK,EACL,IAAK,EACL,IAAK,EACL,IAAK,EACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,GACL,EAAK,EACP,EAEA,SAAS,YAAa,CAAC,EAAG,MAAO,CAC/B,IAAI,EAAI,IAAI,GACZ,OAAO,IAAM,OAAY,IAAM,GAAK,MAGtC,OAAO,QAAU,sBCjHjB,IAAI,EAAE,CAAC,EAAE,IAAI,CAAC,IAAI,EAAE,GAAG,OAAO,CAAC,EAAE,KAAK,GAAG,EAAE,QAAQ,KAAK,EAAE,EAAE,EAAE,KAAK,WAAW,CAAC,GAAG,EAAE,MAAM,CAAC,KAAK,EAAE,MAAM,KAAK,MAAM,EAAE,OAAO,KAAK,cAAc,IAAI,GAAG,EAAE,CAAC,EAAE,KAAK,IAAI,EAAE,KAAK,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,KAAK,EAAE,MAAM,KAAK,MAAM,IAAI,GAAG,MAAM,CAAC,CAAC,OAAO,KAAK,CAAC,EAAE,QAAQ,CAAC,EAAE,SAAS,CAAC,EAAE,WAAW,CAAC,EAAE,CAAC,EAAE,CAAe,GAAd,KAAK,OAAO,EAAK,EAAE,KAAK,KAAK,KAAK,KAAK,eAAgB,OAAM,CAAC,OAAO,eAAe,OAAO,gBAAgB,eAAe,iBAAiB,EAAE,SAAS,CAAC,EAAE,IAAI,CAAC,IAAI,KAAK,OAAO,KAAK,OAAO,KAAK,KAAK,OAAO,KAAK,MAAM,EAAE,KAAK,KAAK,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,IAAI,KAAK,OAAO,KAAK,OAAO,QAAQ,EAAE,EAAE,KAAK,KAAK,SAAS,KAAK,IAAI,EAAE,EAAE,EAAE,CAAC,KAAK,GAAG,cAAc,EAAE,CAAC,EAAE,KAAK,SAAS,CAAC,EAAE,KAAK,KAAK,CAAC,EAAE,IAAI,CAAC,IAAI,EAAE,KAAK,KAAK,GAAG,IAAI,EAAE,OAAO,KAAK,OAAO,EAAE,EAAE,EAAE,OAAO,EAAE,CAAC,GAAG,GAAG,CAAC,EAAE,EAAE,GAAG,YAAY,EAAE,GAAG,cAAc,EAAE,GAAG,KAAK,EAAE,KAAK,OAAO,MAAM,CAAC,EAAE,CAAC,GAAG,EAAE,OAAO,KAAK,KAAK,KAAK,SAAS,KAAK,SAAS,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,EAAE,GAAG,OAAO,IAAI,SAAS,MAAM,IAAI,UAAU,6BAA6B,EAAE,GAAG,IAAI,GAAG,EAAE,IAAS,QAAG,EAAE,KAAK,IAAI,EAAE,IAAI,IAAI,IAAI,EAAE,EAAE,EAAE,OAAO,KAAK,IAAI,EAAE,EAAE,MAAM,EAAE,MAAM,cAAc,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,EAAE,WAAW,IAAI,EAAE,EAAE,KAAK,IAAI,EAAE,EAAE,EAAE,CAAC,YAAY,EAAE,cAAc,EAAE,KAAK,CAAC,CAAC,EAAE,QAAQ,EAAE,EAAE,EAAE,EAAE,OAAO,IAAI,CAAC,IAAI,EAAE,EAAE,QAAQ,IAAI,EAAE,GAAG,EAAE,EAAE,KAAK,IAAI,EAAE,EAAE,EAAE,CAAC,YAAY,GAAG,cAAc,EAAE,KAAK,CAAC,CAAC,EAAE,OAAO,EAAE,GAAG,EAAE,EAAE,EAAE,WAAW,IAAI,EAAE,EAAE,GAAG,KAAK,QAAQ,KAAK,EAAE,EAAE,EAAE,KAAK,IAAI,GAAG,IAAI,CAAC,EAAE,OAAO,EAAE,GAAG,GAAG,GAAG,EAAE,WAAW,EAAE,OAAO,CAAC,IAAI,GAAG,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,IAAI,EAAE,KAAK,QAAQ,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,MAAM,EAAE,MAAM,MAAM,EAAE,EAAE,EAAE,MAAM,EAAE,MAAM,MAAM,GAAG,CAAC,EAAE,GAAG,EAAE,EAAE,OAAO,KAAK,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,KAAK,KAAK,GAAG,EAAE,KAAK,KAAK,GAAG,EAAE,GAAG,EAAO,OAAE,KAAK,KAAK,GAAG,IAAI,EAAE,EAAE,QAAQ,EAAE,EAAE,EAAE,EAAE,SAAS,EAAE,CAAC,IAAI,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,CAAC,IAAI,EAAE,EAAE,KAAK,MAAM,CAAC,EAAE,GAAG,EAAE,SAAS,KAAK,EAAE,OAAO,EAAE,CAAC,EAAO,QAAG,EAAE,OAAO,OAAO,EAAE,GAAG,EAAE,OAAO,EAAO,WAAM,IAAI,MAAM,wBAAwB,sBAAsB,uEAAuE,EAAE,OAAO,6BAA6B,EAAE,IAAI,EAAE,EAAE,OAAO,GAAG,EAAE,QAAQ,KAAK,CAAC,EAAE,EAAE,MAAM,EAAE,CAAC,EAAE,SAAS,EAAE,EAAE,MAAM,QAAQ,EAAE,IAAI,CAAC,GAAG,IAAI,EAAE,OAAO,CAAC,GAAG,EAAE,EAAE,KAAK,OAAO,CAAC,IAAI,EAAE,EAAE,EAAE,EAAE,KAAK,MAAM,CAAC,CAAC,EAAE,OAAO,OAAO,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,GAAG,IAAI,EAAE,KAAK,OAAO,CAAC,GAAG,EAAE,QAAQ,KAAK,EAAE,MAAM,CAAC,EAAE,IAAI,EAAE,EAAE,MAAM,EAAE,WAAW,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,MAAM,CAAC,EAAE,EAAE,EAAE,SAAS,IAAI,EAAE,EAAE,EAAE,MAAM,CAAC,CAAC,EAAE,EAAE,MAAM,EAAE,WAAW,CAAC,GAAG,EAAE,EAAE,EAAE,MAAM,GAAG,EAAE,KAAK,EAAE,KAAK,GAAG,CAAC,IAAI,EAAE,EAAE,EAAE,EAAE,KAAK,MAAM,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,MAAM,CAAC,CAAC,EAAE,OAAO,OAAO,EAAE,EAAE,EAAE,KAAK,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,QAAQ,GAAG,GAAG,EAAE,EAAE,OAAO,CAAC,IAAI,EAAE,EAAE,GAAG,MAAM,CAAC,EAAE,GAAG,EAAE,SAAS,KAAK,EAAE,OAAO,EAAE,CAAC,EAAO,QAAG,EAAE,OAAO,OAAO,EAAE,GAAG,EAAE,OAAO,EAAO,WAAM,IAAI,MAAM,wBAAwB,sBAAsB,uEAAuE,EAAE,OAAO,6BAA6B,EAAE,GAAG,EAAE,OAAO,QAAQ,KAAK,EAAE,OAAO,MAAM,EAAE,OAAO,EAAE,OAAO,MAAM,GAAG,EAAE,CAAC,GAAG,EAAE,gBAAgB,KAAK,EAAE,cAAc,EAAE,OAAO,EAAE,cAAc,GAAG,EAAE,QAAQ,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,IAAI,CAAC,EAAE,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,GAAG,IAAI,EAAE,OAAO,KAAK,OAAO,EAAE,EAAE,EAAE,OAAO,EAAE,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,IAAI,CAAC,IAAI,EAAE,EAAE,KAAK,EAAE,EAAE,OAAO,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,CAAC,GAAG,EAAE,EAAE,OAAO,KAAK,GAAG,EAAE,IAAI,QAAQ,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,IAAI,EAAE,GAAG,EAAE,WAAW,CAAC,IAAI,EAAE,WAAW,CAAC,EAAE,OAAO,KAAU,QAAG,EAAE,MAAM,EAAE,CAAC,IAAI,EAAE,OAAO,KAAK,GAAG,IAAI,EAAE,CAAC,GAAG,EAAE,QAAQ,KAAK,MAAM,CAAC,MAAM,EAAE,MAAM,OAAO,CAAC,CAAC,EAAE,GAAG,EAAE,gBAAgB,KAAK,MAAM,CAAC,MAAM,EAAE,cAAc,OAAO,CAAC,IAAI,EAAE,CAAC,EAAE,OAAO,KAAK,GAAG,EAAE,QAAQ,KAAK,CAAC,IAAI,EAAE,EAAE,MAAM,EAAE,WAAW,CAAC,GAAG,GAAG,IAAS,OAAE,CAAC,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,IAAI,KAAK,OAAO,GAAG,GAAG,EAAE,SAAS,KAAK,CAAC,IAAI,MAAM,EAAE,KAAK,EAAE,MAAM,GAAG,EAAE,OAAO,EAAE,EAAE,QAAQ,IAAI,CAAC,EAAE,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC,EAAE,OAAO,EAAE,GAAG,EAAE,UAAU,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC,GAAQ,QAAG,IAAI,KAAK,CAAC,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,IAAI,KAAK,OAAO,EAAE,OAAO,GAAG,EAAE,UAAU,EAAE,CAAC,EAAE,IAAI,GAAG,EAAE,gBAAgB,KAAK,MAAM,CAAC,MAAM,EAAE,cAAc,OAAO,CAAC,IAAI,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE,OAAO,MCA1oH,eACC,8BCFD,oBAAe,8BCAf,8CAqCO,IAAM,YAAc,CAE1B,KAEA,KAAM,QAAQ,EAAI,EAClB,YAAa,YAAY,EAAI,EAC7B,WAAY,QAAQ,EAAK,EACzB,gBAAiB,YAAY,EAAK,EAElC,SACC,yEACD,IACA,gBACC,yoCAED,eACC,oLAGD,IAAK,qdACL,MAAO,2IACP,SACC,wGAED,KAAM,oFACN,KAAM,m/BACN,MAEA,KAAM,+DAGN,eAAgB,4BAChB,4BACC,+DAED,wBAAyB,mDAGzB,KAEA,MAAO,CAAE,KAAM,SAAU,SAAU,aAAc,EAEjD,MAAO,CAAE,KAAM,SAAU,SAAU,aAAc,EAEjD,MAAO,CAAE,KAAM,SAAU,SAAU,cAAe,EAElD,OAAQ,CAAE,KAAM,SAAU,SAAU,cAAe,EAEnD,SAAU,GAEV,OAAQ,EACT,EAEA,SAAS,UAAU,CAAC,KAAuB,CAE1C,OAAO,KAAO,IAAM,IAAM,KAAO,MAAQ,GAAK,KAAO,MAAQ,GAG9D,IAAM,KAAO,6BACP,KAAO,CAAC,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAE,EAE/D,SAAS,IAAI,CAAC,IAAsB,CAEnC,IAAM,QAA2B,KAAK,KAAK,GAAG,EAC9C,IAAK,QAAS,MAAO,GACrB,IAAM,MAAgB,QAAQ,GACxB,OAAiB,QAAQ,GACzB,KAAe,QAAQ,GAC7B,OACC,OAAS,GACT,OAAS,IACT,KAAO,GACP,MAAQ,QAAU,GAAK,WAAW,IAAI,EAAI,GAAK,KAAK,QAItD,IAAM,KAAO,kEAEb,SAAS,OAAO,CAAC,eAAoD,CACpE,OAAO,SAAS,IAAI,CAAC,IAAsB,CAC1C,IAAM,QAA2B,KAAK,KAAK,GAAG,EAC9C,IAAK,QAAS,MAAO,GACrB,IAAM,IAAc,QAAQ,GACtB,KAAe,QAAQ,GACvB,KAAe,QAAQ,GACvB,GAAyB,QAAQ,GACjC,OAAiB,QAAQ,KAAO,IAAM,GAAK,EAC3C,MAAgB,QAAQ,IAAM,GAC9B,MAAgB,QAAQ,IAAM,GACpC,GAAI,IAAM,IAAM,IAAM,IAAO,iBAAmB,GAAK,MAAO,GAC5D,GAAI,IAAM,IAAM,KAAO,IAAM,IAAM,GAAI,MAAO,GAE9C,IAAM,OAAS,IAAM,IAAM,OACrB,MAAQ,GAAK,IAAM,QAAU,OAAS,EAAI,EAAI,GACpD,OACE,QAAU,IAAM,QAAU,MAC1B,SAAW,IAAM,SAAW,KAC7B,IAAM,IAKF,IAAM,wBAA0B,CAAC,MAAgB,CACvD,GAAI,IAAI,WAAW,IAAI,OAAS,CAAC,IAAM,GACtC,OAAO,IAAI,MAAM,EAAG,EAAE,EAAI,IAAM,IAAI,MAAM,EAAE,EAE7C,OAAO,KAGF,oBAAsB,QAC5B,SAAS,WAAW,CAAC,eAAoD,CACxE,IAAM,KAAO,QAAQ,cAAc,EAEnC,OAAO,SAAS,SAAS,CAAC,IAAsB,CAE/C,IAAM,SAAqB,IAAI,MAAM,mBAAmB,EAExD,OAAO,SAAS,SAAW,GAAK,KAAK,SAAS,EAAE,GAAK,KAAK,SAAS,EAAE,GAIvE,IAAM,iBAAmB,OACnB,IACL,+nCAED,SAAS,GAAG,CAAC,IAAsB,CAElC,OAAO,iBAAiB,KAAK,GAAG,GAAK,IAAI,KAAK,GAAG,EAGlD,IAAM,KACL,qEAED,SAAS,IAAI,CAAC,IAAsB,CAEnC,OADA,KAAK,UAAY,EACV,KAAK,KAAK,GAAG,EAGrB,IAAM,UAAY,YACZ,UAAY,WAElB,SAAS,aAAa,CAAC,MAAwB,CAC9C,OAAO,OAAO,UAAU,KAAK,GAAK,OAAS,WAAa,OAAS,UAGlE,SAAS,aAAa,CAAC,MAAwB,CAE9C,OAAO,OAAO,UAAU,KAAK,EAG9B,SAAS,cAAc,EAAY,CAClC,MAAO,GAGR,IAAM,SAAW,WACjB,SAAS,KAAK,CAAC,IAAsB,CACpC,GAAI,SAAS,KAAK,GAAG,EAAG,MAAO,GAC/B,GAAI,CAEH,OADA,IAAI,OAAO,GAAG,EACP,GACN,MAAO,EAAG,CACX,MAAO,IA8BT,IAAM,UACL,iNAEK,aACL,qJAEK,cACL,oOAEK,cAAgB,YAAY,KAC5B,kBAAoB,YAAY,aAEtC,IAAK,eAAe,IAAI,MAAM,EAC7B,eAAe,IAAI,OAAQ,CAAC,QAAkB,CAE7C,IAAM,KAAO,wBAAwB,KAAK,EAAE,QAAQ,KAAM,EAAE,EAE5D,GACC,UAAU,KAAK,IAAI,GACnB,aAAa,KAAK,IAAI,GACtB,cAAc,KAAK,IAAI,GACvB,cAAc,IAAI,EACjB,CACD,IAAM,MAAO,IAAI,KAAK,IAAI,EAC1B,IAAK,OAAO,MAAM,MAAK,QAAQ,CAAC,EAAG,MAAO,GAG3C,MAAO,GACP,EAEF,IAAK,eAAe,IAAI,WAAW,EAClC,eAAe,IAAI,YAAa,CAAC,QAAkB,CAElD,IAAM,KAAO,MAAM,QAAQ,KAAM,EAAE,EAEnC,GACC,UAAU,KAAK,IAAI,GACnB,aAAa,KAAK,IAAI,GACtB,cAAc,KAAK,IAAI,GACvB,kBAAkB,IAAI,EACrB,CACD,IAAM,MAAO,IAAI,KAAK,IAAI,EAC1B,IAAK,OAAO,MAAM,MAAK,QAAQ,CAAC,EAAG,MAAO,GAG3C,MAAO,GACP,EAEF,OAAO,QAAQ,WAAW,EAAE,QAAQ,CAAC,cAAgB,CACpD,IAAO,WAAY,aAAe,YAElC,IAAK,eAAe,IAAI,UAAU,GACjC,GAAI,uBAAuB,OAC1B,eAAe,IAAI,WAAY,CAAC,QAAU,YAAY,KAAK,KAAK,CAAC,EAC7D,QAAI,OAAO,cAAgB,WAC/B,eAAe,IAAI,WAAY,WAAW,GAE5C,EAED,IAAK,eAAe,IAAI,SAAS,EAChC,eAAe,IAAI,UAAW,CAAC,UAAY,QAAU,OAAO,KAAK,CAAC,EAEnE,IAAK,eAAe,IAAI,SAAS,EAChC,eAAe,IACd,UACA,CAAC,UAAY,OAAS,OAAO,WAAW,KAAK,CAC9C,EAED,IAAK,eAAe,IAAI,SAAS,EAChC,eAAe,IACd,UACA,CAAC,QAAU,QAAU,QAAU,QAAU,OAC1C,EAED,IAAK,eAAe,IAAI,cAAc,EACrC,eAAe,IAAI,eAAgB,CAAC,QAAU,CAC7C,IAAI,MAAQ,MAAM,WAAW,CAAC,EAG9B,GAAI,QAAU,GAAK,QAAU,IAAM,QAAU,GAC5C,MAAQ,MAAM,UAAU,EAAE,WAAW,CAAC,EAEvC,GAAI,QAAU,KAAO,QAAU,GAAI,MAAO,GAE1C,GAAI,CAGH,OAFA,KAAK,MAAM,KAAK,EAET,GACN,KAAM,CACP,MAAO,IAER,EAEF,IAAK,eAAe,IAAI,aAAa,EACpC,eAAe,IAAI,cAAe,CAAC,QAAU,CAC5C,IAAI,MAAQ,MAAM,WAAW,CAAC,EAG9B,GAAI,QAAU,GAAK,QAAU,IAAM,QAAU,GAC5C,MAAQ,MAAM,UAAU,EAAE,WAAW,CAAC,EAEvC,GAAI,QAAU,KAAO,QAAU,GAAI,MAAO,GAE1C,GAAI,CAGH,OAFA,KAAK,MAAM,KAAK,EAET,GACN,KAAM,CACP,MAAO,IAER,EClVF,wDAOA,gBAAS,qCACT,qDCPO,IAAM,MAAQ,OAAO,MAAQ,YCO7B,IAAM,KAAO,CACnB,IAAK,YACL,IAAK,wBACL,GAAI,yBACJ,IAAK,2BACL,IAAK,kBACL,IAAK,+BACL,IAAK,2BACL,GAAI,qBACJ,IAAK,sBACL,IAAK,oBACL,IAAK,WACL,IAAK,WACL,IAAK,qBACL,IAAK,2BACL,IAAK,gCACL,KAAM,uBACN,IAAK,YACL,IAAK,YACL,KAAM,YACN,IAAK,eACL,IAAK,gBACL,IAAK,2BACL,KAAM,aACN,IAAK,aACL,GAAI,yBACJ,KAAM,mBACN,IAAK,aACL,KAAM,aACN,IAAK,aACL,IAAK,aACL,IAAK,YACL,IAAK,aACL,IAAK,aACL,KAAM,aACN,KAAM,sCACN,IAAK,kDACL,IAAK,iDACL,IAAK,0CACL,IAAK,YACL,IAAK,YACL,IAAK,kBACL,IAAK,WACL,IAAK,YACL,IAAK,kBACL,IAAK,gCACL,IAAK,+BACL,IAAK,kBACL,GAAI,mBACJ,IAAK,gBACL,IAAK,gCACL,IAAK,oBACL,IAAK,aACL,KAAM,aACN,GAAI,yBACJ,IAAK,WACL,IAAK,aACL,IAAK,wBACL,IAAK,cACL,KAAM,aACN,KAAM,aACN,KAAM,aACN,KAAM,YACN,MAAO,aACP,MAAO,wBACP,IAAK,2BACL,KAAM,2BACN,SACC,oEACD,IAAK,kBACL,IAAK,kCACL,IAAK,kBACL,MAAO,aACP,6BAA8B,aAC9B,OAAQ,cACR,8BAA+B,cAC/B,KAAM,6BACP,EAEa,iBAAmB,CAAC,OAAiB,CACjD,IAAM,MAAQ,KAAK,YAAY,GAAG,EAClC,GAAI,QAAU,GAAI,MAAO,GAEzB,OAAO,KAAK,MAAM,MAAQ,CAAC,GAGf,KAAO,CAAC,OAAiB,IAAI,WAAW,IAAI,EAErD,iBACA,KAEG,MAAM,UAAW,CAIJ,KAHV,MACA,MAET,WAAW,CAAQ,KAAc,CAAd,eAClB,GAAI,MAAO,KAAK,MAAQ,IAAI,KAAK,IAAI,EAIpC,QAAI,OAAO,SAAW,YACrB,QAAQ,KAAK,2CAA2C,EAExD,SAAK,mBAAqB,KACzB,GAAI,CACH,KAAK,MAAe,aAAM,KAAK,CAAC,KAAO,CAGtC,OAFA,iBAAmB,GAAG,iBAEf,GAAG,iBAAiB,IAAI,EAC/B,EACD,KAAK,MAAe,sBAAe,KAAK,CAAC,KAAO,CAG/C,OAFA,KAAO,GAAG,KAEH,GAAG,KAAK,IAAI,EACnB,EACA,KAAM,EAIR,UAAK,MAAQ,iBAAiB,IAAI,EAClC,KAAK,MAAQ,KAAK,IAAI,KAMtB,KAAI,EAAG,CACV,OAEC,KAAK,iBAAiB,KAAK,IAAI,IAAM,8BAInC,OAAM,EAAG,CACZ,GAAI,MAAO,OAAQ,KAAK,MAAkB,KAE1C,OAAO,KAAK,OAAO,KAAK,CAAC,IAAM,EAAE,IAAI,GAAK,EAE5C,CCjJA,2CCuBO,IAAM,mBAAqB,WAAY,IAAI,QAErC,eAAiB,CAAC,IAAa,WAAqB,CAChE,IAAM,UAAY,IAAI,IAAI,GAAG,EAE7B,OADA,UAAU,SAAW,SACd,UAAU,SAAS,GAGd,QAAU,CAAC,IACtB,OAAO,IAAM,YAAc,eAAe,KAAK,EAAE,SAAS,CAAC,GAE3D,EAAE,UAIF,EAAE,SAAS,EAAE,WAAW,UAAU,GAClC,EAAE,SAAS,IAAM,mBAElB,WAAW,OAAO,eAAe,CAAC,CAAC,EAE9B,SAAW,CAAC,OACjB,MAAQ,OAAO,OAAS,WAAa,MAAM,QAAQ,IAAI,EAE3C,UAAY,CAIxB,OACA,OACA,UAIW,CACX,IAAM,SAAW,SAAS,SACpB,SAAW,SAAS,UAAY,GAEtC,IAAK,SAAS,MAAM,IAAM,SAAS,MAAM,EAAG,OAAO,OAEnD,QAAY,IAAK,SAAU,OAAO,QAAQ,MAAM,EAAG,CAClD,GAAI,UAAU,SAAS,GAAG,EAAG,SAE7B,IAAK,SAAS,KAAK,KAAO,OAAO,SAAW,QAAQ,KAAK,EAAG,CAC3D,GAAI,YAAc,OAAO,QACxB,OAAO,KAA8B,MAEtC,SAGD,OAAO,KAA8B,UACnC,OAAe,KAChB,MACA,CAAE,SAAU,QAAS,CACtB,EAGD,OAAO,QAEK,YAAc,CAC1B,EACA,IACW,CACX,IAAM,EAAI,UAAU,OAAO,OAAO,CAAC,EAAG,CAAC,EAAG,EAAG,CAC5C,SAAU,CAAC,YAAY,CACxB,CAAC,EAGD,GAAI,EAAE,WAAY,OAAO,EAAE,WAE3B,OAAO,GAGK,iBAAmB,CAC/B,EACA,IACqB,CACrB,IAAK,EAAG,OAAO,EAGf,IAAM,MAAa,CAAC,EACd,UAAoC,CAAC,EAE3C,GAAI,EAAG,CACN,IAAK,MAAM,QAAQ,CAAC,EAAG,EAAI,CAAC,CAAC,EAC7B,QAAW,QAAQ,EAGlB,GAFA,MAAM,KAAK,IAAI,EAEX,KAAK,SAAU,UAAU,KAAK,KAAK,QAAQ,EAIjD,GAAI,EAAG,CACN,IAAK,MAAM,QAAQ,CAAC,EAAG,EAAI,CAAC,CAAC,EAC7B,QAAW,QAAQ,EAClB,IAAK,UAAU,SAAS,KAAK,QAAQ,EAAG,MAAM,KAAK,IAAI,EAGzD,OAAO,OAGK,eAAiB,CAC7B,QACA,UACA,QACA,YACA,UACA,eACA,cACA,cACA,gBACA,QACA,QACA,OACA,OACA,UACA,SACA,QACA,WACA,OACA,QACD,EAEM,iBAAmB,eAAe,OACvC,CAAC,IAAK,KAAQ,IAAI,GAAK,GAAO,KAC9B,CAAC,CACF,EAEa,cAAgB,CAC5B,EACA,IACI,CAIJ,IAAM,eAAiB,CAAC,IACvB,OAAO,IAAM,UAAY,OAAO,KAAK,CAAC,EAAE,MAAM,eAAe,EAE9D,GAAI,eAAe,CAAC,GAAK,eAAe,CAAC,EAAG,OAAO,OAAO,OAAO,EAAG,CAAC,EAChE,QAAI,IAAM,eAAe,CAAC,GAAK,eAAe,CAAC,EACnD,OAAO,OAAO,OAAO,CAAE,IAAK,CAAE,EAAG,CAAC,EAEnC,OAAO,GAAK,GAGA,qBAAuB,CACnC,EACA,IACqB,CACrB,MAAO,CACN,KAAM,GAAG,MAAQ,GAAG,KACpB,QAAS,GAAG,SAAW,GAAG,QAC1B,OAAQ,GAAG,QAAU,GAAG,OACxB,MAAO,GAAG,OAAS,GAAG,MACtB,OAAQ,GAAG,QAAU,GAAG,OAExB,SAAU,cAET,GAAG,SAEH,GAAG,QACJ,CACD,GAGY,UAAY,CACxB,EACA,IAEoB,CA8BpB,IAAK,OAAO,OAAO,CAAC,EAAE,KAAK,CAAC,IAAM,IAAM,QAAa,IAAM,IAAI,EAC9D,MAAO,IAAK,CAAE,EAEf,IAAM,KAAO,IACT,KACA,EAGH,KAAM,GAAG,MAAQ,GAAG,KAEpB,QAAS,GAAG,SAAW,GAAG,QAE1B,OAAQ,GAAG,QAAU,GAAG,OAExB,MAAO,GAAG,OAAS,GAAG,MAEtB,OAAQ,GAAG,QAAU,GAAG,OAExB,SAAU,cAET,GAAG,SAEH,GAAG,QACJ,EACA,KAAM,GAAG,MAAQ,GAAG,KACpB,OAAQ,UAEP,GAAG,QAAU,CAAC,EAEd,GAAG,QAAU,CAAC,CACf,EACA,MAAO,iBAAiB,GAAG,MAAc,GAAG,KAAK,EACjD,UAAW,iBAAiB,GAAG,UAAW,GAAG,SAAS,EACtD,aAAc,iBACb,iBAEC,cAAc,GAAG,QAAS,SAAS,EACnC,GAAG,YACJ,EACA,iBACC,cAAc,EAAE,QAAS,SAAS,EAClC,GAAG,YACJ,CACD,EACA,YAAa,iBAAiB,GAAG,YAAa,GAAG,WAAW,EAC5D,YAAa,iBAAiB,GAAG,YAAa,GAAG,WAAW,EAC5D,cAAe,iBACd,GAAG,cACH,GAAG,aACJ,EACA,MAAO,iBAAiB,GAAG,MAAO,GAAG,KAAK,EAC1C,MAAO,iBAAiB,GAAG,MAAO,GAAG,KAAK,CAC3C,EAEA,GAAI,KAAK,QAAS,OAAO,KAAK,QAE9B,OAAO,MAGK,iBAAmB,CAAC,IAAsB,CACtD,GAAI,EAAE,QAAU,MAAM,QAAQ,EAAE,KAAK,EAAG,EAAE,MAAQ,CAAC,EAAE,KAAK,EAE1D,GAAI,EAAE,YAAc,MAAM,QAAQ,EAAE,SAAS,EAAG,EAAE,UAAY,CAAC,EAAE,SAAS,EAE1E,GAAI,EAAE,cAAgB,MAAM,QAAQ,EAAE,WAAW,EAChD,EAAE,YAAc,CAAC,EAAE,WAAW,EAE/B,GAAI,EAAE,cAAgB,MAAM,QAAQ,EAAE,WAAW,EAChD,EAAE,YAAc,CAAC,EAAE,WAAW,EAE/B,GAAI,EAAE,gBAAkB,MAAM,QAAQ,EAAE,aAAa,EACpD,EAAE,cAAgB,CAAC,EAAE,aAAa,EAEnC,GAAI,EAAE,QAAU,MAAM,QAAQ,EAAE,KAAK,EAAG,EAAE,MAAQ,CAAC,EAAE,KAAK,EAC1D,GAAI,EAAE,QAAU,MAAM,QAAQ,EAAE,KAAK,EAAG,EAAE,MAAQ,CAAC,EAAE,KAAK,EAE1D,IAAI,aAAe,CAAC,EAGpB,GAAI,EAAE,QACL,aAAe,cAEd,MAAM,QAAQ,EAAE,OAAO,EAAI,EAAE,QAAU,CAAC,EAAE,OAAO,EACjD,SACD,EAGA,OAAO,EAAE,QAGV,GAAI,EAAE,aACL,GAAI,aAAa,OAChB,aAAe,aAAa,OAC3B,MAAM,QAAQ,EAAE,YAAY,EACzB,EAAE,aACF,CAAC,EAAE,YAAY,CACnB,EAEA,kBAAe,MAAM,QAAQ,EAAE,YAAY,EACxC,EAAE,aACF,CAAC,EAAE,YAAY,EAGpB,GAAI,aAAa,OAAQ,EAAE,aAAe,aAE1C,OAAO,GAGF,OAAQ,OAAO,MAAQ,YACvB,WAAa,QAAS,OAAO,IAAI,OAAS,WAGnC,SAAW,CAAC,IAAc,CACtC,IAAI,EAAI,EAER,QAAS,EAAI,EAAG,EAAI,EAAE,QAAU,EAAI,KAAK,KAAK,EAAI,EAAE,WAAW,GAAG,EAAG,SAAM,EAE3E,OAAQ,EAAI,EAAK,IAAM,GAGX,eAAiB,CAC7B,UACA,IACI,CACJ,IAAK,EAAG,OAER,IAAK,MAAM,QAAQ,CAAC,EAAG,CAEtB,IAAM,GAAK,EAEX,GAAI,YAAa,GAAG,SAAU,GAAG,SAAW,UAC5C,GAAI,GAAG,QAAU,SAAU,GAAG,MAAQ,QAEtC,OAAO,GAIR,IAAM,IAAM,CAAC,GAAG,CAAC,EAEjB,QAAW,MAAM,IAAK,CACrB,GAAI,YAAa,GAAG,SAAU,GAAG,SAAW,UAE5C,GAAI,GAAG,QAAU,SAAU,GAAG,MAAQ,QAGvC,OAAO,KAGK,eAAiB,CAC7B,EACA,EACA,YACoB,CACpB,MAAO,CACN,MAAO,iBACN,EAAE,MACF,eAAe,UAAU,GAAG,KAAK,CAClC,EACA,QAAS,iBACR,EAAE,QACF,eAAe,UAAU,GAAG,OAAO,CACpC,EACA,MAAO,iBACN,EAAE,MACF,eAAe,UAAU,GAAG,KAAK,CAClC,EACA,UAAW,iBACV,EAAE,UACF,eAAe,UAAU,GAAG,SAAS,CACtC,EACA,aAAc,iBACb,iBAEC,cAAc,EAAE,QAAS,SAAS,EAClC,EAAE,YACH,EACA,eACC,UACA,iBACC,cAAc,GAAG,QAAS,SAAS,EACnC,GAAG,YACJ,CACD,CACD,EACA,YAAa,iBACZ,EAAE,YACF,eAAe,UAAU,GAAG,WAAW,CACxC,EACA,YAAa,iBACZ,EAAE,YACF,eAAe,UAAU,GAAG,WAAW,CACxC,EACA,cAAe,iBACd,EAAE,cACF,eAAe,UAAU,GAAG,aAAa,CAC1C,EAEA,MAAO,iBACN,EAAE,MACF,eAAe,UAAU,GAAG,KAAK,CAClC,EACA,MAAO,iBACN,EAAE,MACF,eAAe,UAAU,GAAG,KAAK,CAClC,EACA,KAAM,iBACL,EAAE,KACF,eAAe,UAAU,GAAG,IAAI,CACjC,CACD,GAGY,WAAa,CACzB,GACA,QACE,cAAgB,MACd,CACJ,IAAK,GAAI,OAAO,GAEhB,IAAK,MAAM,QAAQ,EAAE,EAAG,CACvB,GAAI,cAAe,GAAG,QAAU,OAC3B,QAAG,MAAQ,OAEhB,OAAO,GAGR,QAAW,KAAK,GACf,GAAI,cAAe,EAAE,QAAU,OAC1B,OAAE,MAAQ,OAEhB,OAAO,IAGF,aAAe,CAAC,KAAkC,CACvD,IAAK,GAAI,OAAO,GAEhB,IAAK,MAAM,QAAQ,EAAE,EACpB,OAAQ,GAAG,WACL,aACA,SACJ,MAAO,IAAK,EAAG,UAGf,MAAO,CAAE,EAAG,EAGf,IAAM,MAAa,CAAC,EAEpB,QAAW,KAAK,GACf,OAAQ,EAAE,WACJ,aACA,SACJ,MAAM,KAAK,IACP,CACJ,CAAC,EACD,MAGH,OAAO,OAGK,iBAAmB,CAAC,OAAqC,CACrE,MAAO,IAEH,KACH,KAAM,MAAM,KACZ,OAAQ,MAAM,OACd,MAAO,aAAa,MAAM,KAAK,EAC/B,UAAW,aAAa,MAAM,SAAS,EACvC,aAAc,aAAa,MAAM,YAAY,EAC7C,YAAa,aAAa,MAAM,WAAW,EAC3C,YAAa,aAAa,MAAM,WAAW,EAC3C,cAAe,aAAa,MAAM,aAAa,EAC/C,MAAO,aAAa,MAAM,KAAK,EAC/B,MAAO,aAAa,MAAM,KAAK,CAChC,GAGY,UAAY,CACxB,SAAU,IACV,sBAAuB,IACvB,WAAY,IACZ,cAAe,IACf,GAAI,IACJ,QAAS,IACT,SAAU,IACV,gCAAiC,IACjC,aAAc,IACd,gBAAiB,IACjB,kBAAmB,IACnB,eAAgB,IAChB,mBAAoB,IACpB,mBAAoB,IACpB,oBAAqB,IACrB,MAAO,IACP,YAAa,IACb,eAAgB,IAChB,qBAAsB,IACtB,qBAAsB,IACtB,cAAe,IACf,aAAc,IACd,mBAAoB,IACpB,UAAW,IACX,YAAa,IACb,qBAAsB,IACtB,iBAAkB,IAClB,gCAAiC,IACjC,kBAAmB,IACnB,SAAU,IACV,KAAM,IACN,kBAAmB,IACnB,sBAAuB,IACvB,oBAAqB,IACrB,eAAgB,IAChB,yBAA0B,IAC1B,wBAAyB,IACzB,qBAAsB,IACtB,eAAgB,IAChB,sBAAuB,IACvB,wBAAyB,IACzB,OAAQ,IACR,oBAAqB,IACrB,YAAa,IACb,mBAAoB,IACpB,wBAAyB,IACzB,oBAAqB,IACrB,kCAAmC,IACnC,gCAAiC,IACjC,wBAAyB,IACzB,kBAAmB,IACnB,cAAe,IACf,sBAAuB,IACvB,kBAAmB,IACnB,6BAA8B,IAC9B,0BAA2B,IAC3B,uBAAwB,IACxB,gBAAiB,IACjB,eAAgB,IAChB,kCAAmC,GACpC,EAEa,kBAAoB,OAAO,YACvC,OAAO,QAAQ,SAAS,EAAE,IAAI,EAAE,GAAG,KAAO,CAAC,EAAG,EAAC,CAAC,CACjD,EAOA,SAAS,oBAAoB,CAAC,OAAwB,CACrD,IAAI,cAAgB,OAEpB,MAAO,cAAc,SAAS,GAAG,EAChC,cAAgB,cAAc,MAAM,EAAG,EAAE,EAE1C,OAAO,cAGR,IAAM,QAAU,IAAI,YAEP,WAAa,MAAO,IAAa,SAA0B,CACvE,GAAI,OAAO,MAAQ,SAClB,MAAM,IAAI,UAAU,4CAA4C,EAEjE,GAAI,SAAW,KAAM,MAAM,IAAI,UAAU,8BAA8B,EAEvE,IAAM,UAAY,MAAM,OAAO,OAAO,UACrC,MACA,QAAQ,OAAO,MAAM,EACrB,CAAE,KAAM,OAAQ,KAAM,SAAU,EAChC,GACA,CAAC,MAAM,CACR,EAEM,WAAa,MAAM,OAAO,OAAO,KACtC,OACA,UACA,QAAQ,OAAO,GAAG,CACnB,EAQA,OACC,IACA,IACA,qBAAqB,OAAO,KAAK,UAAU,EAAE,SAAS,QAAQ,CAAC,GAIpD,aAAe,MAAO,MAAe,SAA0B,CAC3E,GAAI,OAAO,QAAU,SACpB,MAAM,IAAI,UAAU,wCAAwC,EAE7D,GAAa,SAAT,KAAiB,MAAM,IAAI,UAAU,8BAA8B,EAEvE,IAAM,eAAiB,MAAM,MAAM,EAAG,MAAM,YAAY,GAAG,CAAC,EAG5D,OAFsB,MAAM,WAAW,eAAgB,MAAM,IAEpC,MAAQ,eAAiB,IAGtC,eAAiB,CAC7B,UACA,SACA,SACI,CACJ,IAAK,WAAa,OAAO,YAAc,WAAa,SAAU,OAE9D,QAAY,IAAK,SAAU,OAAO,QAAQ,QAAQ,EAAG,CACpD,GAAI,iBAAiB,QAAU,OAAO,WAAY,SAElD,IAAM,EAAI,UACT,KAGD,GAAI,OAAO,IAAM,WAAY,CAC5B,IAAM,KAAO,EAAE,KAAK,EAEpB,GAAI,OAAO,OAAS,SACnB,QAAY,GAAG,MAAM,OAAO,QAAQ,IAAI,EACvC,OAAO,EAAyB,EAAE,CACjC,GAAI,EACL,CAAC,EAGJ,OAAO,SAAS,OAIL,mBACZ,EACC,WACA,aAKD,CAAC,YACD,CACC,KAMA,KACI,CACJ,GAAI,OAAO,OAAS,WACnB,KAAO,CACN,GAAI,IACL,EAGD,GAAI,YAAc,UACjB,KAAO,IACH,KACH,QAAS,SACV,EAGD,IAAK,UAAU,WAAY,UAAU,WAAa,CAAC,EACnD,GAAI,OAAO,UAAU,aAAe,WACnC,UAAU,WAAa,CAAC,UAAU,UAAU,EAC7C,IAAK,MAAM,QAAQ,UAAU,UAAU,EACtC,UAAU,WAAa,CAAC,UAAU,UAAU,EAE7C,GAAI,OAAQ,MAAQ,MAAM,QAAQ,IAAI,EAAG,CACxC,GAAI,MAAM,QAAQ,IAAI,EACrB,UAAU,WACT,UAAU,WACT,OAAO,IAAI,EACT,eAAU,WAAW,KAAK,IAAI,EAEnC,OAGD,IAAQ,OAAS,QAAS,MAAQ,SAAY,KAE9C,GAAI,OAAO,KAAO,WAAY,GAAK,CAAE,EAAG,EAExC,GAAI,QAAU,SACb,IAAK,MAAM,QAAQ,EAAE,EACpB,GAAI,SAAW,SACZ,WAAW,WAAqB,QAAQ,EAAE,EAE3C,KAAC,WAAW,WAAqB,KAAK,EAAE,EAG1C,QAAI,SAAW,SACd,WAAW,WAAa,GAAG,OAC1B,WAAW,UACZ,EAEA,gBAAW,WACV,WAAW,WACV,OAAO,EAAE,EAIb,SAAK,MAAM,QAAQ,EAAE,EACpB,GAAI,SAAW,SACZ,UAAU,WAAqB,QAAQ,EAAE,EAE1C,KAAC,UAAU,WAAqB,KAAK,EAAE,EAGzC,QAAI,SAAW,SACd,UAAU,WAAa,GAAG,OAAO,UAAU,UAAU,EAErD,eAAU,WAAa,UAAU,WAAW,OAAO,EAAE,GAMpD,mBAAqB,CAAC,UAA4C,CACvE,GAAI,OAAO,UAAY,SAAU,OAAO,QAExC,GAAI,QAAQ,OAAS,GAAI,CACxB,GAAI,QAAQ,KAAK,EAAE,SAAW,EAAG,OAAO,KAExC,IAAM,OAAS,OAAO,OAAO,EAC7B,GAAI,OAAO,MAAM,MAAM,EAAG,OAAO,KAEjC,OAAO,OAIR,GAAI,QAAQ,SAAW,GAAI,CAC1B,GAAI,QAAQ,KAAK,EAAE,SAAW,EAAG,OAAO,KAExC,IAAM,OAAS,OAAO,OAAO,EAC7B,GAAI,OAAO,MAAM,MAAM,GAAK,OAAO,SAAS,IAAM,QAAS,OAAO,KAElE,OAAO,OAGR,OAAO,MAGK,gBAAkB,CAAC,UAC/B,mBAAmB,OAAO,IAAM,KAE1B,MAAM,YAA0C,CAK9C,QACA,UALR,KAA4B,KAC5B,SAA2B,CAAC,EAE5B,WAAW,CACH,QAAgC,QAAQ,MACxC,UAAwB,IAAM,GACpC,CAFM,qBACA,4BAMJ,KAAI,EAAG,CACV,OAAO,KAAK,SAAS,OAOtB,GAAM,CAAC,QAAqB,CAI3B,GAHA,KAAK,SAAS,KAAK,OAAO,EAC1B,KAAK,OAAS,KAAK,MAAM,EAErB,KAAK,SAAS,SAAW,EAAG,KAAK,KAAK,KAAK,SAAS,EACxD,OAAO,aAGM,MAAK,EAAG,CACrB,MAAO,KAAK,SAAS,OAAS,EAAG,CAChC,GAAI,CACH,MAAM,KAAK,SAAS,GACnB,MAAO,MAAO,CACf,KAAK,QAAQ,KAAK,EAEnB,KAAK,SAAS,MAAM,EAErB,KAAK,KAAO,KAIb,IAAuC,CACtC,YAIA,WAImC,CACnC,OAAQ,KAAK,MAAQ,QAAQ,QAAQ,GAAG,KAAK,YAAa,UAAU,EAEtE,CAEO,IAAM,cAAgB,CAC5B,GAEA,UAC+B,CAC/B,IAAK,GAAI,OAAO,GAEhB,IAAK,MAAM,QAAQ,EAAE,GAEpB,GAAI,OAAO,KAAO,YAAc,OAAO,KAAO,SAC7C,OAAO,QAAU,CAAE,GAAI,OAAQ,EAAI,CAAE,EAAG,EACpC,QAAI,OAAQ,GAAI,OAAO,GAG7B,IAAM,IAAuB,CAAC,EAC9B,QAAW,KAAK,GAEf,GAAI,OAAO,IAAM,YAAc,OAAO,IAAM,SAC3C,IAAI,KAAK,QAAU,CAAE,GAAI,EAAG,OAAQ,EAAI,CAAE,GAAI,CAAE,CAAC,EAC7C,QAAI,OAAQ,EAAG,IAAI,KAAK,CAAC,EAG/B,OAAO,KAGK,0BAA4B,CAAC,IAAoC,CAC7E,GAAI,EAAE,MAAO,EAAE,MAAQ,cAAc,EAAE,KAAK,EAC5C,GAAI,EAAE,QAAS,EAAE,QAAU,cAAc,EAAE,OAAO,EAClD,GAAI,EAAE,MAAO,EAAE,MAAQ,cAAc,EAAE,KAAK,EAC5C,GAAI,EAAE,UAAW,EAAE,UAAY,cAAc,EAAE,SAAS,EACxD,GAAI,EAAE,aAAc,EAAE,aAAe,cAAc,EAAE,YAAY,EACjE,GAAI,EAAE,YAAa,EAAE,YAAc,cAAc,EAAE,WAAW,EAC9D,GAAI,EAAE,YAAa,EAAE,YAAc,cAAc,EAAE,WAAW,EAC9D,GAAI,EAAE,cAAe,EAAE,cAAgB,cAAc,EAAE,aAAa,EACpE,GAAI,EAAE,MAAO,EAAE,MAAQ,cAAc,EAAE,KAAK,EAC5C,GAAI,EAAE,MAAO,EAAE,MAAQ,cAAc,EAAE,KAAK,EAC5C,GAAI,EAAE,KAAM,EAAE,KAAO,cAAc,EAAE,IAAI,EAEzC,OAAO,GAGK,cAAgB,CAAC,IAA6C,CAE1E,GAAI,EAAE,OAAO,IAAK,EAAE,MAAQ,EAAE,MAAM,IAAI,CAAC,IAAM,EAAE,EAAE,EAEnD,GAAI,EAAE,SAAS,IAAK,EAAE,QAAU,EAAE,QAAQ,IAAI,CAAC,IAAM,EAAE,EAAE,EAEzD,GAAI,EAAE,OAAO,IAAK,EAAE,MAAQ,EAAE,MAAM,IAAI,CAAC,IAAM,EAAE,EAAE,EAEnD,GAAI,EAAE,WAAW,IAAK,EAAE,UAAY,EAAE,UAAU,IAAI,CAAC,IAAM,EAAE,EAAE,EAC/D,GAAI,EAAE,cAAc,IAEnB,EAAE,aAAe,EAAE,aAAa,IAAI,CAAC,IAAM,EAAE,EAAE,EAEhD,GAAI,EAAE,aAAa,IAAK,EAAE,YAAc,EAAE,YAAY,IAAI,CAAC,IAAM,EAAE,EAAE,EAErE,GAAI,EAAE,aAAa,IAAK,EAAE,YAAc,EAAE,YAAY,IAAI,CAAC,IAAM,EAAE,EAAE,EACrE,GAAI,EAAE,eAAe,IAEpB,EAAE,cAAgB,EAAE,cAAc,IAAI,CAAC,IAAM,EAAE,EAAE,EAElD,GAAI,EAAE,OAAO,IAAK,EAAE,MAAQ,EAAE,MAAM,IAAI,CAAC,IAAM,EAAE,EAAE,EAC9C,OAAE,MAAQ,CAAC,EAEhB,GAAI,EAAE,OAAO,IAAK,EAAE,MAAQ,EAAE,MAAM,IAAI,CAAC,IAAM,EAAE,EAAE,EAEnD,GAAI,EAAE,MAAM,IAAK,EAAE,KAAO,EAAE,KAAK,IAAI,CAAC,IAAM,EAAE,EAAE,EAEhD,OAAO,GAGK,eAAiB,CAAC,aAC7B,CACA,KAAM,UAAU,KAChB,OAAQ,UAAU,OAClB,QAAS,UAAU,QACnB,MAAO,UAAU,MACjB,IAAK,UAAU,IACf,OAAQ,UAAU,OAClB,KAAM,UAAU,KAChB,MAAO,UAAU,MACjB,IAAK,UAAU,GAChB,GAOY,SAAW,CACvB,IACA,OAAsC,MAClC,SAAS,SAAS,IAAK,MAAM,EAIrB,iBAAmB,OAAO,gBAAgB,EAO1C,kBAAoB,OAAO,iBAAiB,EAG5C,KAAO,CACnB,QACuB,CACvB,IAAM,SAAW,IAAI,SAIrB,GAFA,SAAS,kBAAoB,CAAC,EAE1B,MACH,QAAY,IAAK,SAAU,OAAO,QAAQ,KAAK,EAAG,CACjD,GAAI,MAAM,QAAQ,KAAK,EAAG,CAEzB,SAAS,kBAAkB,KAAO,CAAC,EAEnC,QAAW,KAAK,MAAO,CACtB,GAAI,iBAAiB,KACpB,SAAS,OAAO,IAAK,MAAO,MAAM,IAAI,EAClC,QAAI,iBAAiB,WAEzB,SAAS,OAAO,IAAK,MAAM,MAAO,MAAM,OAAO,IAAI,EAC/C,cAAS,OAAO,IAAK,KAAY,EAGtC,SAAS,kBAAkB,KAAK,KAAK,KAAK,EAG3C,SAGD,GAAI,iBAAiB,KAAM,SAAS,OAAO,IAAK,MAAO,MAAM,IAAI,EAC5D,QAAI,iBAAiB,WAEzB,SAAS,OAAO,IAAK,MAAM,MAAO,MAAM,OAAO,IAAI,EAC/C,cAAS,OAAO,IAAK,KAAY,EAEtC,SAAS,kBAAkB,KAAO,MAGpC,OAAO,UAGK,SAAW,IAAM,CAC7B,IAAM,KAAO,OAAO,WAAW,EAC/B,OAAO,KAAK,MAAM,EAAG,CAAC,EAAI,KAAK,MAAM,GAAI,EAAE,GAI/B,oBAAsB,CAClC,QACwB,CACxB,IAAM,OAAmB,CAAC,EAE1B,QAAS,EAAI,EAAG,EAAI,MAAM,OAAQ,IAAK,CACtC,IAAM,KAAO,MAAM,GAEnB,GAAI,KAAK,SAAU,CAClB,GAAI,OAAO,SAAS,KAAK,QAAQ,EAChC,MAAM,OAAO,EAAG,CAAC,EACjB,IAGD,OAAO,KAAK,KAAK,QAAQ,GAI3B,OAAO,OAQK,aAAe,CAC3B,OACA,GAA0B,WAChB,CACV,IAAK,OAAQ,OAEb,GAAI,KAAO,SAAU,CACpB,QAAW,SAAS,OACnB,GAAI,UAAW,OAAS,MAAM,QAAU,QACvC,MAAM,MAAQ,SAEhB,OAGD,QAAW,SAAS,OAAQ,GAAI,UAAW,MAAO,MAAM,MAAQ,UAsDpD,aAAe,CAAC,OAAiB,CAC7C,GAAI,KAAK,WAAW,KAAK,OAAS,CAAC,IAAM,GACxC,OAAO,KAAK,MAAM,EAAG,KAAK,OAAS,CAAC,EAErC,OAAO,KAAO,KAGF,WAAa,CAAC,MAAiB,CAC3C,IAAK,IAAK,MAAO,GAEjB,QAAW,KAAK,IAAK,MAAO,GAE5B,MAAO,IASD,IAAM,WAAa,CAAC,MAAgB,QAAU,IAAU,CAAC,IAAM,CACrE,IAAI,QAAU,mBAAmB,IAAI,EAAE,QAAQ,OAAQ,GAAG,EAE1D,GAAI,QAAS,QAAU,QAAQ,QAAQ,OAAQ,GAAG,EAAE,QAAQ,OAAQ,GAAG,EAEvE,OAAO,SAGK,+BAAiC,IAAM,CACnD,GAAG,OAAO,MAAQ,YAAa,MAAO,GAEtC,IAAM,OAAS,IAAI,QAAQ,MAAM,GAAG,EACpC,IAAK,OAAO,GAAK,IAAM,OAAO,GAAK,IAAM,OAAO,GAAK,GAAI,MAAO,GAEhE,MAAO,KACL,EDvkCH,IAAM,IACL,OAAO,MAAQ,YACZ,IAAI,IACJ,OAAO,UAAY,YAClB,SAAS,IACT,OAEQ,WAAa,OAAO,iBAAiB,EAGrC,cAAgB,KAAK,UAAY,KAAK,OAAS,aASrD,MAAM,0BAQX,CACD,KACA,SAEA,WAAW,CAAC,KAAY,SAAa,CACpC,IAAM,IACL,WACC,QAAQ,kBAEP,kBAAkB,MACjB,MAGJ,KAAK,KAAO,UAAU,OAAS,KAC/B,KAAK,SAAW,IAElB,CAEO,IAAM,OAAS,CAMrB,KACA,WACI,IAAI,2BAAoC,KAAM,QAAe,EAKrD,MAAQ,OAEd,MAAM,4BAA4B,KAAM,CAC9C,KAAO,wBACP,OAAS,IAET,WAAW,CAAC,QAAkB,CAC7B,MAAM,SAAW,uBAAuB,EAE1C,CAEO,MAAM,sBAAsB,KAAM,CACxC,KAAO,YACP,OAAS,IAET,WAAW,CAAC,QAAkB,CAC7B,MAAM,SAAW,WAAW,EAE9B,CAEO,MAAM,mBAAmB,KAAM,CACrC,KAAO,QACP,OAAS,IAET,WAAW,CAAC,MAAe,CAC1B,MAAM,cAAe,CACpB,KACD,CAAC,EAEH,CAEO,MAAM,+BAA+B,KAAM,CAKzC,IAJR,KAAO,2BACP,OAAS,IAET,WAAW,CACH,IACP,QACC,CACD,MAAM,SAAW,IAAI,mCAAmC,EAHjD,aAKT,CAEO,IAAM,cAAgB,CAAC,SAAkC,CAC/D,IAAK,OACJ,MAAO,CACN,QAAS,MACV,EAED,IAAQ,QAAS,KAAM,MAAO,MAAS,OAEjC,SAAW,KAAK,MAAM,CAAC,EAAE,WAAW,IAAK,GAAG,EAC5C,OAAS,OAAS,GAExB,OAAQ,UACF,IACJ,MAAO,IACH,OACH,QAAS,OACN,+BACA,aAAa,kCACjB,MAEI,IACJ,MAAO,IACH,OACH,QAAS,OACN,mBACA,aAAa,sBACjB,MAEI,IAEJ,IAAM,WAAa,QAAQ,QAAQ,GAAG,EAChC,OAAS,QAAQ,MACtB,WAAa,EACb,QAAQ,QAAQ,IAAK,WAAa,CAAC,CACpC,EAEA,MAAO,IACH,OACH,QAAS,OACN,2BACA,aAAa,uBAAuB,QACxC,MAEI,IACJ,MAAO,IACH,OACH,QAAS,GAAG,QACV,MAAM,EAAG,CAAC,EACV,KAAK,eAAe,mBAAmB,QACvC,MAAM,CAAC,EACP,KAAK,gBAAgB,OACxB,MAEI,IACJ,IAAM,MAAQ,OAAM,OAAO,MACzB,IAAI,CAAC,IAA+B,IAAI,GAAG,QAAU,EAAE,OAAO,EAC9D,KAAK,IAAI,EAEX,MAAO,IACH,OACH,QAAS,OACN,0BAA0B,QAC1B,aAAa,+BAA+B,OAChD,UAGA,MAAO,CAAE,QAAS,WAAY,MAAM,IAIhC,MAAM,wBAAwB,KAAM,CAKlC,SACA,SACA,QANR,KAAO,oBACP,OAAS,IAET,WAAW,CACH,SACA,SACA,QAAU,IAAI,kCACpB,CACD,MAAM,OAAO,EAJN,uBACA,uBACA,qBAIP,OAAO,eAAe,KAAM,gBAAgB,SAAS,EAGtD,UAAU,CAAC,QAA+B,CACzC,GAAI,aACH,OAAO,IAAI,SACV,KAAK,UAAU,CACd,KAAM,aACN,GAAI,MACL,CAAC,EACD,CACC,OAAQ,IACR,QAAS,IACL,QACH,eAAgB,kBACjB,CACD,CACD,EAED,OAAO,IAAI,SACV,KAAK,UAAU,CACd,KAAM,aACN,GAAI,OACJ,QAAS,oBACT,QAAS,KAAK,QACd,SAAU,KAAK,SACf,SAAU,KAAK,QAChB,CAAC,EACD,CACC,OAAQ,IACR,QAAS,IACL,QACH,eAAgB,kBACjB,CACD,CACD,EAEF,CAEO,MAAM,wBAAwB,KAAM,CAKlC,KACA,UACA,MANR,KAAO,aACP,OAAS,IAET,WAAW,CACH,KACA,UACA,MACP,OACC,CACD,GACC,OACA,OAAO,QAAU,UACjB,iBAAiB,2BAEjB,MAAQ,MAAM,SAEf,IAAM,OACL,QAAQ,MAAM,IACb,aACE,QACA,WAAY,WACX,UAAU,OAAO,KAAK,EAAE,MAAM,EAC9B,MAAM,OAAO,UAAW,KAAK,EAAE,MAAM,GAEpC,YACL,QAAO,QAAQ,SAAW,QAAO,QAAQ,QAAU,OAChD,OAAO,OAAM,OAAO,QAAU,WAC7B,OAAM,OAAO,MAAM,CACnB,KACA,UACA,SACI,OAAM,EAAG,CACZ,MAAO,CAAC,GAAG,UAAU,OAAO,KAAK,CAAC,EAAE,IACnC,aACD,EAEF,CAAC,EACA,OAAM,OAAO,MACd,OAEE,SAAW,QAAO,MAAQ,OAC5B,QAAU,GAEd,GAAI,cAAgB,OACnB,QACC,OAAO,cAAgB,SACpB,KAAK,UAAU,WAAW,EAC1B,YAAc,GACZ,QAAI,aACV,QAAU,KAAK,UAAU,CACxB,KAAM,aACN,GAAI,KACJ,QAAS,cAAc,MAAK,EAAE,QAC9B,QAAS,QAAO,QAChB,MAAO,KACR,CAAC,EACK,KAEN,IAAM,OAAS,WAAW,QAAU,UAC9B,QACL,WAAY,UACT,CAAC,GAAG,UAAU,OAAO,KAAK,CAAC,EAAE,IAAI,aAAa,EAC9C,CAAC,GAAG,MAAM,OAAO,UAAW,KAAK,CAAC,EAAE,IAAI,aAAa,EAErD,SAEJ,GAAI,CACH,SAAW,MAAM,OAAO,MAAM,EAC7B,MAAO,OAAO,CACf,SAAW,CACV,KAAM,kCAEN,QAAS,QAAO,QAChB,YACD,EAGD,QAAU,KAAK,UACd,CACC,KAAM,aACN,GAAI,KACJ,QAAS,cAAc,MAAK,EAAE,QAC9B,SAAU,SACV,QAAS,QAAO,QAChB,SACA,MAAO,MACP,cACD,EACA,KACA,CACD,EAGD,MAAM,OAAO,EAzFN,eACA,yBACA,iBAyFP,OAAO,eAAe,KAAM,gBAAgB,SAAS,KAGlD,IAAG,EAAG,CACT,MAAO,WAAY,KAAK,UACrB,CAAC,GAAG,KAAK,UAAU,OAAO,KAAK,KAAK,CAAC,EAAE,IAAI,aAAa,EAEzD,CAAC,GAAG,MAAM,OAAO,KAAK,UAAW,KAAK,KAAK,CAAC,EAAE,IAAI,aAAa,QAG3D,cAAa,CACnB,UACC,CAED,IAAM,MAAQ,WAAY,UAAY,UAAU,OAAS,UAEzD,GAAI,CACH,OAAO,MAAM,OAAO,KAAK,EACxB,KAAM,CACP,OAAO,UAIL,MAAK,EAAG,CACX,OAAO,gBAAgB,cAAc,KAAK,SAAS,EAGpD,UAAU,CAAC,QAA+B,CACzC,OAAO,IAAI,SAAS,KAAK,QAAS,CACjC,OAAQ,IACR,QAAS,IACL,QACH,eAAgB,kBACjB,CACD,CAAC,EAEH,CH/VO,IAAM,SAAW,CAAC,EAAY,SAAuB,CAC3D,GAAI,CACH,OAAO,KAAK,MAAM,CAAW,EAC5B,KAAM,CACP,MAAM,IAAI,gBAAgB,WAAY,OAAQ,CAAC,IAI1C,SAAS,UAAgD,CAC/D,KACA,KACmB,CACnB,IAAK,aAAa,IAAI,IAAI,EAAG,aAAa,IAAa,KAAM,IAAI,EAEjE,MAAQ,CAAC,QAAU,CAAC,IAAM,OAAO,IAAK,SAAU,MAAO,IAAK,CAAC,EAGvD,IAAM,QAAU,CAAuB,SAAc,CAC3D,GAAI,CACH,IAAM,SAAW,aAAa,QAAQ,MAAM,EAS5C,OAJA,SAAS,OAAS,IAAM,OAAM,OAAO,MAAM,EAC3C,SAAS,MAAQ,CAAC,IACjB,IAAI,gBAAgB,WAAY,OAAQ,EAAG,SAAS,OAAO,CAAC,CAAC,EAEvD,SACN,KAAM,CACP,MAAO,CACN,MAAO,CAAC,IAAe,OAAM,MAAM,OAAQ,CAAC,EAC5C,WAAY,CAAC,IAAe,CAC3B,IAAK,OAAM,MAAM,OAAQ,CAAC,EACzB,MAAM,IAAI,gBACT,WACA,OACA,EACA,OAAM,OAAO,OAAQ,CAAC,CACvB,GAEF,OAAQ,CAAC,IAAe,OAAM,OAAO,OAAQ,CAAC,EAC9C,OAAQ,IAAM,OAAM,OAAO,MAAM,EACjC,MAAO,CAAC,IACP,IAAI,gBACH,WACA,OACA,EACA,OAAM,OAAO,OAAQ,CAAC,CACvB,CACF,IAIW,cAAgB,CAAC,OAAmB,CAChD,GAAI,OAAO,OAAS,SACnB,OAAQ,KAAK,MAAM,EAAE,OACf,IACJ,OAAQ,KAAK,MAAM,EAAG,KAAK,OAAS,CAAC,EAAI,SAErC,IACJ,OAAQ,KAAK,MAAM,EAAG,KAAK,OAAS,CAAC,EAAI,gBAGzC,OAAQ,KAGX,OAAO,MAGK,mBAAqB,CAAC,KAAc,YAAsB,CACtE,GAAI,KAAK,WAAW,SAAS,EAAG,MAAO,GAEvC,OACC,UAAU,WAAW,UAAU,OAAS,CAAC,IAAM,IAC/C,UAAU,WAAW,UAAU,OAAS,CAAC,IAAM,IAC/C,KAAK,WAAW,UAAU,MAAM,EAAG,EAAE,CAAC,GAIpC,sBAAwB,GACtB,6BAA+B,IAAM,CAC1C,IAAK,sBACJ,QAAQ,KACP,uKACD,EACA,sBAAwB,IAIb,aAAe,SACpB,oBACL,KAAK,CAAC,IAAM,CAEZ,OADA,kBAAoB,EAAE,iBACf,kBACP,EACA,MAAM,4BAA4B,EAEjC,kBACS,iBAAmB,CAAC,QAAsB,CACtD,GAAI,kBAAmB,OAAO,kBAAkB,KAAI,EAEpD,OAAO,aAAa,EAAE,KAAK,CAAC,MAAQ,CACnC,GAAI,IAAK,OAAO,IAAI,KAAI,EACxB,GAGW,sBAAwB,MACpC,MACA,UAEA,KAAO,OAAM,MAAQ,KACjB,CACJ,IAAK,MAAM,OAEX,IAAM,OAAS,MAAM,iBAAiB,KAAI,EAC1C,IAAK,OAAQ,MAAM,IAAI,gBAAgB,KAAM,SAAS,EAEtD,GAAI,OAAO,YAAc,UACxB,IAAK,mBAAmB,OAAO,KAAM,SAAS,EAC7C,MAAM,IAAI,gBAAgB,KAAM,SAAS,EAE3C,QAAS,EAAI,EAAG,EAAI,UAAU,OAAQ,IACrC,GAAI,mBAAmB,OAAO,KAAM,UAAU,EAAE,EAAG,MAAO,GAE3D,MAAM,IAAI,gBAAgB,KAAM,SAAS,GAG7B,aAAe,CAAC,QAAsB,QAAe,CACjE,GAAI,iBAAiB,WAAY,MAAO,GAExC,KAAM,iBAAiB,MAAO,MAAO,GAErC,GAAI,QAAQ,SAAW,MAAM,KAAO,cAAc,QAAQ,OAAO,EAChE,MAAO,GAER,GAAI,QAAQ,SAAW,MAAM,KAAO,cAAc,QAAQ,OAAO,EAChE,MAAO,GAIR,GAAI,QAAQ,UAAW,CACtB,GAAI,OAAO,QAAQ,YAAc,SAChC,OAAO,mBAAmB,MAAM,KAAM,QAAQ,SAAS,EAExD,QAAS,EAAI,EAAG,EAAI,QAAQ,UAAU,OAAQ,IAC7C,GAAI,mBAAmB,MAAM,KAAM,QAAQ,UAAU,EAAE,EACtD,MAAO,GAET,MAAO,GAGR,MAAO,IFwWR,wHAMA,uBAAS,gCAAc,wCACvB,uBAAS,2BAAc,4CArevB,IAAM,EAAI,OAAO,OAAO,CAAC,EAAG,IAAI,EAUhC,WACC,YACA,CAAC,OAAQ,SACP,OAAO,QAAU,UACjB,OAAO,QAAU,UACjB,QAAU,OACX,OAAO,KAAK,SAAS,KAAc,CACrC,EAEA,IAAM,cAAgB,WACrB,QACA,CAAC,QAAS,QAAU,CACnB,IAAK,MAAM,QAAQ,KAAK,EAAG,OAAO,aAAa,QAAS,KAAK,EAE7D,GAAI,QAAQ,UAAY,MAAM,OAAS,QAAQ,SAAU,MAAO,GAEhE,GAAI,QAAQ,UAAY,MAAM,OAAS,QAAQ,SAAU,MAAO,GAEhE,QAAS,EAAI,EAAG,EAAI,MAAM,OAAQ,IACjC,IAAK,aAAa,QAAS,MAAM,EAAE,EAAG,MAAO,GAE9C,MAAO,GAET,EAEM,iBAAmB,WACxB,aACA,EAAG,YAAa,QAAU,QAAU,CACnC,KAAM,iBAAiB,UAAW,MAAO,GAEzC,GAAI,SAAU,CACb,KAAM,oBAAoB,OACzB,MAAM,IAAI,gBAAgB,WAAY,OAAQ,KAAK,EAEpD,IAAK,SAAS,MAAM,MAAM,iBAAiB,EAC1C,MAAM,SAAS,MAAM,MAAM,iBAAiB,EAG9C,MAAO,GAET,EAea,WAAa,CAEzB,OAAQ,CAAC,WAAmC,KAAK,OAAO,QAAQ,EAChE,QAAS,CAAC,WAA6B,CACtC,IAAM,OAAS,KAAK,OAAO,QAAQ,EAC7B,SAAW,QAAQ,MAAM,EAE/B,OAAO,EACL,UACA,EAAE,MACD,CACC,EAAE,OAAO,CACR,OAAQ,UACR,QAAS,CACV,CAAC,EACD,EAAE,OAAO,QAAQ,CAClB,EACA,QACD,CACD,EACC,OAAO,CAAC,QAAU,CAClB,IAAM,QAAU,MAChB,GAAI,MAAM,MAAM,EAAG,OAAO,MAE1B,GAAI,WAAa,SAAS,MAAM,MAAM,EACrC,MAAM,SAAS,MAAM,KAAK,EAE3B,OAAO,OACP,EACA,OAAO,CAAC,QAAU,KAAK,GAG1B,QAAS,CAAC,WAAwC,CACjD,IAAM,OAAS,KAAK,QAAQ,QAAQ,EAC9B,SAAW,QAAQ,MAAM,EAE/B,OAAO,EACL,UACA,EAAE,MACD,CACC,EAAE,OAAO,CACR,OAAQ,UACR,QAAS,CACV,CAAC,EACD,KAAK,QAAQ,QAAQ,CACtB,EACA,QACD,CACD,EACC,OAAO,CAAC,QAAU,CAClB,IAAM,QAAU,MAEhB,IAAK,SAAS,MAAM,MAAM,EAAG,MAAM,SAAS,MAAM,MAAM,EAExD,OAAO,OACP,EACA,OAAO,CAAC,QAAU,KAAK,GAG1B,KAAM,CAAC,WAA2B,CACjC,IAAM,OAAS,KAAK,KAAK,QAAQ,EAC3B,SAAW,QAAQ,MAAM,EAEzB,SAAW,UAAU,QACxB,IAAI,KAAK,SAAS,OAAO,EACzB,OAEH,OAAO,EACL,UACA,EAAE,MACD,CACC,KAAK,KAAK,QAAQ,EAClB,EAAE,OAAO,CACR,OAAQ,YACR,QAAS,UAAU,YAAY,CAChC,CAAC,EACD,EAAE,OAAO,CACR,OAAQ,OACR,QAAS,UAAU,YAAY,CAChC,CAAC,EACD,EAAE,OAAO,CAAE,QAAS,UAAU,QAAQ,CAAE,CAAC,CAC1C,EACA,QACD,CACD,EACC,OAAO,CAAC,QAAU,CAClB,GAAI,OAAO,QAAU,SAAU,CAC9B,IAAM,MAAO,IAAI,KAAK,KAAK,EAE3B,IAAK,SAAS,MAAM,KAAI,EAAG,MAAM,SAAS,MAAM,KAAI,EAEpD,OAAO,MAGR,GAAI,iBAAiB,KAAM,OAAO,MAElC,IAAM,MAAO,IAAI,KAAK,wBAAwB,KAAK,CAAC,EAEpD,IAAK,OAAQ,MAAM,MAAK,QAAQ,CAAC,EAChC,MAAM,IAAI,gBAAgB,WAAY,OAAQ,KAAI,EAEnD,IAAK,SAAS,MAAM,KAAI,EAAG,MAAM,SAAS,MAAM,KAAI,EAEpD,OAAO,MACP,EACA,OAAO,CAAC,QAAU,MAAM,YAAY,CAAC,GAGxC,cAAe,CAAC,WAA6B,CAC5C,IAAM,OAAS,KAAK,QAAQ,QAAQ,EAC9B,SAAW,QAAQ,MAAM,EAE/B,OAAO,EACL,UACA,EAAE,MACD,CACC,EAAE,QAAQ,QAAQ,EAClB,EAAE,OAAO,CACR,OAAQ,UACR,QAAS,EACV,CAAC,CACF,EACA,QACD,CACD,EACC,OAAO,CAAC,QAAU,CAClB,GAAI,OAAO,QAAU,SAAU,OAAO,QAAU,OAEhD,GAAI,QAAU,SAAc,SAAS,MAAM,KAAK,EAC/C,MAAM,SAAS,MAAM,KAAK,EAE3B,OAAO,MACP,EACA,OAAO,CAAC,QAAU,KAAK,GAG1B,aAAc,CACb,WACA,UACI,CACJ,IAAM,OAAS,EAAE,OAAO,WAAY,OAAO,EACrC,SAAW,QAAQ,MAAM,EAEzB,aAAe,KAAK,UAAU,SAAS,OAAO,CAAC,EAErD,OAAO,EACL,UACA,EAAE,MAAM,CACP,EAAE,OAAO,CACR,OAAQ,eACR,QAAS,YACV,CAAC,EACD,MACD,CAAC,CACF,EACC,OAAO,CAAC,QAAU,CAClB,GAAI,OAAO,QAAU,SAAU,CAC9B,GAAI,MAAM,WAAW,CAAC,IAAM,IAC3B,MAAM,IAAI,gBAAgB,WAAY,OAAQ,KAAK,EAEpD,IAAK,SAAS,MAAO,MAAQ,SAAS,MAAO,MAAM,CAAE,EACpD,MAAM,SAAS,MAAM,KAAK,EAE3B,OAAO,SAAS,OAAO,KAAK,EAG7B,OAAO,MACP,EACA,OAAO,CAAC,QAAU,CAClB,IAAI,SACJ,GAAI,OAAO,QAAU,SACpB,MAAQ,SAAU,SAAW,MAAQ,MAAM,EAE5C,IAAK,SAAS,MAAM,KAAK,EAAG,MAAM,SAAS,MAAM,KAAK,EAEtD,OAAO,UAAY,KAAK,UAAU,KAAK,EACvC,GAGH,YAAa,CACZ,SAAc,EAAE,OAAO,EACvB,UACI,CACJ,IAAM,OAAS,EAAE,MAAM,SAAU,OAAO,EAClC,SAAW,QAAQ,MAAM,EAEzB,OAAS,CAAC,MAAe,WAAa,KAAU,CACrD,GAAI,MAAM,WAAW,CAAC,IAAM,GAAI,CAC/B,IAAK,SAAS,MAAO,MAAQ,SAAS,MAAO,MAAM,CAAE,EACpD,MAAM,SAAS,MAAM,KAAK,EAE3B,OAAO,SAAS,OAAO,KAAK,EAI7B,GAAI,MAAM,QAAQ,GAAG,IAAM,GAAI,CAG9B,IAAK,SAAS,MAAM,KAAK,EAAG,MAAM,SAAS,MAAM,KAAK,EAEtD,OAAO,SAAS,OAAO,KAAK,EAG7B,GAAI,WAAY,OAAO,MAEvB,MAAM,IAAI,gBAAgB,WAAY,OAAQ,KAAK,GAGpD,OAAO,EACL,UACA,EAAE,MAAM,CACP,EAAE,OAAO,CACR,OAAQ,cACR,QAAS,SAAS,OACnB,CAAC,EACD,MACD,CAAC,CACF,EACC,OAAO,CAAC,QAAU,CAClB,GAAI,MAAM,QAAQ,KAAK,EAAG,CACzB,IAAI,OAAoB,CAAC,EAEzB,QAAS,EAAI,EAAG,EAAI,MAAM,OAAQ,IAAK,CACtC,IAAM,EAAI,MAAM,GAChB,GAAI,OAAO,IAAM,SAAU,CAC1B,IAAM,GAAI,OAAO,EAAG,EAAI,EACxB,GAAI,MAAM,QAAQ,EAAC,EAAG,OAAS,OAAO,OAAO,EAAC,EACzC,YAAO,KAAK,EAAC,EAElB,SAGD,OAAO,KAAK,CAAC,EAGd,OAAO,OAGR,GAAI,OAAO,QAAU,SAAU,OAAO,OAAO,KAAK,EAGlD,OAAO,MACP,EACA,OAAO,CAAC,QAAU,CAClB,IAAI,SACJ,GAAI,OAAO,QAAU,SACpB,MAAQ,SAAU,SAAW,MAAQ,MAAM,EAE5C,IAAK,SAAS,MAAM,KAAK,EACxB,MAAM,IAAI,gBAAgB,WAAY,OAAQ,KAAK,EAEpD,OAAO,UAAY,KAAK,UAAU,KAAK,EACvC,GAGH,KAAM,WACL,OACA,YACD,EAEA,MAAO,CAAC,QAAwB,CAAC,IAChC,EACE,UAAU,cAAc,OAAO,CAAC,EAChC,OAAO,CAAC,QAAU,CAClB,GAAI,MAAM,QAAQ,KAAK,EAAG,OAAO,MACjC,MAAO,CAAC,KAAK,EACb,EACA,OAAO,CAAC,QAAU,KAAK,EAE1B,SAAU,CAAoB,OAAW,UACxC,EAAE,MAAM,CAAC,OAAQ,EAAE,KAAK,CAAC,EAAG,OAAO,EAKpC,WAAY,CAAoB,OAAW,UAC1C,EAAE,MAAM,CAAC,OAAQ,EAAE,KAAK,EAAG,EAAE,UAAU,CAAC,EAAG,OAAO,EAEnD,OAAQ,CACP,YAEC,OACA,QACA,SACA,OACA,KACA,SACA,SACA,OACA,QACA,QACG,SAC2B,CAAC,IAC5B,CACJ,IAAM,EAAI,EAAE,OAAO,WAAY,OAAO,EAetC,OAbA,EAAE,OAAS,CACV,OACA,QACA,SACA,OACA,KACA,SACA,SACA,OACA,QACA,IACD,EAEO,GAGR,UAAW,CAKV,OACA,QAAyB,CAAC,IACtB,CACJ,IAAM,KAAO,OAAO,MAAM,CAAC,QAAU,OAAO,QAAU,QAAQ,EAC3D,CAAE,KAAM,QAAS,EACjB,OAAO,MAAM,CAAC,QAAU,OAAO,QAAU,QAAQ,EAChD,CAAE,KAAM,QAAS,EACjB,OAAO,MAAM,CAAC,QAAU,QAAU,IAAI,EACrC,CAAE,KAAM,MAAO,EACf,CAAC,EAEN,GAAI,OAAO,KAAK,CAAC,IAAM,OAAO,IAAM,UAAY,IAAM,IAAI,EACzD,MAAM,IAAI,MAAM,8CAA8C,EAE/D,MAAO,CAEN,QAAS,OAAO,MACb,SACF,OAAO,eACL,KACH,KAAM,MACP,GAGD,WAAY,CAAuB,EAAM,QAAU,KAAS,CAG3D,OAFA,EAAE,WAAa,QAER,GAGR,KAAM,CACL,EACA,QAAyB,CAAC,IACZ,CACd,IAAM,OAAS,EAAE,OAAO,EAAG,CAC1B,QAAS,KAAK,CAAC,CAAC,KACb,OACJ,CAAC,EACK,SAAW,QAAQ,MAAM,EAE/B,OAAO,EAAE,MAAM,CACd,OAEA,iBAAiB,CAChB,QACD,CAAC,CACF,CAAC,EAEH,EAEA,EAAE,cAAgB,WAAW,cAC7B,EAAE,aAAe,WAAW,aAC5B,EAAE,YAAc,WAAW,YAC3B,EAAE,QAAU,WAAW,QACvB,EAAE,QAAU,WAAW,QAEvB,EAAE,KAAO,CAAC,MAAQ,CACjB,GAAI,KAAK,KAAM,aAAa,EAE5B,OAAO,WAAW,KAAK,CACtB,QAAS,UACN,IACH,UAAW,KAAK,KAChB,KAAM,SACN,OAAQ,QACT,CAAC,GAGF,EAAE,MAAQ,CAAC,MAAQ,CAClB,GAAI,KAAK,KAAM,aAAa,EAE5B,OAAO,WAAW,MAAM,IACpB,IACH,WAAY,QACZ,QAAS,QACT,UAAW,KAAK,KAChB,KAAM,QACN,MAAO,IACH,IACH,QAAS,QACT,KAAM,SACN,OAAQ,QACT,CACD,CAAC,GAGF,EAAE,SAAW,CAAC,SAAW,WAAW,SAAS,MAAM,EACnD,EAAE,WAAa,WAAW,WAC1B,EAAE,OAAS,WAAW,OACtB,EAAE,KAAO,WAAW,KACpB,EAAE,UAAY,WAAW,UACzB,EAAE,WAAa,WAAW,WAC1B,EAAE,KAAO,WAAW,KOzeb,IAAM,iBAAmB,CAC/B,OACkD,CAElD,GAAI,KAAK,WAAW,OAAO,EAAG,KAAO,KAAK,MAAM,CAAC,EACjD,KAAO,KAAK,UAAU,EAEtB,IAAI,MAAQ,GAGZ,GAAI,KAAK,WAAW,CAAC,IAAM,IAG1B,GAFA,MAAQ,KAAK,QAAQ,KAAM,KAAK,QAAQ,GAAG,CAAC,EAExC,QAAU,GAAI,CACjB,IAAI,gBAAkB,MAEtB,MAAO,gBAAkB,EACxB,GAAI,KAAK,aAAa,eAAe,IAAM,GAAI,MAEhD,IAAI,KAAO,KAAK,MAAM,MAAQ,CAAC,EAC/B,GAAI,KAAK,WAAW,CAAC,IAAM,GAAI,KAAO,KAAK,UAAU,EAErD,MAAO,CACN,KAAK,MAAM,EAAG,eAAe,EAC7B,KACA,CACC,cAAe,KAAK,WAAW,CAAC,IAAM,GACvC,CACD,GAKF,GAAI,YAAY,KAAK,IAAI,GAGxB,GAFA,MAAQ,KAAK,QAAQ,IAAI,EAErB,QAAU,GAAI,CACjB,IAAI,KAAO,KAAK,MAAM,MAAQ,CAAC,EAC/B,GAAI,KAAK,WAAW,CAAC,IAAM,GAAI,KAAO,KAAK,UAAU,EAErD,MAAO,CACN,KAAK,MAAM,EAAG,KAAK,EACnB,KACA,CACC,cAAe,KAAK,WAAW,CAAC,IAAM,GACvC,CACD,GAKF,GAAI,KAAK,WAAW,UAAU,EAAG,CAChC,MAAQ,KAAK,QAAQ,GAAG,EACxB,IAAM,IAAM,KAAK,QAAQ,GAAG,EAE5B,MAAO,CACN,KAAK,MAAM,MAAQ,EAAG,GAAG,EACzB,KAAK,MAAM,IAAM,CAAC,EAClB,CACC,cAAe,EAChB,CACD,EAID,IAAM,MAAQ,KAAK,QAAQ,GAAG,EAE9B,GAAI,QAAU,GAAI,CACjB,IAAM,IAAM,KAAK,QAAQ;AAAA,EAAM,CAAC,EAC1B,UAAY,KAAK,MAAM,EAAG,GAAG,EAC7B,IAAM,UAAU,YAAY,GAAG,EAAI,EAEnC,KAAO,KAAK,MAAM,IAAM,CAAC,EAE/B,MAAO,CACN,UAAU,MAAM,MAAO,GAAG,EAC1B,IAAM,KACN,CACC,cAAe,EAChB,CACD,EAID,IAAM,EAAI,KAAK,MAAM;AAAA,EAAM,CAAC,EAE5B,MAAO,CAAC,EAAE,GAAI,EAAE,GAAI,CAAE,cAAe,EAAM,CAAC,GAWhC,iBAAmB,CAAC,YAAwC,CACxE,IAAM,MAAQ,UAAU,QAAQ,GAAG,EACnC,GAAI,QAAU,GAAI,MAAO,CAAC,GAAI,CAAC,EAE/B,IAAI,IAAM,MAAQ,EACd,KAAO,EAEX,KAAO,IAAM,UAAU,OAAQ,MAAO,CACrC,IAAM,KAAO,UAAU,WAAW,GAAG,EAGrC,GAAI,OAAS,IAAK,OAEb,QAAI,OAAS,IAAK,OAEvB,GAAI,OAAS,EAAG,MAGjB,GAAI,OAAS,EAAG,MAAO,CAAC,EAAG,UAAU,MAAM,EAE3C,MAAO,CAAC,MAAO,IAAM,CAAC,GAYV,wBAA0B,CACtC,YACsB,CACtB,IAAM,IAAM,UAAU,YAAY,GAAG,EACrC,GAAI,MAAQ,GAAI,MAAO,CAAC,GAAI,CAAC,EAE7B,IAAI,MAAQ,IAAM,EACd,KAAO,EAEX,KAAO,OAAS,EAAG,QAAS,CAC3B,IAAM,KAAO,UAAU,WAAW,KAAK,EAGvC,GAAI,OAAS,IAAK,OAEb,QAAI,OAAS,IAAK,OAEvB,GAAI,OAAS,EAAG,MAGjB,GAAI,OAAS,EAAG,MAAO,CAAC,GAAI,CAAC,EAE7B,MAAO,CAAC,MAAO,IAAM,CAAC,GAGV,iBAAmB,CAAC,YAAsB,CACtD,MAAO,GAAM,CACZ,IAAM,MAAQ,UAAU,QAAQ,GAAG,EACnC,GAAI,QAAU,GAAI,MAElB,IAAI,IAAM,UAAU,QAAQ,IAAK,KAAK,EACtC,GAAI,MAAQ,GAAI,IAAM,UAAU,QAAQ,IAAK,KAAK,EAAI,EACtD,GAAI,MAAQ,GAAI,IAAM,UAAU,OAEhC,UAAY,UAAU,MAAM,EAAG,KAAK,EAAI,UAAU,MAAM,GAAG,EAG5D,OAAO,WAcK,sBAAwB,CAAC,YAAsB,CAC3D,IAAI,eAAiB,GAGrB,GAAI,UAAU,WAAW,CAAC,IAAM,GAAI,UAAY,UAAU,MAAM,EAAG,EAAE,EAGrE,GAAI,UAAU,WAAW,CAAC,IAAM,IAC/B,eAAiB,GACjB,UAAY,UAAU,MAAM,EAAG,EAAE,EAGlC,UAAY,UAAU,QAAQ,aAAc,EAAE,EAAE,KAAK,EACrD,IAAI,WAAuB,CAAC,EAG5B,MAAO,GAAM,CAEZ,IAAK,MAAO,KAAO,iBAAiB,SAAS,EAC7C,GAAI,QAAU,GAAI,MAIlB,GADA,WAAW,KAAK,UAAU,MAAM,EAAG,MAAQ,CAAC,CAAC,EACzC,UAAU,WAAW,GAAG,IAAM,GAAI,MACtC,UAAY,UAAU,MAAM,GAAG,EAIhC,GADA,UAAY,iBAAiB,SAAS,EAClC,UAAW,WAAa,WAAW,OAAO,UAAU,MAAM,GAAG,CAAC,EAElE,IAAM,aAAqC,OAAO,OAAO,IAAI,EAC7D,QAAW,KAAK,WAAY,CAC3B,GAAI,EAAE,QAAQ,GAAG,IAAM,GAAI,CAC1B,aAAa,GAAK,GAClB,SAGD,QAAW,KAAK,EAAE,MAAM,GAAG,EAAG,aAAa,EAAE,KAAK,GAAK,GAGxD,MAAO,CACN,eACA,WAAY,YACb,GAQY,uBAAyB,CACrC,UACA,YACI,CACJ,IAAQ,WAAY,gBAAmB,sBAAsB,SAAS,EAGtE,GAAI,WAAW,MAAO,UAAU,MAAQ,GACxC,GAAI,WAAW,QAAS,UAAU,QAAU,GAC5C,GAAI,WAAW,KAAM,UAAU,KAAO,GACtC,GAAI,WAAW,OAAQ,UAAU,OAAS,GAC1C,GAAI,WAAW,IAAK,UAAU,IAAM,GACpC,GAAI,WAAW,OAAQ,UAAU,OAAS,GAC1C,GAAI,WAAW,MAAO,UAAU,MAAQ,GACxC,GAAI,WAAW,IAAK,UAAU,IAAM,GACpC,GAAI,WAAW,KAAM,UAAU,KAAO,GAEtC,GAAI,eAAgB,MAAO,KAAK,OAAO,KAAK,UAAU,EAAE,KAAK,IAAI,MAEjE,OAAO,OAAO,KAAK,UAAU,EAAE,KAAK,IAAI,GAGnC,aAAe,CACpB,KACA,QACA,QACI,CACJ,IAAM,OAAQ,IAAI,OACjB,GAAG,KAAK,QAAQ,sBAAuB,MAAM,cAC9C,EAEA,GAAI,QAAU,OAAW,OAAM,UAAY,MAE3C,IAAM,MAAQ,OAAM,KAAK,OAAO,EAEhC,OAAO,MAAQ,MAAM,MAAQ,IA4BvB,IAAM,UAAY,CAAC,KAAc,KAAc,MAAQ,IAAM,CACnE,GAAI,MAAQ,EAAG,MAAO,CAAC,EAEvB,IAAM,QAAoB,CAAC,EAEvB,QAAU,KAEd,MAAO,GAAM,CACZ,IAAI,MAAQ,aAAa,MAAQ,KAAM,OAAO,EAE9C,GAAI,QAAU,GAAI,MAAQ,aAAa,IAAM,KAAM,OAAO,EAE1D,GAAI,QAAU,GAAI,CASjB,IAAI,UAAY,QAAQ,QAAQ,MAAQ,IAAI,EAC5C,GAAI,YAAc,GAAI,UAAY,QAAQ,QAAQ,IAAM,IAAI,EAE5D,GAAI,UAAY,EAAI,KAAK,SAAW,QAAQ,OAAQ,MAEpD,MAAQ,UAGT,IAAM,KAAO,QAAQ,MAAM,EAAG,KAAK,EAG7B,SAAW,KAAK,YAAY,GAAG,EASjC,SAAW,KAAK,MAAM,WAAa,GAAK,SAAW,EAAI,EAAE,EAG7D,GAAI,WAAa,IAAK,CACrB,IAAO,MAAO,KAAO,wBAAwB,IAAI,EAEjD,QAAQ,KAAK,iBAAiB,QAAQ,MAAM,MAAO,GAAG,CAAC,CAAC,EAExD,QAAU,QAAQ,MAAM,MAAQ,EAAI,KAAK,MAAM,EAE/C,SAID,MAAO,SAAS,WAAW,CAAC,IAAM,GAAI,SAAW,SAAS,MAAM,CAAC,EACjE,MAAO,SAAS,WAAW,CAAC,IAAM,EAAG,SAAW,SAAS,MAAM,CAAC,EAEhE,IAAK,SAAS,SAAS,GAAG,EAAG,QAAQ,KAAK,QAAQ,EAElD,QAAU,QAAQ,MAAM,MAAQ,EAAI,KAAK,MAAM,EAGhD,QAAW,SAAS,QAAS,CAC5B,GAAI,MAAM,WAAW,CAAC,IAAM,IAAK,SAEjC,IAAM,UAAY,UAAU,MAAO,IAAI,EACvC,GAAI,UAAU,OAAS,EAAG,QAAQ,KAAK,GAAG,SAAS,EAGpD,OAAO,SAWK,qBAAuB,CAAC,YAAsB,CAC1D,IAAK,UAAW,OAEhB,GAAI,UAAU,WAAW,CAAC,IAAM,IAAK,OAAO,UAK5C,GAHA,UAAY,UAAU,MAAM,EAAG,EAAE,GAEhB,UAAU,SAAS,GAAG,EACxB,CAGd,GAFc,UAAU,QAAQ,KAAK,IAEvB,GAAI,OAAO,UAAU,MAAM,UAAU,QAAQ,KAAK,EAAI,CAAC,EAErE,OAGD,IAAM,YAAc,UAAU,QAAQ,KAAK,EAC3C,GAAI,cAAgB,GAAI,OAGxB,OAAO,UAAU,MAAM,YAAc,CAAC,EAAE,QAAQ,GAMpC,mBAAqB,CACjC,KACA,QACA,YACI,CACJ,IAAM,OAAS,CAAC,KAAc,QAC7B,IAAI,OACH,GAAG,YAAY,SAAS,YAAY,YAAY,YAAY,UAC7D,EAAE,KAAK,IAAI,EAEZ,QAAW,SAAS,QAAS,CAC5B,IAAK,MAAO,SAGZ,GAAI,MAAM,WAAW,CAAC,IAAM,IAAK,CAChC,IAAM,WAAa,sBAAsB,KAAK,EAAE,WAEhD,GAAI,WAAW,MAAO,UAAU,MAAQ,GACxC,GAAI,WAAW,QAAS,UAAU,QAAU,GAC5C,GAAI,WAAW,KAAM,UAAU,KAAO,GACtC,GAAI,WAAW,OAAQ,UAAU,OAAS,GAC1C,GAAI,WAAW,IAAK,UAAU,IAAM,GACpC,GAAI,WAAW,OAAQ,UAAU,OAAS,GAC1C,GAAI,WAAW,IAAK,UAAU,IAAM,GACpC,GAAI,WAAW,MAAO,UAAU,MAAQ,GACxC,GAAI,WAAW,KAAM,UAAU,KAAO,GAEtC,SAGD,IACE,UAAU,QACV,OAAO,QAAS,KAAK,GACrB,KAAK,SAAS,UAAY,KAAK,GAC/B,KAAK,SAAS,UAAY,MAAQ,QAAQ,GAE3C,UAAU,MAAQ,GAEnB,IAAK,UAAU,SAAW,OAAO,UAAW,KAAK,EAChD,UAAU,QAAU,GAErB,IAAK,UAAU,MAAQ,OAAO,OAAQ,KAAK,EAAG,UAAU,KAAO,GAE/D,IAAK,UAAU,QAAU,OAAO,SAAU,KAAK,EAC9C,UAAU,OAAS,GAEpB,IAAK,UAAU,KAAO,OAAO,MAAO,KAAK,EAAG,UAAU,IAAM,GAC5D,IAAK,UAAU,QAAU,OAAO,SAAU,KAAK,EAC9C,UAAU,OAAS,GAEpB,IAAK,UAAU,OAAS,OAAO,QAAS,KAAK,EAAG,UAAU,MAAQ,GAClE,IAAK,UAAU,KAAO,OAAO,MAAO,KAAK,EAAG,UAAU,IAAM,GAC5D,IAAK,UAAU,MAAQ,OAAO,OAAQ,KAAK,EAAG,UAAU,KAAO,GAE/D,GACC,UAAU,OACV,UAAU,SACV,UAAU,MACV,UAAU,QACV,UAAU,KACV,UAAU,QACV,UAAU,OACV,UAAU,KACV,UAAU,KAEV,MAGF,OAAO,SA+BD,IAAM,wBAA0B,CACtC,QACA,KACA,YACI,CAEJ,GAAI,CACH,IAAM,gBAAkB,IAAI,OAAO,eAAe,UAAW,IAAI,EACjE,gBAAgB,KAAK,IAAI,EAOzB,IAAM,SAAW,KAAK,WAAW,gBAAgB,SAAS,EAE1D,GAAI,WAAa,IAAM,WAAa,GAWnC,OAVA,UAAU,MAAQ,GAClB,UAAU,QAAU,GACpB,UAAU,KAAO,GACjB,UAAU,OAAS,GACnB,UAAU,IAAM,GAChB,UAAU,OAAS,GACnB,UAAU,IAAM,GAChB,UAAU,MAAQ,GAClB,UAAU,KAAO,GAEV,GAGR,MAAO,GACN,MAAO,OAAO,CASf,OARA,QAAQ,IACP,oJACD,EACA,QAAQ,IAAI,cAAc,EAC1B,QAAQ,IAAI,IAAI,EAChB,QAAQ,IAAI,iBAAiB,EAC7B,QAAQ,IAAI,OAAO,EAEZ,KAIL,UACA,OAA4C,CAAC,EAEpC,kBAAoB,CAAC,MAAQ,IAAM,CAC/C,GAAI,UAAW,aAAa,SAAS,EAErC,UAAY,WAAW,IAAM,CAI5B,GAHA,OAAS,CAAC,EAEV,UAAY,OACR,MAAO,IAAI,GAAG,EAAK,GACrB,KAAK,GAGI,eAAiB,CAAC,EAAsB,IAAyB,CAC7E,MAAO,CACN,KAAM,EAAE,MAAQ,EAAE,KAClB,OAAQ,EAAE,QAAU,EAAE,OACtB,QAAS,EAAE,SAAW,EAAE,QACxB,MAAO,EAAE,OAAS,EAAE,MACpB,IAAK,EAAE,KAAO,EAAE,IAChB,OAAQ,EAAE,QAAU,EAAE,OACtB,IAAK,EAAE,KAAO,EAAE,IAChB,MAAO,EAAE,OAAS,EAAE,MACpB,KAAM,EAAE,MAAQ,EAAE,IACnB,GAGY,QAAU,CACtB,UACA,UAA+B,CAC9B,MAAO,GACP,QAAS,GACT,KAAM,GACN,OAAQ,GACR,IAAK,GACL,OAAQ,GACR,IAAK,GACL,MAAO,GACP,KAAM,EACP,IACuB,CACvB,IAAM,OAAsC,CAAC,EAE7C,GAAI,UAAU,SAAS,OAAQ,OAAO,KAAK,GAAG,UAAU,OAAO,EAC/D,GAAI,UAAU,cAAc,OAAQ,OAAO,KAAK,GAAG,UAAU,YAAY,EACzE,GAAI,UAAU,OAAO,OAAQ,OAAO,KAAK,GAAG,UAAU,KAAK,EAC3D,GAAI,UAAU,OAAO,OAAQ,OAAO,KAAK,GAAG,UAAU,KAAK,EAC3D,GAAI,UAAU,WAAW,OAAQ,OAAO,KAAK,GAAG,UAAU,SAAS,EACnE,GAAI,UAAU,aAAa,OAAQ,OAAO,KAAK,GAAG,UAAU,WAAW,EACvE,GAAI,UAAU,aAAa,OAAQ,OAAO,KAAK,GAAG,UAAU,WAAW,EACvE,GAAI,UAAU,eAAe,OAAQ,OAAO,KAAK,GAAG,UAAU,aAAa,EAE3E,GAAI,UAAU,SAAW,OAAO,UAAU,UAAY,WACrD,OAAO,KAAK,UAAU,OAAkB,EAEzC,QAAS,EAAI,EAAG,EAAI,OAAO,OAAQ,IAAK,CACvC,IAAM,EAAI,OAAO,GACjB,IAAK,EAAG,SAER,IAAM,MAAQ,OAAO,IAAM,SAAW,EAAE,GAAK,EAG7C,GAAI,OAAO,QAAU,WAAY,SAEjC,IAAM,QAAU,MAAM,SAAS,EACzB,IAAM,SAAS,OAAO,EACtB,gBAAkB,OAAO,KAC/B,GAAI,gBAAiB,CACpB,UAAY,eAAe,UAAW,eAAe,EACrD,SAGD,IAAM,YAAiC,CACtC,MAAO,GACP,QAAS,GACT,KAAM,GACN,OAAQ,GACR,IAAK,GACL,OAAQ,GACR,IAAK,GACL,MAAO,GACP,KAAM,EACP,GAEO,UAAW,MAAQ,iBAAiB,OAAO,EAE5C,eAAiB,uBAAuB,UAAW,WAAW,EAC9D,cAAgB,qBAAqB,cAAc,EAEzD,GAAI,cAAe,CAClB,IAAM,QAAU,UAAU,cAAe,KAAK,MAAM,EAAG,EAAE,CAAC,EAC1D,QAAQ,OAAO,EAAG,GAAI,aAAa,EAEnC,IAAI,KAAO,KAEX,GACC,KAAK,WAAW,CAAC,IAAM,KACvB,KAAK,WAAW,KAAK,OAAS,CAAC,IAAM,IAErC,KAAO,KAAK,MAAM,EAAG,EAAE,EAExB,IAAK,wBAAwB,cAAe,KAAM,WAAW,EAC5D,mBAAmB,KAAM,QAAS,WAAW,EAE9C,IACE,YAAY,OACb,KAAK,SAAS,UAAY,cAAgB,QAAQ,EAElD,YAAY,MAAQ,GAGtB,IAAK,OAAO,KAAM,OAAO,KAAO,YAIhC,GAFA,UAAY,eAAe,UAAW,WAAW,EAGhD,UAAU,OACV,UAAU,SACV,UAAU,MACV,UAAU,QACV,UAAU,KACV,UAAU,QACV,UAAU,KACV,UAAU,OACV,UAAU,KAEV,MAGF,OAAO,WCpsBR,4CAEA,gFA4HO,MAAM,MAAkC,CAErC,KACA,IACA,QAHT,WAAW,CACF,KACA,IACA,QAAiC,CAAC,EACzC,CAHO,eACA,aACA,wBAGL,OAAM,EAAG,CACZ,OAAO,KAAK,IAAI,KAAK,OAAS,KAAK,WAGhC,OAAM,CAAC,IAAmB,CAC7B,KAAM,KAAK,QAAQ,KAAK,KAAM,KAAK,IAAI,KAAK,MAAQ,KAAK,QAEzD,KAAK,IAAI,KAAK,MAAQ,OAGT,UAAS,EAAG,CACzB,KAAM,KAAK,QAAQ,KAAK,KAAM,KAAK,IAAI,KAAK,MAAQ,KAAK,QAEzD,OAAO,KAAK,IAAI,KAAK,SAGR,UAAS,CAAC,IAAmB,CAC1C,KAAK,OAAS,OAGX,MAAK,EAAM,CACd,OAAO,KAAK,OAAO,SAGhB,MAAK,CAAC,MAAU,CACnB,KAAK,UAAU,MAAQ,SAGpB,QAAO,EAAG,CACb,OAAO,KAAK,OAAO,WAGhB,QAAO,CAAC,QAAS,CACpB,KAAK,UAAU,QAAU,WAGtB,OAAM,EAAG,CACZ,OAAO,KAAK,OAAO,UAGhB,OAAM,CAAC,OAAQ,CAClB,KAAK,UAAU,OAAS,UAGrB,OAAM,EAAG,CACZ,OAAO,KAAK,OAAO,UAGhB,OAAM,CAAC,OAAQ,CAClB,KAAK,UAAU,OAAS,UAGrB,KAAI,EAAG,CACV,OAAO,KAAK,OAAO,QAGhB,KAAI,CAAC,KAAM,CACd,KAAK,UAAU,KAAO,QAGnB,OAAM,EAAG,CACZ,OAAO,KAAK,OAAO,UAGhB,OAAM,CAAC,OAAQ,CAClB,KAAK,UAAU,OAAS,UAGrB,SAAQ,EAAG,CACd,OAAO,KAAK,OAAO,YAGhB,SAAQ,CAAC,SAAU,CACtB,KAAK,UAAU,SAAW,YAGvB,SAAQ,EAAG,CACd,OAAO,KAAK,OAAO,YAGhB,SAAQ,CAAC,SAAU,CACtB,KAAK,UAAU,SAAW,YAGvB,SAAQ,EAAG,CACd,OAAO,KAAK,OAAO,YAGhB,SAAQ,CAAC,SAAU,CACtB,KAAK,UAAU,SAAW,YAGvB,YAAW,EAAG,CACjB,OAAO,KAAK,OAAO,eAGhB,YAAW,CAAC,YAAa,CAC5B,KAAK,UAAU,YAAc,eAG1B,QAAO,EAAG,CACb,OAAO,KAAK,OAAO,WAGhB,QAAO,CAAC,QAAS,CACpB,KAAK,UAAU,QAAU,QAG1B,MAAM,CAAC,OAAwC,CAM9C,OALA,KAAK,UAAY,OAAO,OACvB,KAAK,OACL,OAAO,SAAW,WAAa,OAAO,KAAK,MAAM,EAAI,MACtD,EAEO,KAGR,GAAG,CAAC,OAAwC,CAS3C,OARA,KAAK,UAAY,OAAO,OACvB,IACI,KAAK,QACR,MAAO,KAAK,KACb,EACA,OAAO,SAAW,WAAa,OAAO,KAAK,MAAM,EAAI,MACtD,EAEO,KAGR,MAAM,EAAG,CACR,GAAI,KAAK,QAAU,OAAW,OAQ9B,OANA,KAAK,IAAI,CACR,QAAS,IAAI,KAAK,CAAC,EACnB,OAAQ,EACR,MAAO,EACR,CAAC,EAEM,KAGR,QAAQ,EAAG,CACV,OAAO,OAAO,KAAK,QAAU,SAC1B,KAAK,UAAU,KAAK,KAAK,EACxB,KAAK,OAAO,SAAS,GAAK,GAEhC,CAEO,IAAM,gBAAkB,CAC9B,KACA,MACA,UACqC,CACrC,IAAK,KAAI,OAAQ,KAAI,OAAS,CAAC,EAE/B,OAAO,IAAI,MAAM,MAAO,CACvB,GAAG,CAAC,GAAG,IAAa,CACnB,GAAI,OAAO,MACV,OAAO,IAAI,OACV,IACA,KAAI,OACJ,OAAO,OAAO,CAAC,EAAG,SAAW,CAAC,EAAG,MAAM,IAAI,CAC5C,EAED,OAAO,IAAI,OACV,IACA,KAAI,OACJ,OAAO,OAAO,CAAC,EAAG,OAAO,CAC1B,EAEF,CAAC,GAGW,YAAc,MAC1B,KACA,cAEC,QACA,QACG,SAGA,CAAC,IACD,CACJ,IAAK,aAAc,OAAO,gBAAgB,KAAK,CAAC,EAAG,OAAO,EAE1D,IAAM,YAAc,OAAO,UAAY,SACvC,GAAI,MAAQ,OAAS,KAAS,MAAM,QAAQ,IAAI,EAAG,KAAO,CAAC,IAAI,EAE/D,IAAM,IAAoC,CAAC,EAErC,QAAU,oBAAM,YAAY,EAClC,QAAY,KAAM,KAAM,OAAO,QAAQ,OAAO,EAAG,CAChD,GAAI,IAAM,OAAW,SAErB,IAAI,MAAQ,yCAAO,CAAC,EAEpB,GAAI,OAAS,IAAQ,MAAM,SAAS,IAAI,EAAG,CAC1C,IAAK,QACJ,MAAM,IAAI,MAAM,wCAAwC,EAEzD,GAAI,YAAa,CAChB,IAAM,KAAO,MAAM,aAAa,MAAiB,OAAO,EACxD,GAAI,OAAS,GAAO,MAAM,IAAI,uBAAuB,IAAI,EAEzD,MAAQ,KACF,KACN,IAAI,QAAU,GACd,QAAS,EAAI,EAAG,EAAI,QAAQ,OAAQ,IAAK,CACxC,IAAM,KAAO,MAAM,aAAa,MAAiB,QAAQ,EAAE,EAE3D,GAAI,OAAS,GAAO,CACnB,QAAU,GACV,MAAQ,KACR,OAIF,IAAK,QAAS,MAAM,IAAI,uBAAuB,IAAI,GAIrD,IAAI,MAAQ,CACX,KACD,EAGD,OAAO,gBAAgB,KAAK,IAAK,OAAO,GAG5B,gBAAkB,CAAC,UAAsC,CACrE,IAAK,UAAY,WAAW,OAAO,EAAG,OAEtC,IAAM,KAAgB,CAAC,EAEvB,QAAY,IAAK,YAAa,OAAO,QAAQ,OAAO,EAAG,CACtD,IAAK,MAAQ,SAAU,SAEvB,IAAM,MAAQ,SAAS,MACvB,GAAI,QAAU,QAAa,QAAU,KAAM,SAE3C,KAAI,KACH,wBACC,IACA,OAAO,QAAU,SAAW,KAAK,UAAU,KAAK,EAAI,MAAQ,GAC5D,QACD,CACD,EAGD,GAAI,KAAI,SAAW,EAAG,OACtB,GAAI,KAAI,SAAW,EAAG,OAAO,KAAI,GAEjC,OAAO,MC5XD,IAAM,WAAa,CACzB,SACA,OACc,CACd,IAAK,OAAS,oBAAoB,QACjC,OAAO,SAAS,KAAK,CAAC,MAAQ,WAAW,IAAK,IAAG,CAAC,EAEnD,IAAM,KAAO,SAAS,KAEtB,IACG,MAAO,MACR,MACA,MACA,KAAI,SAAW,KACf,KAAI,SAAW,KACf,KAAI,SAAW,KACf,KAAI,SAAW,IACf,CACD,GAAI,KAAK,CACR,GAAI,KAAI,mBAAmB,QAAS,CACnC,IAAI,WAAkC,CACrC,gBAAiB,QACjB,gBAAiB,WAAW,KAAO,KAAK,OACxC,oBAAqB,SACtB,EAEA,GAAI,mBACH,WAAc,KAAI,QAA+B,OAAO,EACpD,KACJ,WAAa,CAAC,EACd,QAAY,IAAK,SAAU,KAAI,QAAQ,QAAQ,EAC9C,GAAI,OAAO,KAAI,QAAS,WAAW,KAAO,MAG5C,OAAO,IAAI,SAAS,SAAkB,CACrC,OAAQ,KAAI,OACZ,QAAS,UACV,CAAC,EAGF,GAAI,WAAW,KAAI,OAAO,EACzB,OAAO,IAAI,SAAS,SAAkB,CACrC,OAAQ,KAAI,OACZ,QAAS,OAAO,OACf,CACC,gBAAiB,QACjB,gBAAiB,WAAW,KAAO,KAAK,OACxC,oBAAqB,SACtB,EACA,KAAI,OACL,CACD,CAAC,EAGH,OAAO,IAAI,SAAS,SAAkB,CACrC,QAAS,CACR,gBAAiB,QACjB,gBAAiB,WAAW,KAAO,KAAK,OACxC,oBAAqB,SACtB,CACD,CAAC,EAGF,OAAO,IAAI,SAAS,QAAgB,GAGxB,gBAAkB,CAAC,QAAkB,YAAwB,CACzE,IAAK,QAAS,OAAO,QAErB,QAAQ,OAAO,YAAY,EAE3B,QAAS,EAAI,EAAG,EAAI,UAAU,OAAQ,IAAK,CAC1C,IAAM,MAAQ,UAAU,GAAG,QAAQ,GAAG,EAEtC,QAAQ,OACP,aACA,GAAG,UAAU,GAAG,MAAM,EAAG,KAAK,KAC7B,UAAU,GAAG,MAAM,MAAQ,CAAC,GAAK,IAEnC,EAGD,OAAO,SAGK,qBAAuB,CACnC,SACA,OACI,CACJ,GAAI,MAAK,QAAS,CACjB,GAAI,UACH,GAAI,mBACH,OAAO,OAAO,KAAI,QAAS,SAAS,QAAQ,OAAO,CAAC,EAEpD,aAAY,IAAK,SAAU,SAAS,QAAQ,QAAQ,EACnD,GAAI,OAAO,KAAI,QAAS,KAAI,QAAQ,KAAO,MAG9C,GAAI,KAAI,SAAW,IAAK,KAAI,OAAS,SAAS,OAG9C,GAAI,KAAI,QAAQ,oBACf,OAAO,KAAI,QAAQ,oBAEpB,OAAO,KAGR,IAAK,SACJ,MAAO,CACN,QAAS,CAAC,EACV,OAAQ,MAAK,QAAU,GACxB,EAED,GAAI,mBAAoB,CAOvB,GANA,KAAM,CACL,QAAS,SAAS,QAAQ,OAAO,EACjC,OAAQ,MAAK,QAAU,GACxB,EAGI,KAAI,QAAQ,oBACf,OAAO,KAAI,QAAQ,oBAEpB,OAAO,KAGR,KAAM,CACL,QAAS,CAAC,EACV,OAAQ,MAAK,QAAU,GACxB,EAEA,QAAY,IAAK,SAAU,SAAS,QAAQ,QAAQ,EAAG,CAGtD,GAAI,MAAQ,mBAAoB,SAEhC,GAAI,OAAO,KAAI,QAAS,KAAI,QAAQ,KAAO,MAG5C,OAAO,MAYK,oBACZ,EAAG,YAAa,sBAChB,MACC,UACA,KACA,UACI,CACJ,IAAI,KAAO,UAAU,KAAK,EAC1B,GAAI,gBAAgB,QAAS,KAAO,MAAM,KAE1C,GAAI,KAAK,KAAM,CACd,GAAI,KAAK,OAAO,YAAY,KAAK,MAAO,KAAK,OAAO,EACpD,OAAO,mBAAmB,KAAK,MAAO,OAAO,EAG9C,GAAI,MAAK,QAAS,CACjB,IAAK,KAAI,QAAQ,qBAChB,KAAI,QAAQ,qBAAuB,UACpC,IAAK,KAAI,QAAQ,gBAChB,KAAI,QAAQ,gBAAkB,mCAE/B,UAAM,CACL,OAAQ,IACR,QAAS,CACR,eAAgB,mCAChB,oBAAqB,SACtB,CACD,EAGD,OAAO,IAAI,SACV,IAAI,eAAe,MACZ,MAAK,CAAC,WAAY,CACvB,IAAI,IAAM,GAYV,GAVA,SAAS,QAAQ,iBAAiB,QAAS,IAAM,CAChD,IAAM,GAEN,GAAI,CACH,WAAW,MAAM,EAChB,KAAM,GAGR,EAEG,KAAK,QAAU,QAAa,KAAK,QAAU,KAC9C,GAAI,OAAO,KAAK,QAAU,SACzB,GAAI,CACH,WAAW,QACV,OAAO,KAAK,KAAK,UAAU,KAAK,KAAK,CAAC,CACvC,EACC,KAAM,CACP,WAAW,QACV,OAAO,KAAK,KAAK,MAAM,SAAS,CAAC,CAClC,EAGD,gBAAW,QACV,OAAO,KAAK,KAAK,MAAM,SAAS,CAAC,CAClC,EAGF,cAAiB,SAAS,UAAW,CACpC,GAAI,IAAK,MACT,GAAI,QAAU,QAAa,QAAU,KAAM,SAE3C,GAAI,OAAO,QAAU,SACpB,GAAI,CACH,WAAW,QACV,OAAO,KAAK,KAAK,UAAU,KAAK,CAAC,CAClC,EACC,KAAM,CACP,WAAW,QACV,OAAO,KAAK,MAAM,SAAS,CAAC,CAC7B,EAEG,gBAAW,QAAQ,OAAO,KAAK,MAAM,SAAS,CAAC,CAAC,EAIrD,MAAM,IAAI,QAAc,CAAC,UACxB,WAAW,IAAM,QAAQ,EAAG,CAAC,CAC9B,EAGD,GAAI,CACH,WAAW,MAAM,EAChB,KAAM,GAIV,CAAC,EACD,IACD,GAGF,eAAuB,cAAc,CAAC,SAAoB,CACzD,IAAM,KAAO,SAAS,KAEtB,IAAK,KAAM,OAEX,IAAM,OAAS,KAAK,UAAU,EACxB,QAAU,IAAI,YAEpB,GAAI,CACH,MAAO,GAAM,CACZ,IAAQ,KAAM,OAAU,MAAM,OAAO,KAAK,EAC1C,GAAI,KAAM,MAEV,MAAM,QAAQ,OAAO,KAAK,UAE1B,CACD,OAAO,YAAY,GAId,IAAM,UAAY,CAAC,OAAwB,CACjD,GAAI,OAAO,KAAI,SAAW,SAAU,KAAI,OAAS,UAAU,KAAI,QAE/D,GAAI,KAAI,QAAU,WAAW,KAAI,MAAM,EAAG,CACzC,IAAM,OAAS,gBAAgB,KAAI,MAAM,EAEzC,GAAI,OAAQ,KAAI,QAAQ,cAAgB,OAGzC,GAAI,KAAI,QAAQ,eAAiB,MAAM,QAAQ,KAAI,QAAQ,aAAa,EACvE,KAAI,QAAU,gBACb,IAAI,QAAQ,KAAI,OAAc,EAC9B,KAAI,QAAQ,aACb,GAIW,sBAAwB,CAAC,UAAoC,CACzE,IAAM,aAAe,oBAAoB,OAAO,EAEhD,MAAO,CAAC,SAAoB,KAAqB,UAAsB,CACtE,IAAI,YAAc,GAElB,GAAI,KAAI,mBAAmB,QAC1B,QAAW,OAAO,KAAI,QAAQ,KAAK,EAClC,GAAI,MAAQ,aAAc,CACzB,GAAI,YAAa,SAEjB,YAAc,GAEd,QAAW,UAAU,KAAI,QAAQ,aAAa,EAC7C,SAAS,QAAQ,OAAO,aAAc,MAAM,EACvC,cAAS,QAAQ,OAAO,IAAK,KAAI,SAAS,IAAI,GAAG,GAAK,EAAE,EAGhE,aAAW,OAAO,KAAI,QACpB,SAAsB,QAAQ,OAC9B,IACA,KAAI,QAAQ,IACb,EAEF,IAAM,QAAS,KAAI,QAAU,IAE7B,GACE,SAAsB,SAAW,SAClC,UAAW,MACT,SAAS,QAAqB,KAC9B,SAAS,OAAoB,KAE/B,OAAO,SAAS,KAAK,EAAE,KAAK,CAAC,QAAU,CACtC,IAAM,YAAc,IAAI,SAAS,MAAO,CACvC,QAAS,SAAS,QAClB,OAAQ,KAAI,MACb,CAAC,EAED,IACG,YAAyB,QAAQ,IAAI,gBAAgB,GACtD,YAAyB,QAAQ,IACjC,mBACD,IAAM,UAEN,OAAO,aACN,eAAe,WAAuB,EACtC,qBAAqB,YAAyB,IAAG,EACjD,OACD,EAED,OAAO,YACP,EAEF,IACG,SAAsB,QAAQ,IAAI,gBAAgB,GACnD,SAAsB,QAAQ,IAAI,mBAAmB,IACrD,UAED,OAAO,aACN,eAAe,QAAoB,EACnC,qBAAqB,SAAsB,IAAG,EAC9C,OACD,EAED,OAAO,WC/UF,IAAM,YAAc,CAC1B,SACA,KACA,UACc,CACd,GAAI,WAAW,KAAI,OAAO,GAAK,KAAI,SAAW,KAAO,KAAI,OAGxD,OAFA,UAAU,IAAG,EAEL,UAAU,aAAa,UACzB,SAEJ,OADA,KAAI,QAAQ,gBAAkB,aACvB,IAAI,SAAS,SAAoB,IAAU,MAE9C,YACA,SAEJ,OADA,KAAI,QAAQ,gBAAkB,mBACvB,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,IAAU,MAEpD,aACJ,OAAO,WAAY,SAAwB,KAAa,MAEpD,OACJ,OAAO,WAAW,SAAkB,IAAU,MAE1C,OACJ,OAAO,WAAW,SAAkB,IAAU,MAE1C,6BAGJ,OAFA,KAAI,OAAU,SAA6C,KAEpD,YACL,SAA6C,SAC9C,KACA,OACD,MAEI,iBACJ,IACE,KAAI,QAAQ,iBAAiB,WAC7B,mBACD,EAEA,KAAI,QAAQ,gBACX,mCAeF,OAbA,SAAS,QAAQ,iBAChB,QACA,CACC,WAAW,EAAG,CACb,GAAI,SAAS,SAAW,SAAS,QAAQ,QACvC,SAA4B,OAAO,EAEvC,EACA,CACC,KAAM,EACP,CACD,EAEO,IAAI,SAAS,SAA4B,IAAU,MAEtD,QACJ,IAAK,SAAU,OAAO,IAAI,SAAS,GAAI,IAAU,EAEjD,OAAO,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,IAAU,MAEpD,WACJ,OAAO,eAAe,SAAsB,KAAK,OAAO,MAEpD,QACJ,OAAO,gBAAgB,SAAmB,IAAG,MAEzC,UACJ,OAAQ,SAA0B,KAAK,CAAC,IACvC,YAAY,EAAG,KAAK,OAAO,CAC5B,MAEI,WACJ,OAAO,YAAa,SAAsB,EAAG,KAAK,OAAO,MAErD,aACA,UACJ,OAAO,IAAI,SACT,SAA8B,SAAS,EACxC,IACD,MAEI,SACJ,GAAI,oBAAoB,OACvB,OAAO,IAAI,SAAS,SAAS,MAAO,IAAU,EAE/C,OAAO,IAAI,SAAS,UAAU,SAAS,EAAG,IAAU,MAEhD,WACJ,OAAO,IAAI,SAAS,SAAsB,IAAU,UAIpD,GAAI,oBAAoB,SACvB,OAAO,eAAe,SAAsB,KAAK,OAAO,EAEzD,GAAI,oBAAoB,QACvB,OAAO,SAAS,KAAK,CAAC,IAAM,YAAY,EAAG,IAAG,CAAC,EAEhD,GAAI,oBAAoB,MACvB,OAAO,gBAAgB,SAAmB,IAAG,EAE9C,GAAI,oBAAoB,2BAKvB,OAJA,KAAI,OACH,SACC,KAEK,YACL,SAA6C,SAC9C,KACA,OACD,EAID,GAAI,OAAO,UAAU,OAAS,WAC7B,OAAO,aAAa,SAAiB,KAAK,OAAO,EAGlD,GAAI,OAAO,UAAU,OAAS,WAE7B,OAAO,SAAS,KAAK,CAAC,IAAM,YAAY,EAAG,IAAG,CAAC,EAGhD,GAAI,OAAO,UAAU,aAAe,WACnC,OAAO,YAAa,SAAiB,WAAW,EAAG,IAAG,EAEvD,GAAI,eAAiB,SAAkB,CACtC,IAAM,KAAQ,SAAiB,WAAW,CAAC,EAE3C,GAAI,OAAS,KAAO,OAAS,GAAI,CAChC,IAAK,KAAI,QAAQ,gBAChB,KAAI,QAAQ,gBAAkB,mBAE/B,OAAO,IAAI,SACV,KAAK,UAAU,QAAQ,EACvB,IACD,GAIF,OAAO,IAAI,SAAS,SAAiB,IAAU,EAIlD,GACC,oBAAoB,WAClB,SAAsB,QAAQ,IAAI,gBAAgB,GACnD,SAAsB,QAAQ,IAAI,mBAAmB,IAAM,UAE5D,OAAO,aACN,eAAe,QAAQ,EACvB,qBAAqB,SAAsB,IAAG,EAC9C,OACD,EAGD,GAEC,OAAO,UAAU,OAAS,YAC1B,oBAAoB,eAEpB,OAAO,aAAa,SAAiB,KAAK,OAAO,EAElD,OAAO,mBAAmB,SAAU,OAAO,GAG/B,iBAAmB,CAC/B,SACA,KACA,UAC0B,CAC1B,GAAI,WAAa,QAAa,WAAa,KAAM,OAEjD,GAAI,WAAW,KAAI,OAAO,GAAK,KAAI,SAAW,KAAO,KAAI,OAGxD,OAFA,UAAU,IAAG,EAEL,UAAU,aAAa,UACzB,SAEJ,OADA,KAAI,QAAQ,gBAAkB,aACvB,IAAI,SAAS,SAAoB,IAAU,MAE9C,YACA,SAEJ,OADA,KAAI,QAAQ,gBAAkB,mBACvB,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,IAAU,MAEpD,aACJ,OAAO,WAAY,SAAwB,KAAa,MAEpD,OACJ,OAAO,WAAW,SAAkB,IAAU,MAE1C,OACJ,OAAO,WAAW,SAAyB,IAAG,MAE1C,6BAGJ,OAFA,KAAI,OAAU,SAA6C,KAEpD,iBACL,SAA6C,SAC9C,KACA,OACD,MAEI,iBACJ,IACE,KAAI,QAAQ,iBAAiB,WAC7B,mBACD,EAEA,KAAI,QAAQ,gBACX,mCAeF,OAbA,SAAS,QAAQ,iBAChB,QACA,CACC,WAAW,EAAG,CACb,GAAI,SAAS,SAAW,SAAS,QAAQ,QACvC,SAA4B,OAAO,EAEvC,EACA,CACC,KAAM,EACP,CACD,EAEO,IAAI,SAAS,SAA4B,IAAU,MAEtD,QACJ,IAAK,SAAU,OAEf,OAAO,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,IAAU,MAEpD,WACJ,OAAO,eAAe,SAAsB,KAAK,OAAO,MAEpD,UAEJ,OAAQ,SAA8B,KAAK,CAAC,IAC3C,iBAAiB,EAAG,IAAG,CACxB,MAEI,QACJ,OAAO,gBAAgB,SAAmB,IAAG,MAEzC,WACJ,OAAO,iBAAkB,SAAsB,EAAG,IAAG,MAEjD,aACA,UACJ,OAAO,IAAI,SACT,SAA8B,SAAS,EACxC,IACD,MAEI,WACJ,OAAO,IAAI,SAAS,QAAoB,MAEpC,SACJ,GAAI,oBAAoB,OACvB,OAAO,IAAI,SAAS,SAAS,MAAO,IAAU,EAE/C,OAAO,IAAI,SAAS,UAAU,SAAS,EAAG,IAAU,UAGpD,GAAI,oBAAoB,SACvB,OAAO,eAAe,SAAU,KAAK,OAAO,EAE7C,GAAI,oBAAoB,QACvB,OAAO,SAAS,KAAK,CAAC,IAAM,iBAAiB,EAAG,IAAG,CAAC,EAErD,GAAI,oBAAoB,MACvB,OAAO,gBAAgB,SAAmB,IAAG,EAE9C,GAAI,oBAAoB,2BAKvB,OAJA,KAAI,OACH,SACC,KAEK,iBACL,SAA6C,SAC9C,KACA,OACD,EAID,GAAI,OAAO,UAAU,OAAS,WAC7B,OAAO,aAAa,SAAiB,KAAK,OAAO,EAGlD,GAAI,OAAO,UAAU,OAAS,WAE7B,OAAO,SAAS,KAAK,CAAC,IAAM,iBAAiB,EAAG,IAAG,CAAC,EAGrD,GAAI,OAAO,UAAU,aAAe,WACnC,OAAO,iBAAkB,SAAiB,WAAW,EAAG,IAAG,EAE5D,GAAI,eAAiB,SAAkB,CACtC,IAAM,KAAQ,SAAiB,WAAW,CAAC,EAE3C,GAAI,OAAS,KAAO,OAAS,GAAI,CAChC,IAAK,KAAI,QAAQ,gBAChB,KAAI,QAAQ,gBAAkB,mBAE/B,OAAO,IAAI,SACV,KAAK,UAAU,QAAQ,EACvB,IACD,GAIF,OAAO,IAAI,SAAS,SAAiB,IAAU,EAGjD,YAAQ,UAAU,aAAa,UACzB,SAEJ,OADA,KAAI,QAAQ,gBAAkB,aACvB,IAAI,SAAS,QAAkB,MAElC,YACA,SAEJ,OADA,KAAI,QAAQ,gBAAkB,mBACvB,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,IAAU,MAEpD,aACJ,OAAO,WAAY,SAAwB,KAAa,MAEpD,OACJ,OAAO,WAAW,SAAkB,IAAU,MAE1C,OACJ,OAAO,WAAW,SAAyB,IAAG,MAE1C,6BAGJ,OAFA,KAAI,OAAU,SAA6C,KAEpD,iBACL,SAA6C,SAC9C,KACA,OACD,MAEI,iBAcJ,OAbA,SAAS,QAAQ,iBAChB,QACA,CACC,WAAW,EAAG,CACb,GAAI,SAAS,SAAW,SAAS,QAAQ,QACvC,SAA4B,OAAO,EAEvC,EACA,CACC,KAAM,EACP,CACD,EAEO,IAAI,SAAS,SAA4B,CAC/C,QAAS,CACR,eAAgB,kCACjB,CACD,CAAC,MAEG,QACJ,IAAK,SAAU,OAAO,IAAI,SAAS,EAAE,EAErC,OAAO,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,CAC7C,QAAS,CACR,eAAgB,kBACjB,CACD,CAAC,MAEG,WACJ,IACG,SAAsB,QAAQ,IAAI,gBAAgB,GACnD,SAAsB,QAAQ,IAAI,mBAAmB,IACrD,UAED,OAAO,aACN,eAAe,QAAoB,EACnC,qBAAqB,QAAoB,EACzC,OACD,EAED,OAAO,aAEH,UAEJ,OAAQ,SAA8B,KAAK,CAAC,IAAM,CACjD,IAAM,EAAI,iBAAiB,EAAG,IAAG,EACjC,GAAI,IAAM,OAAW,OAAO,EAC5B,MAEG,QACJ,OAAO,gBAAgB,SAAmB,IAAG,MAEzC,WACJ,OAAO,mBAAoB,SAAsB,EAAG,OAAO,MAEvD,aACA,UACJ,OAAO,IAAI,SAAU,SAA8B,SAAS,CAAC,MAEzD,SACJ,GAAI,oBAAoB,OACvB,OAAO,IAAI,SAAS,SAAS,MAAO,IAAU,EAE/C,OAAO,IAAI,SAAS,UAAU,SAAS,EAAG,IAAU,MAEhD,WACJ,OAAO,IAAI,SAAS,QAAoB,UAGxC,GAAI,oBAAoB,SAAU,OAAO,SAEzC,GAAI,oBAAoB,QACvB,OAAO,SAAS,KAAK,CAAC,IAAM,iBAAiB,EAAG,IAAG,CAAC,EAErD,GAAI,oBAAoB,MACvB,OAAO,gBAAgB,SAAmB,IAAG,EAE9C,GAAI,oBAAoB,2BAKvB,OAJA,KAAI,OACH,SACC,KAEK,iBACL,SAA6C,SAC9C,KACA,OACD,EAID,GAAI,OAAO,UAAU,OAAS,WAC7B,OAAO,aAAa,SAAiB,KAAK,OAAO,EAGlD,GAAI,OAAO,UAAU,OAAS,WAE7B,OAAO,SAAS,KAAK,CAAC,IAAM,iBAAiB,EAAG,IAAG,CAAC,EAGrD,GAAI,OAAO,UAAU,aAAe,WACnC,OAAO,iBAAkB,SAAiB,WAAW,EAAG,IAAG,EAE5D,GAAI,eAAiB,SAAkB,CACtC,IAAM,KAAQ,SAAiB,WAAW,CAAC,EAE3C,GAAI,OAAS,KAAO,OAAS,GAAI,CAChC,IAAK,KAAI,QAAQ,gBAChB,KAAI,QAAQ,gBAAkB,mBAE/B,OAAO,IAAI,SACV,KAAK,UAAU,QAAQ,EACvB,IACD,GAIF,OAAO,IAAI,SAAS,QAAe,IAI1B,mBAAqB,CACjC,SACA,UACc,CACd,OAAQ,UAAU,aAAa,UACzB,SACJ,OAAO,IAAI,SAAS,SAAoB,CACvC,QAAS,CACR,eAAgB,YACjB,CACD,CAAC,MAEG,aACA,QACJ,OAAO,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,CAC7C,QAAS,CACR,eAAgB,kBACjB,CACD,CAAC,MAEG,aACJ,OAAO,WAAY,SAAwB,KAAa,MAEpD,OACJ,OAAO,WAAW,QAAgB,MAE9B,OACJ,OAAO,WAAW,QAAuB,MAErC,6BACJ,OAAO,YACL,SAA6C,SAC9C,CACC,OAAS,SAA6C,KACtD,QAAS,CAAC,CACX,CACD,MAEI,iBAcJ,OAbA,SAAS,QAAQ,iBAChB,QACA,CACC,WAAW,EAAG,CACb,GAAI,SAAS,SAAW,SAAS,QAAQ,QACvC,SAA4B,OAAO,EAEvC,EACA,CACC,KAAM,EACP,CACD,EAEO,IAAI,SAAS,SAA4B,CAC/C,QAAS,CACR,eAAgB,kCACjB,CACD,CAAC,MAEG,QACJ,IAAK,SAAU,OAAO,IAAI,SAAS,EAAE,EAErC,OAAO,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,CAC7C,QAAS,CACR,eAAgB,kBACjB,CACD,CAAC,MAEG,WACJ,GACE,SAAsB,QAAQ,IAAI,mBAAmB,IACtD,UAEA,OAAO,aACN,eAAe,QAAoB,EACnC,qBAAqB,QAAoB,EACzC,OACD,EAED,OAAO,aAEH,QACJ,OAAO,gBAAgB,QAAiB,MAEpC,UACJ,OAAQ,SAAqC,KAAK,CAAC,IAClD,mBAAmB,EAAG,OAAO,CAC9B,MAGI,WACJ,OAAO,mBAAoB,SAAsB,EAAG,OAAO,MAEvD,aACA,UACJ,OAAO,IAAI,SAAU,SAA8B,SAAS,CAAC,MAEzD,WACJ,OAAO,IAAI,SAAS,QAAoB,UAGxC,GAAI,oBAAoB,SAAU,OAAO,SAEzC,GAAI,oBAAoB,QACvB,OAAO,SAAS,KAAK,CAAC,IACrB,mBAAmB,EAAG,OAAO,CAC9B,EAED,GAAI,oBAAoB,MACvB,OAAO,gBAAgB,QAAiB,EAEzC,GAAI,oBAAoB,2BACvB,OAAO,YACL,SAA6C,SAC9C,CACC,OAAS,SACP,KACF,QAAS,CAAC,CACX,CACD,EAGD,GAAI,OAAO,UAAU,OAAS,WAC7B,OAAO,aAAa,SAAiB,OAAW,OAAO,EAGxD,GAAI,OAAO,UAAU,OAAS,WAE7B,OAAO,SAAS,KAAK,CAAC,IAAM,YAAY,EAAG,GAAG,CAAC,EAGhD,GAAI,OAAO,UAAU,aAAe,WACnC,OAAO,mBAAoB,SAAiB,WAAW,CAAC,EAEzD,GAAI,eAAiB,SAAkB,CACtC,IAAM,KAAQ,SAAiB,WAAW,CAAC,EAE3C,GAAI,OAAS,KAAO,OAAS,GAC5B,OAAO,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,CAC7C,QAAS,CACR,eAAgB,kBACjB,CACD,CAAC,EAIH,OAAO,IAAI,SAAS,QAAe,IAIzB,gBAAkB,CAAC,OAAc,OAC7C,IAAI,SACH,KAAK,UAAU,CACd,KAAM,QAAO,KACb,QAAS,QAAO,QAChB,MAAO,QAAO,KACf,CAAC,EACD,CACC,OACC,MAAK,SAAW,IAAQ,MAAK,QAAqB,IAAO,IAC1D,QAAS,MAAK,OACf,CACD,EAEY,oBAAsB,CAClC,OACA,MACA,WAAwC,CAAC,IACP,CAClC,GAAI,OAAO,SAAW,WAAY,OAElC,IAAM,SAAW,YAAY,OAAQ,CACpC,QAAS,UACV,CAAC,EAED,IACE,MAAM,OAAO,SACb,MAAM,WAAW,SACjB,MAAM,cAAc,SACpB,MAAM,aAAa,OAEpB,OAAO,SAAS,MAAM,KAAK,QAAQ,GAG/B,eAAiB,sBAAsB,CAC5C,YACA,kBACD,CAAC,EAEK,aAAe,oBAAoB,CACxC,YACA,kBACD,CAAC,EC/pBM,IAAM,mBAAoC,CAChD,KAAM,eACN,cAAe,GACf,QAAS,CACR,YACA,iBACA,mBACA,mBACD,EACA,eAAgB,CACf,mBAAoB,YACpB,yBAA0B,GAE1B,QACC;AAAA;AAAA,EAGD,OAAQ,CACP,IAAI,CAAC,WAAY,CAChB,GAAI,WACH,MAAO;AAAA,EACR,MAAO;AAAA,GAER,IAAI,EAAG,CACN,MAAO;AAAA,GAER,UAAU,EAAG,CACZ,MAAO;AAAA,GAER,WAAW,EAAG,CACb,MAAO;AAAA,GAER,QAAQ,CAAC,WAAY,CACpB,IAAI,UAAY;AAAA;AAAA,EAEhB,GAAI,WACH,WAAa,uDACT,gBAAa;AAAA,EAElB,OACC,UACA;AAAA;AAAA;AAAA,yBASH,CACD,EACA,sBAAuB,CACtB,WAAY,IACZ,aAAa,CAAC,IAAK,CAClB,IAAI,kBAAoB,GACpB,UAAY,GAGV,eAAiB,IAAI,WAE3B,QAAW,OAAO,OAAO,KAAK,IAAI,SAAS,EAC1C,mBAAqB,KAAK,mBAAmB,QAE9C,IAAM,iBACL,IAAI,OAAO,SAAS,kBAAoB,GACnC,WAAa,IAAI,MAAM,OAAO,OAUpC,GARA,WACC,iCACmB,iBAAmB,GAAK;AAAA;AAAA;AAAA;AAAA,EAMxC,SAAU,WAAa;AAAA,EAoB3B,GAlBA,WACC,sFAUD,WAAa,OAAO,KAAK,gBAAkB,CAAC,CAAC,EAAE,OAC5C,mCACA,sBAEH,WAAa,eAGT,IAAI,UAAU,OACjB,WAAa,wCACd,GAAI,SAAU,WAAa,0BAI3B,OAHA,WAAa,kBACb,WAAa;AAAA,EAEN,WAER,QAAQ,CAAC,aAAc,aAAc,CACpC,IAAI,iBAAmB,0BAEvB,GAAI,aACH,kBAAoB,oCAAoC,KAAK,cAE7D,uBAAoB,aACjB,mGAIA,mBAEJ,MAAO,CACN,QAAS,aACN,GACA;AAAA;AAAA,EAEH,KAAM,gBACP,EAEF,EACA,aAAc,CACb,mBAAoB,GACpB,gBACC,gIAUD,aACC,+FAIF,EACA,MAAM,EAAG,CACR,MAAO,IAAM,CACZ,MAAM,IAAI,MACT,4FACD,GAGH,ECtJA,qFATA,gBAAS,qCACT,eACC,sBACA,mDCLD,qFAGO,SAAS,iBAAiB,CAChC,MACA,WAAqB,EACI,CACzB,IAAM,OAAS,OAAO,OAAO,IAAI,EAG3B,cAAgB,EAChB,gBAAkB,EAClB,gBAAkB,EAClB,kBAAoB,EAEtB,MAAQ,EACR,cAAgB,WAAa,EAC7B,cAAgB,cACd,YAAc,MAAM,OAG1B,QAAS,EAAI,WAAY,EAAI,YAAa,IACzC,OAAQ,MAAM,WAAW,CAAC,OAEpB,IACJ,oBAAoB,CAAC,EAGrB,cAAgB,EAChB,cAAgB,EAChB,MAAQ,EAER,UAGI,IACJ,GAAI,eAAiB,cAAe,cAAgB,EAC/C,YAxBkB,EA0BvB,UAGI,IACJ,GAAI,cAAgB,cAAe,OA/Bd,EAgChB,YAlCc,EAoCnB,UAGI,IACJ,GAAI,cAAgB,cAAe,OArCZ,EAsClB,YAxCgB,EA0CrB,MAMH,OAFA,oBAAoB,WAAW,EAExB,OAEP,SAAS,mBAAmB,CAAC,SAAkB,CAC9C,IAAM,oBAAsB,cAAgB,cACtC,YAAc,oBAAsB,cAAgB,SAG1D,GAAI,aAAe,cAAgB,EAAG,OAEtC,IAAI,SAAW,MAAM,MAAM,cAAgB,EAAG,WAAW,EACzD,GAAI,MA3DiB,EA2DM,SAAW,SAAS,QAAQ,MAAO,GAAG,EACjE,GAAI,MA3DmB,EA2DM,SAAW,0CAAO,QAAQ,GAAK,SAG5D,GAAI,OAAO,YAAc,OAAW,OAGpC,IAAI,WAAa,GACjB,GAAI,oBAAqB,CAGxB,GAFA,WAAa,MAAM,MAAM,cAAgB,EAAG,QAAQ,EAEhD,MApEkB,EAqErB,WAAa,WAAW,QAAQ,MAAO,GAAG,EAC3C,GAAI,MArEoB,EAsEvB,WAAa,0CAAO,UAAU,GAAK,WAGrC,OAAO,UAAY,YAQd,SAAS,UAAU,CAAC,MAAe,CACzC,IAAM,OAAS,OAAO,OAAO,IAAI,EAG7B,MAAQ,EACN,aAAe,EACf,iBAAmB,EACnB,eAAiB,EACjB,mBAAqB,EAErB,YAAc,MAAM,OACtB,cAAgB,GAChB,cAAgB,GAEpB,QAAS,EAAI,EAAG,EAAI,YAAa,IAChC,OAAQ,MAAM,WAAW,CAAC,OAEpB,IACJ,oBAAoB,MAAO,CAAC,EAG5B,cAAgB,EAChB,cAAgB,EAChB,MAAQ,EAER,UAGI,IACJ,GAAI,eAAiB,cAAe,cAAgB,EAE/C,YAAS,mBAEd,UAGI,IACJ,GAAI,cAAgB,cAAe,OAAS,eACvC,YAAS,aAEd,UAGI,IACJ,GAAI,cAAgB,cAAe,OAAS,mBACvC,YAAS,iBAEd,MAIH,GAAI,cAAgB,YAAa,oBAAoB,MAAO,WAAW,EAEvE,OAAO,OAEP,SAAS,mBAAmB,CAAC,OAAe,SAAkB,CAC7D,IAAM,oBAAsB,cAAgB,cACtC,uBAAyB,oBAC5B,cACA,SAEG,SAAW,OAAM,MAAM,cAAgB,EAAG,sBAAsB,EAGtE,IAAK,qBAAuB,SAAS,SAAW,EAAG,OAEnD,IAAI,SAAW,SACf,GAAI,MAAQ,aAAc,SAAW,SAAS,QAAQ,MAAO,GAAG,EAChE,GAAI,MAAQ,iBAAkB,SAAW,0CAAO,QAAQ,GAAK,SAE7D,IAAI,WAAa,GACjB,GAAI,oBAAqB,CACxB,IAAI,WAAa,OAAM,MAAM,cAAgB,EAAG,QAAQ,EACxD,GAAI,MAAQ,eACX,WAAa,WAAW,QAAQ,MAAO,GAAG,EAC3C,GAAI,MAAQ,mBACX,WAAa,0CAAO,UAAU,GAAK,WACpC,WAAa,WAGd,IAAM,aAAe,OAAO,UAC5B,GAAI,eAAiB,OAAW,OAAO,UAAY,WAC9C,QAAI,MAAM,QAAQ,YAAY,EAAG,aAAa,KAAK,UAAU,EAC7D,YAAO,UAAY,CAAC,aAAc,UAAU,GC1C5C,IAAM,aAAe,OAAO,aAAa,EAE1C,cAAgB,IAAM,CAC3B,IAAQ,QAAS,SAAY,QAAQ,cAA4B,GACzD,QAAS,IAAK,QAAS,YAC9B,QAAQ,cAAsB,GACvB,QAAS,OAAO,QAAS,cAChC,QAAQ,cAA4B,EAE/B,UAAwB,CAAC,EACzB,aAA2B,CAAC,EAElC,MAAO,CACN,CAAC,WAAwB,CACxB,GAAI,SAAU,UAAU,KAAK,QAAQ,EAErC,OAAO,SAER,CAAC,WAAyB,CACzB,IAAM,UAAwD,CAAC,EACzD,UAAsD,CAAC,EAGzD,WAA2B,KAE/B,QAAS,EAAI,EAAG,GAAK,SAAQ,OAAS,GAAI,IAAK,CAC9C,IAAQ,iBAAS,kBAAY,QAAQ,cAAoB,GACjD,QAAS,KAAK,QAAS,aAC9B,QAAQ,cAAsB,GACvB,QAAS,OAAO,QAAS,eAChC,QAAQ,cAA4B,EAE/B,WAAwB,CAAC,EACzB,cAA2B,CAAC,EAElC,UAAU,KAAK,CAAC,WAAwB,CACvC,GAAI,SAAU,WAAU,KAAK,QAAQ,EAErC,OAAO,SACP,EAED,UAAU,KAAK,CAAC,WAAyB,CACxC,IAAM,QAAS,IACX,SACH,SACA,aACA,MAAO,EACP,MAAM,CAAC,SAAqB,CAC3B,GAAI,SAAU,cAAa,KAAK,QAAQ,EAExC,OAAO,KAET,EAEA,SAAQ,OAAM,EACd,QAAS,GAAI,EAAG,GAAI,WAAU,OAAQ,KACrC,WAAU,IAAG,OAAM,EAEpB,MAAO,CAAC,OAAsB,OAAS,CACtC,IAAM,KAAM,YAAY,IAAI,EAG5B,GAAI,OAAO,WAAa,OAExB,IAAM,OAAS,CACd,SACA,gBACI,QAAO,EAAG,CACb,OAAO,KAAM,SAAQ,MAEvB,EAEA,QAAS,GAAI,EAAG,GAAI,cAAa,OAAQ,KACxC,cAAa,IAAG,MAAM,EAEvB,YAAW,IAAG,EACd,cAAa,MAAK,GAEnB,EAGF,IAAM,OAAS,IACX,SACH,IACA,aACA,OAAO,CAAC,SAAqB,CAC5B,QAAS,EAAI,EAAG,EAAI,UAAU,OAAQ,IACrC,UAAU,GAAG,QAAQ,GAEvB,MAAM,CAAC,SAAqB,CAC3B,GAAI,SAAU,aAAa,KAAK,QAAQ,EAExC,OAAO,IAET,EAEA,QAAQ,MAAM,EACd,QAAS,EAAI,EAAG,EAAI,UAAU,OAAQ,IAAK,UAAU,GAAG,MAAM,EAE9D,MAAO,CACN,aAAc,UACd,OAAO,CAAC,OAAsB,KAAM,CACnC,IAAM,KAAM,YAAY,IAAI,EAI5B,IAAK,QAAS,WAAY,OAAQ,WAElC,IAAM,OAAS,CACd,SACA,gBACI,QAAO,EAAG,CACb,OAAO,KAAM,SAAQ,MAEvB,EAEA,QAAS,EAAI,EAAG,EAAI,aAAa,OAAQ,IACxC,aAAa,GAAG,MAAM,EAEvB,WAAW,IAAG,EACd,aAAa,MAAK,EAEpB,EAEF,GAGY,aAAe,CAAC,gBAAgC,CAC5D,MAAO,CAAC,UAAqB,CAC5B,IAAO,UAAW,gBAAkB,cAAc,GAC3C,QAAS,cAAgB,cAAc,GACvC,YAAa,kBAAoB,cAAc,GAC/C,eAAgB,qBAAuB,cAAc,GACrD,SAAU,eAAiB,cAAc,GACzC,cAAe,oBAAsB,cAAc,GACnD,QAAS,cAAgB,cAAc,GACvC,cAAe,oBAAsB,cAAc,GACnD,gBAAiB,sBAAwB,cAAc,EA8B9D,OA5BA,cAAc,CAEb,GAAI,QAAQ,mBACZ,QACA,IAAK,QAAQ,IAEb,UAEA,QAEA,YAEA,eAEA,SAEA,cAEA,cAEA,gBAEA,QACA,KAAM,KAAK,IAAI,EACf,MAAO,QAAQ,KAChB,CAAC,EAGM,CACN,QAAS,eACT,MAAO,aACP,UAAW,iBACX,aAAc,oBACd,OAAQ,cACR,YAAa,mBACb,MAAO,aACP,YAAa,mBACb,cAAe,oBAChB,ICvTF,eACC,yDAQD,gBAAS,qCACT,uBAAS,+CCVT,uBAAS,+CACT,IAAI,MAAO,OAAO,IAAI,cAAc,EAChC,KAAO,OAAO,IAAI,cAAc,EAChC,kBAAoB,CAAC,OAAS,eAAe,KAAK,IAAI,EACtD,aAAe,CAAC,GAAI,GAAI,WAAa,KAAU,CACjD,GAAI,OAAO,KAAO,SAAU,MAAO,GAAG,MAAM,MAC5C,GAAI,kBAAkB,EAAE,EAAG,MAAO,GAAG,KAAK,WAAa,KAAO,OAAO,OACrE,MAAO,GAAG,KAAK,WAAa,IAAM,MAAM,MAEtC,eAAiB,CAAC,IAAM,kBAAkB,CAAC,EAAI,IAAI,KAAO,EAC1D,SAAW,CAAC,IAAK,UAAY,EAAG,SAAW,CAC7C,GAAI,OAAO,OAAS,UAAY,OAAO,OAAS,OAAO,QAAS,OAAO,IACvE,IAAI,IAAM,GACV,QAAS,EAAI,UAAY,EAAG,GAAK,EAAG,IAAK,KAAO,MAAM,KACtD,OAAO,IAAM,IAAM,IAAI,OAAO,SAAS,GAErC,wBAA0B,CAAC,SAAW,CACxC,IAAK,OAAO,OAAS,SAAQ,SAAW,OAAO,SAAU,aAAe,OAAO,OAAS,UACtF,OAAO,OACT,IAAQ,SAAU,WAAc,OAEhC,GADA,UAAU,WAAa,CAAC,EACpB,SAAQ,UAAW,UAAU,OAAQ,SACzC,QAAW,QAAQ,MAAO,CACxB,GAAI,KAAK,OAAS,SAAU,SAC5B,IAAQ,WAAY,SAAU,KAAM,IAAI,OAAO,MAAO,MAAS,KAC/D,GAAI,SACF,UAAU,SAAW,UAAU,SAAW,UAAU,SAAS,OAAO,QAAQ,EAAI,SAClF,OAAO,OAAO,UAAW,IAAI,EAC7B,QAAW,YAAY,KAAK,WAC1B,UAAU,WAAW,UAAY,wBAC/B,KAAK,WAAW,SAClB,EAEJ,OAAO,WAEL,aAAe,CAAC,OAAQ,SAAU,cAAgB,CACpD,IAAM,MAAQ,OAAO,kBAAkB,WAAa,OAAO,kBAAkB,OAAO,KAAK,OAAO,iBAAiB,EAAE,IACnH,IAAK,MAAO,OAAO,SACnB,IAAM,EAAI,YAAY,MAEtB,OADA,YAAY,QACL,iBAAiB,kBAAkB,eAAe,yBAAyB,0BAA0B,MAAM,cAAc,YAAY,QAAQ,UAAU,OAAO,MAAO,KAAK,KAAM,WAAW,cAAc,UAE9M,YAAc,CAAC,OAAQ,SAAU,cAAgB,CACnD,IAAM,EAAI,YAAY,MACtB,YAAY,QACZ,IAAM,OAAS,WAAa,MAAQ,YAAY,OAAO,OACnD,EAAI,GACR,IAAK,OAAQ,EAAI,SACjB,GAAK,WAAW,OAChB,QAAS,GAAK,EAAG,GAAK,OAAO,OAAQ,KAAM,CACzC,GAAI,KAAO,EAAG,GAAK,IACnB,GAAK,OACH,OAAO,IACP,aAAa,SAAU,GAAI,YAAY,gBAAgB,EACvD,WACF,EAGF,GADA,GAAK,MACA,OAAQ,GAAK,YAAY,SAC9B,OAAO,GAET,SAAS,SAAS,CAAC,OAAQ,KAAuB,IAAI,QAAW,CAC/D,GAAI,SAAW,MAAQ,OAAO,SAAW,UAAY,OAAO,SAAW,WACrE,OAAO,OACT,GAAI,KAAK,IAAI,MAAM,EAAG,OAAO,KAAK,IAAI,MAAM,EAC5C,GAAI,MAAM,QAAQ,MAAM,EAAG,CACzB,IAAM,KAAO,IAAI,MAAM,OAAO,MAAM,EACpC,KAAK,IAAI,OAAQ,IAAI,EACrB,QAAS,EAAI,EAAG,EAAI,OAAO,OAAQ,IACjC,KAAK,GAAK,UAAU,OAAO,GAAI,IAAI,EACrC,OAAO,KAET,GAAI,OAAO,SAAW,SAAU,CAC9B,IAAM,KAAO,OAAO,KAAK,MAAM,EAAE,OAC/B,OAAO,sBAAsB,MAAM,CACrC,EACM,OAAS,CAAC,EAChB,QAAW,OAAO,KAChB,OAAO,KAAO,UAAU,OAAO,KAAM,IAAI,EAC3C,OAAO,OAET,OAAO,OAET,IAAI,YAAc,CAAC,QAAS,SAAU,cAAgB,CACpD,GAAI,YAAY,eAAsB,OAAG,CACvC,IAAK,YAAY,mBACf,QAAQ,KACN,IAAI,MACF,gEACF,CACF,EACA,YAAY,mBAAqB,GAEnC,OAAO,SAET,YAAY,UAAU,UAAY,EAClC,IAAM,GAAK,YAAY,OAAO,OACxB,WAAa,YAAY,OAAO,IAAM,CAAC,EACzC,EAAI;AAAA,EAEF,UAAY,CAAC,OAAS,CAC1B,KAAM,SAAQ,QAAU,KAAK,KAAM,OAAO,KAC1C,GAAI,KAAK,SAAU,OACjB,OAAO,UAAU,YAAY,YAAY,KAAK,KAAK,EAC9C,QAAI,KAAK,SAAU,MACxB,IAAK,YAAY,QACf,QAAQ,KACN,IAAI,MACF,uEACF,CACF,EAEA,YAAO,YAAY,QAAQ,OACzB,KAAK,IACP,EAEJ,OAAO,MAET,QAAS,EAAI,EAAG,EAAI,QAAQ,OAAQ,IAAK,CACvC,IAAI,KAAO,UAAU,QAAQ,EAAE,EAC/B,GAAI,MAAM,QAAQ,KAAK,KAAK,EAC1B,QAAS,GAAK,EAAG,GAAK,KAAK,MAAM,OAAQ,KACvC,KAAK,MAAM,IAAM,UAAU,KAAK,MAAM,GAAG,EACxC,QAAI,KAAK,MACZ,GAAI,MAAM,QAAQ,KAAK,KAAK,EAC1B,QAAS,GAAK,EAAG,GAAK,KAAK,MAAM,OAAQ,KACvC,KAAK,MAAM,IAAM,UAAU,KAAK,MAAM,GAAG,EACxC,UAAK,MAAQ,UAAU,KAAK,KAAK,EAExC,WAAW,KAAK,cAAa,QAAQ,IAAI,CAAC,EAC1C,GAAK,eAAe,OAAO,YAAY,qBAAqB,OAC1D,KACA,SACA,IACK,YACH,UAAW,YAAY,UAAY,EACnC,iBAAkB,EACpB,CACF;AAAA,EAIF,OADA,GAAK,UAAU,YAAY,uBAAyB,YAAc,eAC3D,GAEL,OAAS,CAAC,OAAQ,SAAU,cAAgB,CAC9C,IAAK,OAAQ,MAAO,GACpB,IAAM,OAAS,WAAa,MAAQ,YAAY,OAAO,OACvD,GAAI,SAAQ,QAAU,OAAO,SAAU,UAAY,OAAO,QAAQ,OAAO,MACvE,OAAO,OAAO,OAAO,MAAM,OAAO,MAAO,SAAU,IAC9C,YACH,YAAa,OAAO,OAAO,YAAY,YAAa,OAAO,KAAK,CAClE,CAAC,EACH,GAAI,QAAU,OAAO,OAAS,UAAY,OAAO,OAAS,UAAY,OAAO,MAC3E,MAAO,UAAU,SAAS,IAAK,YAAY,UAAU,OAAQ,MAAM,IACrE,GAAI,YAAY,WAAa,YAAY,eAAgB,OAAO,SAChE,IAAI,EAAI,GACR,GAAI,OAAO,KAAO,QAAQ,OACxB,YAAY,YAAY,OAAO,KAAO,OACxC,OAAQ,OAAO,UACR,SACH,GAAI,OAAO,SAAU,SAAU,CAC7B,EAAI,aAAa,OAAQ,SAAU,WAAW,EAC9C,MAIF,GAFA,OAAS,wBAAwB,MAAM,EACvC,GAAK,IACD,OAAO,qBAAsB,GAAK,MAAM,WAC5C,IAAM,KAAO,OAAO,KAAK,OAAO,UAAU,EAC1C,QAAS,GAAK,EAAG,GAAK,KAAK,OAAQ,KAAM,CACvC,IAAM,IAAM,KAAK,IACb,WAAa,OAAO,WAAa,OAAO,SAAS,SAAS,GAAG,GAAK,MAAM,QAAQ,OAAO,WAAW,KAAK,KAAK,EAC1G,KAAO,aACX,SACA,IACA,YAAY,gBACd,EACA,GAAI,WAAY,CACd,IAAM,MAAQ,YAAY,MAC1B,GAAI,SAAS,WAAW,IAAI,EAAG,CAC7B,IAAM,QAAU,KAAK,MAAM,KAAK,QAAQ,GAAG,EAAI,CAAC,EAC1C,MAAQ,YAAY,iBAC1B,GAAI,MAAM,OAAQ,MAAM,OAAO,KAAK,OAAO,EACtC,WAAM,OAAS,CAAC,OAAO,EAE5B,iBAAY,UAAU,KAAK,IAAI,EAGnC,IAAM,MAAQ,OAAO,WAAW,KAChC,GAAI,OAAO,sBAAwB,MAAM,OAAS,SAChD,SACF,GAAI,KAAO,EAAG,GAAK,IACnB,GAAK,GAAG,eAAe,GAAG,KAAK,WAAa,GAAG,8BAAgC,KAAK,OAClF,MACA,KACA,IACK,YACH,UAAW,YAAY,UAAY,EACnC,iBAAkB,UACpB,CACF,IAEF,GAAK,IACL,UACG,QACH,GAAI,OAAO,MAAM,OAAS,UAAY,OAAO,MAAM,OAAS,QAC1D,GAAI,MAAM,QAAQ,OAAO,KAAK,EAAG,CAC/B,EAAI,YAAY,OAAO,MAAO,SAAU,WAAW,EACnD,MACK,QAAI,OAAQ,MAAO,WACrB,QAAI,SAAQ,OAAO,OAAS,OAAO,MAAM,OAAS,OAAO,MAAM,SAAU,OAAS,OAAO,MAAM,SAAU,QAC5G,EAAI,OACF,UAAU,YAAY,YAAY,OAAO,MAAM,KAAK,EACpD,SACA,IACK,YACH,iBAAkB,GAClB,UAAW,YAAY,UAAY,CACrC,CACF,EACG,KACH,EAAI,SACJ,MAGJ,IAAM,EAAI,YAAY,MACtB,YAAY,QACZ,IAAI,UAAY,SAChB,GAAI,OAAQ,EAAI,WAAW,gBAAgB,oBAEzC,eAAY,KAAK,KACjB,EAAI,KAAK,wBAAwB,gBAAgB,qBAEnD,GAAK,iBAAiB,iCAAiC,MAAM,kBAAkB,SAAS,OAAO,OAAO,MAAO,KAAK,KAAM,WAAW,IACnI,IAAM,UAAY,YAAY,iBAAiB,EAAI,GACnD,GAAI,UACF,QAAS,GAAK,EAAG,GAAK,UAAU,OAAQ,KAAM,CAC5C,IAAM,OAAS,KAAK,SAAS,UAAU,MACvC,GAAK,OAAO,6BAA6B,SAI7C,GADA,GAAK,KACA,OAAQ,GAAK,YAAY,QAAQ,YACtC,cAEA,GAAI,OAAO,MAAQ,OAAO,QAAQ,YAAY,YAC5C,OAAO,OACL,YAAY,YAAY,OAAO,MAC/B,SACA,WACF,EACF,GAAI,MAAM,QAAQ,OAAO,KAAK,EAAG,CAC/B,EAAI,YAAY,OAAO,MAAO,SAAU,WAAW,EACnD,MAEF,EAAI,SAAS,SAAU,YAAY,UAAU,OAAQ,MAAM,EAC3D,MAEJ,IAAK,OAAQ,OAAO,EACpB,GAAI,OAAO,OAAS,QAAS,MAAO,GAAG,eACvC,EAAI,WAAW;AAAA,EAEf,QAAS,EAAI,EAAG,EAAI,YAAY,UAAU,OAAQ,IAAK,CACrD,IAAM,IAAM,YAAY,UAAU,GAC5B,KAAO,IAAI,MAAM,CAAC,EAExB,GADA,GAAK,MAAM,kBACP,YAAY,UAAU,KAAM,GAAK,MAAM,mBAC3C,GAAK,YAAY,KAAK,WAAW,CAAC,IAAM,GAAK,IAAM,KAAK;AAAA,EAG1D,MAAO,GAAG,aAER,aAAe,CAAC,QAClB,aAAc,eACd,QACA,YACA,SAAU,UACV,eAAiB,EACjB,uBAAyB,IACvB,CAAC,IAAM,CACT,IAAM,OAAS,CAAC,EAChB,GAAI,OAAO,YAAc,WAAY,UAAY,CAAC,SAAS,EAC3D,IAAM,EAAI,OAAO,OAAQ,IAAK,CAC5B,UAAW,CAAC,EACZ,iBAAkB,CAAC,EACnB,MAAO,EACP,iBAAkB,GAClB,OACA,UAAW,CAAC,EACZ,aAAc,eACd,QAEA,YAAa,aAAe,SAAS,OAAS,CAAC,EAC/C,SAAU,UACV,UAAW,EACX,eACA,sBACF,CAAC,EACD,IAAK,OAAO,SAAW,WAAW,OAAQ,OAAO,SAAS,IAAK,CAAC,EAChE,IAAI,IACJ,GAAI,WAAW,OAAQ,CACrB,IAAM,CAAC,EACP,QAAS,EAAI,EAAG,EAAI,UAAU,OAAQ,IAAK,IAAI,IAAI,KAAO,UAAU,GAEtE,OAAO,SACL,IACA,6BAA6B,IAC/B,EAAE,CACA,UACG,GACL,CAAC,GD3PI,IAAM,WAAa,CACzB,SACI,CACJ,IAAK,OAAQ,MAAO,GAGpB,GAAI,SAAS,SAAU,UAAY,OAAO,WACzC,OAAO,OAAO,WAAW,EAAE,KAAK,UAAiB,EAGlD,GAAI,OAAO,OAEV,OAAS,OAAO,OAEjB,QAAS,QAAU,gBAAgB,QAGvB,wBAA0B,CACtC,UACa,CACb,IAAK,QAAS,MAAO,GAGrB,IAAM,OAAsB,SAA4B,QAAU,QAElE,GAAI,OAAO,SAAU,UAAY,QAAQ,WACxC,OAAO,QAAQ,WAAW,EAAE,KAAK,uBAAuB,EAEzD,GAAI,OAAO,MAAO,OAAO,OAAO,MAAM,KAAK,uBAAuB,EAClE,GAAI,OAAO,OAAQ,OAAO,OAAO,OAAO,KAAK,uBAAuB,EACpE,GAAI,OAAO,MAAO,OAAO,OAAO,MAAM,KAAK,uBAAuB,EAClE,GAAI,OAAO,IAAK,OAAO,OAAO,IAAI,KAAK,uBAAuB,EAE9D,GAAI,OAAO,OAAS,SAAU,CAC7B,IAAM,WAAa,OAAO,WAE1B,GAAI,yBAA0B,OAAQ,OAAO,OAAO,qBACpD,GAAI,sBAAuB,OAAQ,MAAO,GAE1C,QAAW,OAAO,OAAO,KAAK,UAAU,EAAG,CAC1C,IAAM,SAAW,WAAW,KAE5B,GAAI,SAAS,OAAS,UACrB,GAAI,wBAAwB,QAAQ,EAAG,MAAO,GACxC,QAAI,SAAS,OACnB,QAAS,EAAI,EAAG,EAAI,SAAS,MAAM,OAAQ,IAC1C,GAAI,wBAAwB,SAAS,MAAM,EAAE,EAAG,MAAO,GAGzD,OAAO,SAAS,qBAGjB,MAAO,GAGR,GAAI,OAAO,OAAS,SAAW,OAAO,QAAU,MAAM,QAAQ,OAAO,KAAK,EACzE,OAAO,wBAAwB,OAAO,KAAK,EAE5C,MAAO,IAGK,QAAU,CAAC,KAAc,SAAuB,CAC5D,IAAK,OAAQ,MAAO,GAEpB,GAAI,SAAQ,QAAU,OAAO,SAAU,KAAM,MAAO,GAEpD,GAAI,OAAO,OAAS,SAAU,CAC7B,IAAM,WAAa,OAAO,WAC1B,IAAK,WAAY,MAAO,GAExB,QAAW,OAAO,OAAO,KAAK,UAAU,EAAG,CAC1C,IAAM,SAAW,WAAW,KAE5B,GAAI,SAAS,OAAS,UACrB,GAAI,QAAQ,KAAM,QAAQ,EAAG,MAAO,GAC9B,QAAI,SAAS,OACnB,QAAS,EAAI,EAAG,EAAI,SAAS,MAAM,OAAQ,IAC1C,GAAI,QAAQ,KAAM,SAAS,MAAM,EAAE,EAAG,MAAO,GAG/C,GAAI,SAAQ,UAAY,SAAS,SAAU,KAAM,MAAO,GAGzD,MAAO,GAGR,QACG,OAAO,YACT,SAAQ,OAAO,YACf,OAAO,WAAW,SAAU,MAIjB,YAAc,CAC1B,iBACA,UACI,CACJ,IAAK,QAAS,OAGd,IAAM,OAAS,QAAQ,QAAU,QAEjC,GAAI,OAAO,SAAU,UAAY,QAAQ,WACxC,OAAO,QACL,WAAW,EACX,KAAK,CAAC,UAAuB,YAAY,iBAAkB,OAAM,CAAC,EAErE,GAAI,OAAO,OAAS,SAAU,CAC7B,IAAM,WAAa,OAAO,WAE1B,IAAK,WAAY,MAAO,GAExB,QAAW,OAAO,OAAO,KAAK,UAAU,EAAG,CAC1C,IAAM,SAAW,WAAW,KAE5B,GAAI,oBAAoB,SAAU,MAAO,GAEzC,GAAI,SAAS,OAAS,UACrB,GAAI,YAAY,iBAAkB,QAAQ,EAAG,MAAO,GAC9C,QAAI,SAAS,OACnB,QAAS,EAAI,EAAG,EAAI,SAAS,MAAM,OAAQ,IAC1C,GAAI,YAAY,iBAAkB,SAAS,MAAM,EAAE,EAClD,MAAO,IAGX,MAAO,GAGR,OAAO,oBAAoB,QAGf,OAAS,CAAC,SAAgC,CACtD,IAAK,OAAQ,MAAO,GAEpB,GAAI,OAAO,OACV,QAAS,EAAI,EAAG,EAAI,OAAO,MAAM,OAAQ,IACxC,GAAI,OAAO,OAAO,MAAM,EAAE,EAAG,MAAO,GAEtC,GAAI,OAAO,OACV,QAAS,EAAI,EAAG,EAAI,OAAO,MAAM,OAAQ,IACxC,GAAI,OAAO,OAAO,MAAM,EAAE,EAAG,MAAO,GAEtC,GAAI,OAAO,OACV,QAAS,EAAI,EAAG,EAAI,OAAO,MAAM,OAAQ,IACxC,GAAI,OAAO,OAAO,MAAM,EAAE,EAAG,MAAO,GAEtC,GAAI,OAAO,OACV,QAAS,EAAI,EAAG,EAAI,OAAO,MAAM,OAAQ,IACxC,GAAI,OAAO,OAAO,MAAM,EAAE,EAAG,MAAO,GAEtC,GAAI,OAAO,KAAO,OAAO,OAAO,GAAG,EAAG,MAAO,GAE7C,GAAI,OAAO,OAAS,UAAY,OAAO,WAAY,CAClD,IAAM,WAAa,OAAO,WAE1B,QAAW,OAAO,OAAO,KAAK,UAAU,EAAG,CAC1C,IAAM,SAAW,WAAW,KAE5B,GAAI,OAAO,QAAQ,EAAG,MAAO,GAE7B,GACC,SAAS,OAAS,SAClB,SAAS,OACT,OAAO,SAAS,KAAK,EAErB,MAAO,IAIV,GAAI,OAAO,OAAS,SAAW,OAAO,OAAS,OAAO,OAAO,KAAK,EACjE,MAAO,GAER,OAAO,OAAO,SAAU,OAAS,SAAU,QAG/B,aAAe,CAAC,SAAgC,CAC5D,IAAK,OAAQ,MAAO,GAEpB,GACC,OAAO,MACP,OAAO,OACP,OAAO,QAAQ,OAAO,OACtB,aAAa,OAAO,MAAM,OAAO,KAAK,EAEtC,MAAO,GAER,GAAI,OAAO,OACV,QAAS,EAAI,EAAG,EAAI,OAAO,MAAM,OAAQ,IACxC,GAAI,aAAa,OAAO,MAAM,EAAE,EAAG,MAAO,GAE5C,GAAI,OAAO,OACV,QAAS,EAAI,EAAG,EAAI,OAAO,MAAM,OAAQ,IACxC,GAAI,aAAa,OAAO,MAAM,EAAE,EAAG,MAAO,GAE5C,GAAI,OAAO,OACV,QAAS,EAAI,EAAG,EAAI,OAAO,MAAM,OAAQ,IACxC,GAAI,aAAa,OAAO,MAAM,EAAE,EAAG,MAAO,GAE5C,GAAI,OAAO,KAAO,aAAa,OAAO,GAAG,EAAG,MAAO,GAEnD,GAAI,OAAO,OAAS,UAAY,OAAO,WAAY,CAClD,IAAM,WAAa,OAAO,WAE1B,QAAW,OAAO,OAAO,KAAK,UAAU,EAAG,CAC1C,IAAM,SAAW,WAAW,KAE5B,GAAI,aAAa,QAAQ,EAAG,MAAO,GAEnC,GACC,SAAS,OAAS,SAClB,SAAS,OACT,aAAa,SAAS,KAAK,EAE3B,MAAO,IAIV,GAAI,OAAO,OAAS,SAAW,OAAO,OAAS,aAAa,OAAO,KAAK,EACvE,MAAO,GAER,OAAO,iBAAiB,QAoBZ,kBAAoB,CAChC,OACA,QACA,QAA0D,CAAC,IACvD,CACJ,IAAM,OAAS,QAqBf,GApBA,OAAO,KAAO,IAoBT,MAAM,QAAQ,OAAO,EAKzB,OAJA,QAAQ,SAAW,OAIZ,mBAAmB,OAAQ,QAAS,MAAM,EAGlD,QAAW,UAAU,QACpB,OAAO,SAAW,OAIlB,OAAS,mBAAmB,OAAQ,OAAQ,MAAM,EAGnD,OAAO,QAGF,mBAAqB,CAC1B,OACA,QACA,SACa,CACb,IAAK,OAAQ,OAAO,OAEpB,IAAM,KAAO,OAAO,KAEpB,GAAI,QAAQ,mBAAqB,MAAQ,OAAO,OAAS,SACxD,OAAO,OAER,IAAM,WAAa,QAAQ,KAAK,OAmBhC,GAAI,OAAO,MAAO,CACjB,QAAS,EAAI,EAAG,EAAI,OAAO,MAAM,OAAQ,IACxC,OAAO,MAAM,GAAK,mBACjB,OAAO,MAAM,GACb,QACA,MACD,EAED,OAAO,OAGR,GAAI,OAAO,MAAO,CACjB,QAAS,EAAI,EAAG,EAAI,OAAO,MAAM,OAAQ,IACxC,OAAO,MAAM,GAAK,mBACjB,OAAO,MAAM,GACb,QACA,MACD,EAED,OAAO,OAGR,GAAI,OAAO,MAAO,CACjB,QAAS,EAAI,EAAG,EAAI,OAAO,MAAM,OAAQ,IACxC,OAAO,MAAM,GAAK,mBACjB,OAAO,MAAM,GACb,QACA,MACD,EAED,OAAO,OAGR,GAAI,OAAO,IAAK,OAAO,mBAAmB,OAAO,IAAK,QAAS,MAAM,EAErE,IAAM,OAAS,QAAU,QAAQ,YAEjC,GAAI,OAAO,SAAU,WAAY,CAEhC,IAAQ,MAAO,MAAO,MAAO,IAAK,uBAAY,SAAU,MAAS,OAE3D,GAAK,QAAQ,GAAG,IAAI,EAE1B,IAAK,GAAI,OAAO,OAGhB,IAAI,UAEE,kBAAoB,CAAC,UAAoB,CAC9C,IAAM,EAAI,mBAAmB,OAAM,EAGnC,GAAI,EAAE,IAAK,OAAO,EAAE,IAEpB,OAAO,GAGF,mBAAqB,CAAC,IAAe,CAC1C,GAAI,aAAc,EAAE,OAAS,SAAU,CACtC,IAAM,cAAyC,CAAC,EAChD,QAAY,IAAK,UAAU,OAAO,QAAQ,WAAU,EACnD,cAAc,KAAO,mBACpB,OACA,QACA,IACI,OACH,KAAM,EACP,CACD,EAED,MAAO,IACH,QACA,EACH,WAAY,aACb,EAGD,GAAI,OAAS,EAAE,OAAS,QACvB,MAAO,IACH,QACA,EACH,MAAO,mBAAmB,MAAO,QAAS,IACtC,OACH,KAAM,EACP,CAAC,CACF,EAED,IAAM,MAAQ,IACV,QACA,CACJ,EAMA,GAHA,OAAO,MAAM,SAIZ,aACA,EAAE,OAAS,UACX,EAAE,SAAW,gBACb,EAAE,UAAY,KAEd,UAAY,EAAE,aAAa,YAAY,IAAI,EAC3C,MAAM,QAAU,KAAK,UACpB,OAAM,OAAO,EAAE,OAAO,WAAU,CAAC,CAClC,EACA,MAAM,WAAa,YAIpB,GACC,OACA,EAAE,OAAS,UACX,EAAE,SAAW,eACb,EAAE,UAAY,KAEd,UAAY,EAAE,YAAY,MAAO,IAAI,EACrC,MAAM,QAAU,KAAK,UAAU,OAAM,OAAO,EAAE,MAAM,KAAK,CAAC,CAAC,EAC3D,MAAM,MAAQ,MAGf,OAAO,OAGR,GAAI,OAAQ,CACX,GAAI,YAAY,CACf,IAAM,cAAyC,CAAC,EAChD,QAAY,IAAK,SAAU,OAAO,QAAQ,WAAU,EACnD,cAAc,KAAO,mBACpB,MACA,QACA,IACI,OACH,KAAM,EACP,CACD,EAED,MAAO,IACH,KACH,WAAY,aACb,EACM,QAAI,OAAO,IACjB,MAAO,IACH,KACH,MAAO,MAAM,IAAI,CAAC,IACjB,mBAAmB,EAAG,QAAS,IAC3B,OACH,KAAM,EACP,CAAC,CACF,CACD,EAED,OAAO,KAGR,GAAI,GAAG,MACN,QAAS,EAAI,EAAG,EAAI,GAAG,MAAM,OAAQ,IACpC,GAAG,MAAM,GAAK,kBAAkB,GAAG,MAAM,EAAE,EACxC,QAAI,GAAG,MACX,QAAS,EAAI,EAAG,EAAI,GAAG,MAAM,OAAQ,IACpC,GAAG,MAAM,GAAK,kBAAkB,GAAG,MAAM,EAAE,EACxC,QAAI,GAAG,MACX,QAAS,EAAI,EAAG,EAAI,GAAG,MAAM,OAAQ,IACpC,GAAG,MAAM,GAAK,kBAAkB,GAAG,MAAM,EAAE,EACxC,QAAI,GAAG,IAAK,GAAG,IAAM,kBAAkB,GAAG,GAAG,EAElD,GAAI,UAAW,GAAG,eAAwB,UAAU,eAEpD,GAAI,GAAG,OAAS,GAAG,OAAS,GAAG,OAAS,GAAG,IAAK,OAAO,GAEvD,GAAI,YAAY,CACf,IAAM,cAAyC,CAAC,EAChD,QAAY,IAAK,SAAU,OAAO,QAAQ,WAAU,EACnD,cAAc,KAAO,mBACpB,MACA,QACA,IACI,OACH,KAAM,EACP,CACD,EAED,MAAO,IACH,QACA,GACH,WAAY,aACb,EACM,QAAI,OAAO,IACjB,MAAO,IACH,QACA,GACH,MAAO,MAAM,IAAI,CAAC,IACjB,mBAAmB,EAAG,QAAS,IAC3B,OACH,KAAM,EACP,CAAC,CACF,CACD,EAED,MAAO,IACH,QACA,EACJ,EAGD,IAAM,WAAa,QAAQ,WAE3B,GAAI,YAAc,MAAQ,QAAQ,WAAa,GAC9C,QAAY,IAAK,SAAU,OAAO,QAAQ,UAAU,EACnD,OAAQ,MAAM,aACR,WAEJ,IAAQ,MAAO,MAAO,MAAO,IAAK,QAAS,MAAS,MAC9C,GAAK,QAAQ,GAAG,IAAI,EAE1B,IAAK,GAAI,OAAO,OAEhB,GAAI,GAAG,MACN,QAAS,EAAI,EAAG,EAAI,GAAG,MAAM,OAAQ,IACpC,GAAG,MAAM,GAAK,IAAK,QAAS,GAAG,MAAM,EAAG,EACrC,QAAI,GAAG,MACX,QAAS,EAAI,EAAG,EAAI,GAAG,MAAM,OAAQ,IACpC,GAAG,MAAM,GAAK,IAAK,QAAS,GAAG,MAAM,EAAG,EACrC,QAAI,GAAG,MACX,QAAS,EAAI,EAAG,EAAI,GAAG,MAAM,OAAQ,IACpC,GAAG,MAAM,GAAK,IAAK,QAAS,GAAG,MAAM,EAAG,EACrC,QAAI,GAAG,IAAK,GAAG,IAAM,IAAK,QAAS,GAAG,GAAI,EAE/C,WAAW,KAAO,IACd,QACA,mBAAmB,KAAM,QAAS,IACjC,OACH,KAAM,EACP,CAAC,CACF,EACA,UAEI,aACA,QACJ,WAAW,KAAO,mBAAmB,MAAO,QAAS,IACjD,OACH,KAAM,EACP,CAAC,EACD,cAGA,GAAI,MAAM,QAAQ,MAAM,KAAK,EAC5B,QAAS,EAAI,EAAG,EAAI,MAAM,MAAM,OAAQ,IACvC,MAAM,MAAM,GAAK,mBAChB,MAAM,MAAM,GACZ,QACA,IACI,OACH,KAAM,EACP,CACD,EAEK,QACN,MAAM,OACN,MAAM,OACN,MAAM,OACN,MAAM,IAEN,WAAW,KAAO,mBAAmB,MAAO,QAAS,IACjD,OACH,KAAM,EACP,CAAC,EACG,QAAI,MAAM,OAAS,QACvB,MAAM,MAAQ,mBAAmB,MAAM,MAAO,QAAS,IACnD,OACH,KAAM,EACP,CAAC,EAGF,MAIJ,OAAO,QAGF,cAAgB,CAAC,SAAuB,CAAC,QAAmB,CACjE,GAAI,OAAO,QAAU,SACpB,GAAI,CACH,OAAO,OAAM,MAAM,OAAQ,KAAK,EAC/B,KAAM,CACP,GAAI,CACH,OAAO,OAAM,MAAM,OAAQ,KAAK,EAC/B,KAAM,CACP,OAAO,OAIV,OAAO,OAKK,mBAAqB,CACjC,GAEC,OAAS,CAAC,EACV,QAAU,GACV,QACA,UAAY,GACZ,qBAAuB,GACvB,OAAS,GACT,iBAAmB,CAAC,EACpB,WACA,oBAWG,CAAC,IACyD,CAG9D,GAFA,WAAa,YAAY,OAAO,CAAC,IAAM,CAAC,GAEnC,EAAG,CACP,IAAK,YAAY,OAAQ,OAEzB,EAAI,WAAW,GACf,WAAa,WAAW,MAAM,CAAC,EAGhC,IAAI,YAAmC,OAEjC,cAAgB,CAAC,UAAmC,CACzD,GAAI,OACH,OAAO,kBAAkB,QAAQ,CAChC,CACC,KAAM,EAAE,OAAO,EACf,GAAI,CAAC,UAAY,EAAE,QAAQ,OAAO,EAClC,iBAAkB,EACnB,EACA,CACC,KAAM,EAAE,QAAQ,EAChB,GAAI,CAAC,UAAY,EAAE,cAAc,OAAO,EACxC,iBAAkB,EACnB,EACA,GAAI,MAAM,QAAQ,gBAAgB,EAC/B,iBACA,CAAC,gBAAgB,CACrB,CAAC,EAEF,OAAO,kBAAkB,QAAQ,gBAAgB,GAG5C,UAAY,CAAC,KAA6C,CAC/D,IAAI,QAEJ,IAAK,GAAG,OAER,GAAI,OAAO,KAAM,SAAU,QAAS,GAC/B,KAGJ,IAAM,QAAU,GAAE,SAAS,IAAI,EACzB,IAAM,QAAU,GAAE,UAAU,EAAG,GAAE,OAAS,CAAC,EAAI,GAOrD,GALA,QACE,SAAyC,OACzC,GACD,GAAK,OAAO,KAET,QAAS,QAAS,EAAE,MAAM,OAAM,EAGrC,IAAK,QAAQ,OAEb,IAAI,aACJ,GAAI,QAAO,SAAU,WAAa,aAAe,OAAO,OAAM,GAAI,CACjE,IAAM,GAAK,SAAS,EAEpB,GAAI,cAAgB,OAAW,YAAc,aAQ7C,QANmB,EAAE,OAAO,IAExB,SAAS,OACX,IAAK,OACP,CAAC,EAEc,OAAO,EAAE,EAGzB,GAAI,QAAO,SAAU,SAAU,CAC9B,IAAM,QAAmC,CAAC,EAE1C,QAAY,KAAK,SAAU,OAAO,QAAQ,QAAO,KAAK,EACrD,QAAQ,MAAO,cAAc,KAAgB,EAE9C,IAAM,IAAM,QAAO,KACnB,QAAS,EAAE,OAAO,OAAO,EAAE,OAAO,GAAG,EAC/B,QAAI,QAAU,iBAAkB,QAAS,cAAc,OAAM,EAEpE,OAAO,SAGJ,OAAS,UAAU,CAAC,EAExB,GAAI,YAAY,OAAQ,CACvB,IAAI,cAAgB,IAEZ,OAAQ,mBAAoB,YAAe,mBAAmB,CACrE,OACA,GAAG,WAAW,IAAI,SAAS,CAC5B,CAAC,EAED,GAAI,YAwBH,GAvBA,OAAS,EAAE,UAAU,CACpB,GAAI,mBAAqB,CAAC,kBAAkB,EAAI,CAAC,EACjD,GAAG,WAAW,IAAI,CAAC,IAAM,CACxB,IAAM,QAAS,UAAU,CAAC,EAE1B,GACC,QAAO,OAAS,UAChB,yBAA0B,QACzB,CACD,IACE,eACD,QAAO,uBAAyB,GAEhC,cAAgB,GAGjB,OAAO,QAAO,qBAGf,OAAO,QACP,CACF,CAAC,EAEG,OAAO,OAAS,UAAY,cAC/B,OAAO,qBAAuB,IAGhC,QACC,OAAO,OAAS,UAChB,yBAA0B,SAAW,GAErC,OAAO,qBAAuB,qBAGhC,GAAI,QAAS,CACZ,IAAM,UAAkC,CACvC,OACA,WAAY,GACZ,UAAW,IAAM,GACjB,KAAM,GAEN,MAAO,CAAC,QAAmB,OAAM,MAAM,OAAQ,KAAK,EACpD,OAAQ,CAAC,QAAmB,OAAM,OAAO,OAAQ,KAAK,EACtD,KAAM,IAAM,GACZ,MAAO,cAAc,MAAM,EAC3B,OAAQ,CAAC,QAAmB,OAAM,OAAO,OAAQ,KAAK,EACtD,OAAQ,CAAC,QAAmB,OAAM,OAAO,OAAQ,KAAK,KAClD,wBAAuB,EAAG,CAC7B,GAAI,6BAA8B,KACjC,OAAO,KAAK,4BAEb,OAAQ,KAAK,4BACZ,wBAAwB,MAAM,MAE5B,WAAU,EAAG,CAChB,GAAI,gBAAiB,KAAM,OAAO,KAAK,eAEvC,OAAQ,KAAK,eAAiB,YAAY,UAAW,MAAM,MAExD,WAAU,EAAG,CAChB,GAAI,gBAAiB,KAAM,OAAO,KAAK,eAEvC,OAAQ,KAAK,eAAiB,WAAW,MAAM,MAE5C,aAAY,EAAG,CAClB,GAAI,kBAAmB,KAAM,OAAO,KAAK,iBAEzC,OAAQ,KAAK,iBAAmB,aAAa,MAAM,GAEpD,UAAW,eACP,OAAM,EAAG,CACZ,GAAI,YAAa,KAAM,OAAO,KAAK,WAEnC,OAAQ,KAAK,WAAa,aAAa,MAAM,EAE/C,EAEA,GAAI,OAAO,QAGV,GAFA,UAAU,OAAS,OAAO,OAEtB,WAAW,QAAQ,OAAQ,OAAO,UAAU,OAAO,OAGxD,GAAI,WAAa,OAAO,uBAAyB,GAChD,GAAI,YAAc,IAAQ,YAAc,cACvC,GAAI,CACH,UAAU,MAAQ,aAAa,OAAQ,CACtC,2BACA,SAAU,YAAW,EACrB,OACD,CAAC,EACA,KAAM,CACP,QAAQ,KACP,6GACD,EACA,QAAQ,KAAK,MAAM,EACnB,UAAU,MAAQ,cAAc,MAAM,EAEjC,eAAU,MAAQ,cAAc,MAAM,EA4B9C,OAzBA,UAAU,MAAQ,CAAC,IAAM,CACxB,GAAI,CACH,OAAO,UAAU,OAAO,CAAC,EACxB,MAAO,OAAO,CACf,KAAM,CAAC,GAAG,UAAU,OAAO,CAAC,CAAC,EAAE,IAAI,aAAa,IAIlD,UAAU,UAAY,CAAC,IAAM,CAC5B,GAAI,CACH,MAAO,CAAE,QAAS,GAAM,KAAM,UAAU,OAAO,CAAC,EAAG,MAAO,IAAK,EAC9D,MAAO,OAAO,CACf,IAAM,OAAS,CAAC,GAAG,SAAS,OAAO,CAAC,CAAC,EAAE,IAAI,aAAa,EAExD,MAAO,CACN,QAAS,GACT,KAAM,KACN,MAAO,OAAO,IAAI,QAClB,MACD,IAMK,UAGR,IAAM,SAAW,cAAa,QAC7B,OACA,OAAO,OAAO,MAAM,CACrB,EAEA,GAAI,OAAO,QAGV,GAFA,SAAS,OAAS,OAAO,OAErB,UAAU,QAAQ,OAAQ,OAAO,SAAS,OAAO,OAGtD,GAAI,YAAc,IAAQ,YAAc,cACvC,GAAI,CACH,SAAS,MAAQ,aAAa,OAAQ,CACrC,2BACA,SAAU,YAAW,EACrB,OACD,CAAC,EACA,MAAO,OAAO,CACf,QAAQ,KACP,6GACD,EACA,QAAQ,KAAK,MAAM,EAEnB,SAAS,MAAQ,cAAc,MAAM,EAEhC,cAAS,MAAQ,cAAc,MAAM,EA0D5C,OAxDA,SAAS,MAAQ,CAAC,IAAM,CACvB,GAAI,CACH,OAAO,SAAS,OAAO,CAAC,EACvB,MAAO,OAAO,CACf,KAAM,CAAC,GAAG,SAAS,OAAO,CAAC,CAAC,EAAE,IAAI,aAAa,IAIjD,SAAS,UAAY,CAAC,IAAM,CAC3B,GAAI,CACH,MAAO,CAAE,QAAS,GAAM,KAAM,SAAS,OAAO,CAAC,EAAG,MAAO,IAAK,EAC7D,MAAO,OAAO,CACf,IAAM,OAAS,CAAC,GAAG,SAAS,OAAO,CAAC,CAAC,EAAE,IAAI,aAAa,EAExD,MAAO,CACN,QAAS,GACT,KAAM,KACN,MAAO,OAAO,IAAI,QAClB,MACD,IAIF,OAAO,OAAO,SAAU,IACnB,wBAAuB,EAAG,CAC7B,GAAI,6BAA8B,KACjC,OAAO,KAAK,4BAEb,OAAQ,KAAK,4BACZ,wBAAwB,QAAQ,MAE9B,WAAU,EAAG,CAChB,GAAI,gBAAiB,KAAM,OAAO,KAAK,eAEvC,OAAQ,KAAK,eAAiB,YAAY,UAAW,QAAQ,MAE1D,WAAU,EAAG,CAChB,GAAI,gBAAiB,KAAM,OAAO,KAAK,eAEvC,OAAQ,KAAK,eAAiB,WAAW,QAAQ,MAE9C,aAAY,EAAG,CAClB,GAAI,kBAAmB,KAAM,OAAO,KAAK,iBAEzC,OAAQ,KAAK,iBAAmB,aAAa,MAAM,MAEhD,OAAM,EAAG,CACZ,GAAI,YAAa,KAAM,OAAO,KAAK,WAEnC,OAAQ,KAAK,WAAa,OAAO,MAAM,GAExC,UAAW,WACZ,CAAyB,EAIlB,UAGK,QAAU,CAAC,SACvB,OAAO,SAAU,UAAa,OAAO,UAAY,OAAO,MAE5C,mBAAqB,CACjC,UAII,CACJ,GAAI,QAAQ,SAAW,EACtB,MAAO,CACN,OAAQ,OACR,WAAY,CAAC,CACd,EAED,GAAI,QAAQ,SAAW,EACtB,OAAO,QAAQ,GAAG,OAAS,SACxB,CACA,OAAQ,QAAQ,GAChB,WAAY,CAAC,CACd,EACC,CACA,OAAQ,OACR,WAAY,OACb,EAEH,IAAI,UACE,WAAwB,CAAC,EAE3B,2BAA6B,GAC7B,4BAA8B,GAElC,QAAW,UAAU,QAAS,CAC7B,GAAI,OAAO,OAAS,SAAU,CAC7B,WAAW,KAAK,MAAM,EACtB,SAGD,GAAI,yBAA0B,QAC7B,GAAI,OAAO,uBAAyB,GACnC,2BAA6B,GACzB,QAAI,OAAO,uBAAyB,GACxC,4BAA8B,GAGhC,IAAK,UAAY,CAChB,UAAY,OACZ,SAGD,UAAY,IACR,aACA,OACH,WAAY,IACR,UAAU,cACV,OAAO,UACX,EACA,SAAU,CAAC,GAAI,WAAW,UAAY,CAAC,EAAI,GAAG,OAAO,QAAQ,CAC9D,EAGD,GAAI,UAAY,CACf,GAAI,UAAU,SACb,UAAU,SAAW,CAAC,GAAG,IAAI,IAAI,UAAU,QAAQ,CAAC,EAErD,GAAI,4BAA6B,UAAU,qBAAuB,GAC7D,QAAI,2BACR,UAAU,qBAAuB,GAGnC,MAAO,CACN,OAAQ,UACR,UACD,GAGY,2BAA6B,CACzC,GAEC,OAAS,CAAC,EACV,QACA,QAAU,GACV,UAAY,GACZ,qBAAuB,GACvB,WAAa,CAAC,EACd,sBAUqD,CAGtD,GAFA,WAAa,WAAW,OAAO,CAAC,IAAM,CAAC,GAElC,EAAG,CACP,IAAK,YAAY,OAAQ,OAEzB,EAAI,WAAW,GACf,WAAa,WAAW,MAAM,CAAC,EAGhC,IAAI,oBAEJ,GAAI,OAAO,IAAM,SAAU,oBAAsB,EAC5C,KACJ,IAAM,QAAU,EAAE,SAAS,IAAI,EACzB,IAAM,QAAU,EAAE,UAAU,EAAG,EAAE,OAAS,CAAC,EAAI,EAKrD,GAHA,oBACE,QAA4B,OAAO,GAAY,GAAK,OAAO,KAEzD,QACH,oBAAsB,EAAE,MAAM,mBAA8B,EAG9D,IAAK,oBAAqB,OAE1B,GAAI,SAAQ,oBACX,MAAO,CACN,IAAK,mBAAmB,oBAAqB,CAC5C,QACA,OACA,qBACA,QACA,UACA,OAAQ,GACR,iBAAkB,CAAC,EACnB,WAAY,WAAW,IAAI,CAAC,IAAM,EAAG,IAAI,EACzC,kBACD,CAAC,CACF,EAGD,IAAM,OAA+C,CAAC,EAgDtD,OA9CA,OAAO,KAAK,mBAAmB,EAAE,QAAQ,CAAC,UAAgC,CACzE,GAAI,OAAO,OAAM,EAAG,OAEpB,IAAM,kBAAoB,oBAAoB,CAAC,SAE/C,GAAI,OAAO,oBAAsB,SAAU,CAC1C,GAAI,qBAAqB,OAAQ,CAChC,IAAM,OAAS,OAAO,mBAGtB,OAAO,CAAC,SACP,SAAQ,OACL,mBAAmB,OAAQ,CAC3B,QACA,OACA,qBACA,QACA,UACA,OAAQ,GACR,iBAAkB,CAAC,EACnB,WAAY,WAAW,IAAI,CAAC,IAAM,EAAG,CAAC,QAAO,EAC7C,kBACD,CAAC,EACA,OAGL,OAID,OAAO,CAAC,SACP,SAAQ,kBACL,mBAAmB,kBAA8B,CACjD,QACA,OACA,qBACA,QACA,UACA,OAAQ,GACR,iBAAkB,CAAC,EACnB,WAAY,WAAW,IAAI,CAAC,IAAM,EAAG,CAAC,QAAO,EAC7C,kBACD,CAAC,EACA,kBACJ,EAEM,QAGJ,4BAES,2BAA6B,IAAM,CAC/C,IAAK,4BACJ,4BAA8B,CAC7B,CACC,KAAM,EAAE,OAAO,CAAC,CAAC,EACjB,GAAI,IAAM,EAAE,aAAa,CAAC,CAAC,EAC3B,YAAa,EACd,EACA,CACC,KAAM,EAAE,MAAM,EAAE,IAAI,CAAC,EACrB,GAAI,IAAM,EAAE,YAAY,EAAE,IAAI,CAAC,CAChC,CACD,EAGD,OAAO,6BAGJ,qBAES,oBAAsB,IAAM,CACxC,IAAK,qBACJ,qBAAuB,CACtB,CACC,KAAM,EAAE,OAAO,EACf,GAAI,CAAC,UAAY,EAAE,QAAQ,OAAO,EAClC,SAAU,EACX,EACA,CACC,KAAM,EAAE,QAAQ,EAChB,GAAI,CAAC,UAAY,EAAE,cAAc,OAAO,EACxC,SAAU,EACX,CACD,EAED,OAAO,sBAGK,mBAAqB,EACjC,UACA,QACA,cAAgB,CAAC,EACjB,OACA,QACA,OACA,WACA,sBAUK,CACL,IAAI,gBAAkB,mBAAmB,UAAW,CACnD,QACA,QACA,OACA,qBAAsB,GACtB,OAAQ,GACR,iBAAkB,2BAA2B,EAC7C,WACA,kBACD,CAAC,EAED,GAAI,gBACH,gBAAgB,OAAS,YAAY,gBAAgB,OAAQ,MAAM,EAEnE,qBAAkB,mBAAmB,EAAE,OAAO,EAAE,IAAI,CAAC,EAAG,CACvD,QACA,QACA,OACA,qBAAsB,GACtB,WACA,kBACD,CAAC,EAED,gBAAgB,OAAS,cAG1B,OAAO,iBHrsCR,IAAM,WAAa,CAAC,MAAe,YAClC,UAAY,MAAQ,GAEf,eAAiB,CACtB,OACA,OACA,aACA,cACA,WACA,mBAEA,aAEA,oCAEA,2BAEA,qBACD,EAEM,aAAe,EACpB,QAAU,IACV,MAAQ,CAAC,EACT,SAKK,CACL,IAAK,MAAM,OACV,MAAO,IAAM,CACZ,MAAO,CACN,YAAY,EAAG,CACd,MAAO,IAAM,IAEd,OAAO,EAAG,EACX,GAGF,QAAS,EAAI,EAAG,EAAI,MAAM,OAAQ,IACjC,MACC,aAAa,gBAAgB,cAAc,mBAAmB,cACjD,KAAK,2BAA2B,aAAa,MAAM;AAAA,CACjE,EAED,MAAO,CACN,OAEC,KACA,MAAQ,GAKL,CAAC,IACD,CAUJ,IAAK,KAAM,KAAO,YAElB,IAAM,SAAW,QAAU,QAAU,YAAc,SAEnD,QAAS,EAAI,EAAG,EAAI,MAAM,OAAQ,IACjC,MACC,GAAG,WAAW,YAAY,KAAK,oBAEpB,gBACD,uCAEA;AAAA,CAEX,EAED,MAAO,CACN,OAAO,EAAG,CACT,QAAS,EAAI,EAAG,EAAI,MAAM,OAAQ,IACjC,MAAM,GAAG,WAAW;AAAA,CAAe,GAErC,YAAY,CAAC,MAAc,CAC1B,QAAS,EAAI,EAAG,EAAI,MAAM,OAAQ,IACjC,MACC,GAAG,gBAAgB,KAAK,WAAW,wCAExB,gBACD;AAAA,CAGX,EAED,MAAO,CAAC,UAAqB,CAC5B,QAAS,EAAI,EAAG,EAAI,MAAM,OAAQ,IACjC,GAAI,QAMH,MACC,MAAM,6BACF,gBAAgB,OAAO,kBAEvB,gBAAgB,QAErB,EACI,WAAM,GAAG,gBAAgB;AAAA,CAAS,GAI3C,IAII,eAAiB,EACtB,OACA,KACA,KACA,UAAY,KACZ,UACA,eAAiB,MAQZ,CACL,IAAK,YAAc,OAAO,OAAS,OAAO,wBAAyB,MAAO,GAE1E,GAAI,YAAc,IAAQ,YAAc,cAAe,CACtD,GAAI,eACH,MAAO,GAAG,kBAAkB,mBAAmB;AAAA,EAEhD,MACC,OACG,kBAAkB,mBAAmB;AAAA,UAK1C,GAAI,YAAc,UACjB,MAAO,GAAG,kBAAkB,mBAAmB;AAAA,EAEhD,MAAO,IAGF,yBAA2B,EAChC,eAAiB,GACjB,UAAY,GACZ,UACA,aAAe,GACf,iBAAmB,GACnB,YAAc,OAQR,CACN,SAAU,CAAC,KAAc,MAAQ,KAAK,SACrC,+CAA+C,mBAAmB,QAAQ,SAC3E,SAAU,CAAC,KAAO,MAAQ,CACzB,GAAI,iBAAkB,MAAO,GAE7B,IAAI,KAAO,eAAiB;AAAA,EAE5B,MACC,MAAM,4DACU;AAAA,EACb,QAAQ,sCAIZ,QAAY,QAAQ,SAAU,OAAO,QAAQ,UAAU,QAAS,EAAG,CAClE,MAAQ;AAAA,OAAU,cAAa;AAAA,EAE/B,IAAM,WAAa,MAAM,QAAQ,aAAe,GAE1C,eAAiB,YAAc,YAE/B,MAAQ,EAAG,eAAiB,IAAU,CAAC,IAC5C,eAAe,CACd,KACA,OAAQ,MACR,KAAM,WACN,UAAW,YAAY,WACvB,UACA,cACD,CAAC,EAEF,GAAI,eAAgB,MAAQ,MAAM,EAElC,IAAM,mBACJ,gBAAkB,YAAc,WAGlC,GAAI,cAAgB,MAAM,aACzB,MACC,OACG,2BAA2B,mBAAkB;AAAA,eAChC,kBAEf,kBACE;AAAA,EACD,MAAM,CAAE,eAAgB,EAAK,CAAC,EAC9B,GAAG,2BAA2B,mBAAkB;AAAA,iEAEW,YAAW,SAErE,2DAA2D,YAAW,SACzE,IACG,KACJ,IAAK,eAAgB,MAAQ,MAAM,EAEnC,IAAK,WACJ,MACC,yBAAyB,kBAAiB,yEACiB,YAAW;AAAA,eACtD;AAAA,EAGnB,MAAQ;AAAA,EAGT,OAAO,KAAO,IAEhB,GAEM,YAAc,CAAC,IAAgC,CAIpD,OAFW,GAAG,IAAM,GAEV,YAAY,OAAS,iBAG1B,mBAAqB,yBACrB,cAAgB,uCAET,QAAU,CAAC,IAAgC,CACvD,IAAM,UAAW,OAAO,IAAM,SAE9B,GAAI,WAAY,EAAE,UAAY,OAAW,OAAO,EAAE,QAElD,IAAM,GAAK,UAAW,EAAE,GAAK,EAE7B,GAAI,GAAG,YAAY,OAAS,gBAAiB,MAAO,GAEpD,IAAM,QAAkB,GAAG,SAAS,EAEpC,GAAI,mBAAmB,KAAK,OAAO,EAAG,CACrC,GAAI,UAAU,EAAE,QAAU,GAE1B,MAAO,GAGR,IAAM,OAAS,cAAc,KAAK,OAAO,EAEzC,GAAI,UAAU,EAAE,QAAU,OAE1B,OAAO,QAGF,UAAY,CAAC,IAA8C,CAChE,IAAM,UAAW,OAAO,IAAM,SAE9B,GAAI,WAAY,EAAE,YAAc,OAAW,OAAO,EAAE,UAEpD,IAAM,UAAY,UACf,EAAE,GAAG,SAAS,EACd,OAAO,IAAM,SACZ,EAAE,SAAS,EACX,EAEE,eAAiB,UAAU,QAAQ,GAAG,EAG5C,GACC,UAAU,WAAW,eAAiB,CAAC,IAAM,IAC7C,UAAU,WAAW,eAAiB,CAAC,IAAM,IAC5C,CACD,GAAI,UAAU,EAAE,UAAY,GAE5B,MAAO,GAGR,IAAM,OAAS,UAAU,SAAS,QAAQ,EAE1C,GAAI,UAAU,EAAE,UAAY,OAE5B,OAAO,QAGF,YAAc,CAAC,IAAgC,CAEpD,IAAM,GAAK,GAAG,IAAM,EAEpB,OACC,GAAG,YAAY,OAAS,0BACxB,GAAG,YAAY,OAAS,qBAIb,eAAiB,EAC7B,IACA,KACA,OACA,MACA,UACA,QACA,UAAY,GACZ,aAUsB,CACtB,IAAM,QAAU,IAAI,YAAY,eAC1B,eAAiB,IAAI,YAAY,QACjC,WAAa,OAAO,UAAY,WAEtC,IAAK,YAMJ,GALA,QAAU,eAAe,YAAY,QAAS,CAE7C,QAAS,IAAI,YAAc,CAAC,CAC7B,CAAC,EAGA,MAAM,OAAO,QACb,MAAM,WAAW,QACjB,MAAM,cAAc,QACpB,MAAM,aAAa,OAClB,CACD,GAAI,mBAAmB,SACtB,OAAO,SACN,IACA;AAAA,oCACD,EAAE,OAAO,EAEV,OAAO,SACN,IACA;AAAA,4BACD,EAAE,OAAO,GAIX,IAAM,OAAS,WAAa,aAAe,UACrC,mBAAqB,MAAM,eAAe,OAE1C,WAAa,MAAM,OAAO,OAC5B,UAAY,GAUhB,GARA,UAAY,QAAQ,MAAO,SAAS,EACpC,UAAY,QACX,CACC,OACD,EACA,SACD,EAEI,QAAQ,QAAS,CACpB,IAAM,QAAU,QAAQ,QAAQ,SAAS,EAEzC,GAAI,QAAS,WAAa,QAG3B,GAAI,UAAU,OACb,WACC;AAAA,EAIF,UAAU,aAAa,EACvB,UAAU,cAAc,EACxB,UAAU,gBAAgB,EAC1B,UAAU,eAAe,EACzB,UAAU,eAAe,EACzB,UAAU,iBAAiB,EAE3B,IAAM,gBACH,UAAU,QACV,UAAU,WACV,UAAU,UACV,UAAU,SACV,UAAU,UACV,UAAU,SAEP,SAAW,UAAU,SAAW,UAAU,MAE1C,cACL,MAAM,OAAO,SAAW,GAExB,MAAM,MAAM,GAAG,KAAO,OAEjB,QACL,SAAW,IACX,SAAW,OACX,SAAW,SACV,UAAU,QAAU,UAAU,QAAU,MAAM,OAAO,UACrD,cAGI,eAAiB,IAAI,WACrB,kBACL,kBAAoB,OAAO,KAAK,cAAc,EAAE,OAG3C,WACL,UAAU,WACR,UAAU,SACX,QAAQ,2BAA6B,IAAQ,UAAU,KAEnD,UAAY,UAAU,UAAY,UAAU,OAE5C,WAIF,UAAU,QAAQ,OACnB,YAAY,WAAW,QAAQ,OAAQ,IAAI,OAAO,MAAa,EAC/D,IAAI,OAAO,OAEV,cAAgB,GACd,aAAe,IAAM,CAC1B,GAAI,cAAe,OAAO,cAE1B,GAAI,YAAY,KAAM,CACrB,IAAK,WAAW,QACf,MAAM,IAAI,MACT,iDAAiD,WAAW,OAC7D,EAED,IAAM,QAAU,WAAW,QACxB,OACA,OAAO,WAAW,UAAY,SAC7B,WAAW,QACX,WAAW,QAAQ,GAKvB,GAHA,eACC;AAAA,iBAEG,WAAW,OAAS,GACvB,eACC,iHAC0D,YAG3D,aAAW,QAAQ,WAAW,KAC7B,eACC,kBAAkB,+BACD,6CAA6C,iBAAiB;AAAA,EAElF,eAAiB;AAAA,EAGlB,OAAO,eAGF,UAAY,IAAI,OAAO,UACvB,aAAe,IAAI,OAAO,aAE1B,WAAa,yBAAyB,CAC3C,UACA,UACA,aACA,iBAAkB,mBAAmB,SACrC,cAAe,IAAI,OAAO,QAC3B,CAAC,EAED,GAAI,WAAY,WAAa,QAAQ,QAErC,GAAI,SAAU,WAAa;AAAA,EAE3B,IAAM,OAAS,aAAa,CAC3B,MAAO,MAAM,MACb,MAAO,CAAC,OAAS,CAChB,WAAa,KAEf,CAAC,EAID,GAFA,WAAa,OAET,UAAW,CACd,IAAM,IAAM,CAAC,KAA2B,eAA2B,CAElE,IAAM,MAAQ,aAAa,OAAS,aACpC,IAAK,MACJ,OAAO,OAAO,eAAiB,SAC5B,GAAG,SAAS,iBACZ,GAAG,QAAQ,gBAEf,GAAI,OAAO,QAAU,SAAU,MAAO,GAAG,SAAS,UAClD,GAAI,iBAAiB,KACpB,MAAO,GAAG,kBAAkB,MAAM,QAAQ,MAE3C,MAAO,GAAG,QAAQ,UAGb,QAAU,WACb,YACA,WAAW,UAAY,OACpB,OAAO,WAAW,UAAY,SAC7B,IAAI,WAAW,WACf,IACD,WAAW,QAAQ,OAClB,CAAC,EAAG,IAAM,EAAI,IAAI,MAClB,EACD,EACA,IACA,oBAGH,WAAW,OAAS,GACjB,GACA,WAAW,OAAS,OACnB,IACD,WAAW,KAAK,OACf,CAAC,EAAG,IAAM,EAAI,IAAI,MAClB,EACD,EACA,IACC,eAEL,IAAI,QAAQ,EACZ,IAAI,SAAS,EACb,IAAI,UAAU,EACd,IAAI,QAAQ,EACZ,IAAI,OAAQ,GAAG,EACf,IAAI,UAAU,EACd,IAAI,UAAU,EACd,IAAI,QAAQ,EACZ,IACC,YAEH,GAAI,WACH,WAAa;AAAA,oDAAuD;AAAA,EAEpE,gBAAa;AAAA,mEAAsE;AAAA,EAGrF,GAAI,SAAU,CACb,IAAM,aAQL,CAAC,EAEF,GAAI,UAAU,OAAS,UAAU,MAAM,OAAO,OAAS,SAAU,CAChE,IAAM,WAAa,UAAU,MAAM,OAAO,WAE1C,IAAK,UAAU,MAAM,wBACpB,QAAY,IAAK,UAAW,OAAO,QAAQ,UAAU,EAAG,CACvD,IAAI,MAAQ,OAEN,QACL,MAAM,OAAS,WACb,MAAM,OAAO,KACd,CAAC,IACA,EAAE,OAAS,UACX,EAAE,SAAW,aACf,EAGD,GACC,OACA,iBAAgB,OAChB,MAAM,OAAS,SACf,MAAM,MAEN,MAAQ,MAAM,MAEf,IAAQ,KAAM,OAAU,MAExB,aAAa,KAAK,CACjB,IACA,QACA,oBACE,SAAW,MAAM,OAAO,OAAS,YAChC,MAAM,OAAO,OAAO,KACrB,CAAC,IACA,EAAE,OAAS,UAAY,EAAE,OAAS,OACpC,EACD,SACC,OAAS,UACT,OAAO,KACN,CAAC,IACA,EAAE,OAAS,UACX,EAAE,SAAW,aACf,EACD,QAAS,KACV,CAAC,GAIJ,IAAK,aAAa,OACjB,WACC,yEAKK,KACN,WAAa;AAAA,EAEb,IAAI,MAAQ,EACZ,QACC,IACA,QACA,mBACA,oBACA,SACI,aAAc,CAClB,IAAM,OACJ,QAAU,EAAI,OAAS,IACxB,wBAAwB;AAAA,OACd;AAAA,EAEX,GAAI,QAGH,GAFA,WAAa,MAET,oBACH,WACC,yCACsB,IAAI,OAAS;AAAA;AAAA,MAE5B;AAAA,GACH;AAAA;AAAA,GAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAOA;AAAA;AAAA,uBAEoB;AAAA,+BAIjB,6BACH,uBAAuB;AAAA;AAAA,GAEvB,yBAAyB;AAAA,EAG9B,gBACC,yCACsB,IAAI,OAAS;AAAA;AAAA,MAE5B,sBACH;AAAA;AAAA,0BAGuB,UAAU,uCAC5B;AAAA;AAAA,0BAIkB,UAAU,uCAC5B;AAAA,wBAEe;AAAA;AAAA,GAGpB,QAAI,UACV,WACC,MACA,sCACsB,IAAI,OAAS;AAAA;AAAA,kBAEhB,uEACV,4EACF,0BAEH,qBAAqB,kBAItB,KAUJ,GATA,WACC,MACA,sCACsB,IAAI,OAAS;AAAA;AAAA,kBAEhB;AAAA,QAEf,wEAED,MACH,WACC;AAAA,+BAAkC;AAAA,uBAE9B,WAAW;AAAA;AAAA,qCAGW,IAAI,OAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAYnC,wCAEA,+CAKN,WAAa,KAGd,QACA,WAAa;AAAA,EAGd,WACC,YACA,aACE,IAAI,EAAG,KAAO,SAAU,IAAI,SAAS,QAAO,EAC5C,KAAK,GAAG,EACV,IAGD,WAAa;AAAA,GAIf,IAAM,eAAiB,OAAO,UAAY,YAAc,QAAQ,OAAO,EAEjE,aACL,UAAY,MAAM,eAAe,OAAS,eAAiB,GAEtD,WACL,WACA,SACA,kBACE,MAAM,OAAO,UACb,MAAM,aAAa,KAAK,OAAO,KAC/B,MAAM,cAAc,KAAK,OAAO,KAChC,MAAM,WAAW,KAAK,OAAO,KAC7B,MAAM,aAAa,KAAK,OAAO,EAE5B,aACJ,OAAO,UAAY,WAAa,YAAY,OAAc,EAAI,OAC7D,MAAM,cAAc,KAAK,WAAW,KACpC,MAAM,aAAa,KAAK,WAAW,KACnC,MAAM,WAAW,KAAK,WAAW,EAE9B,aAAe,OAAO,KAAK,UAAU,UAAY,CAAC,CAAC,EACnD,qBAAuB,aAAa,OAAS,EAC7C,aACL,aAAa,SAAW,GACvB,aAAa,SAAW,GAAK,aAAa,KAAO,MAE7C,OACL,UAAU,QACV,UAAU,KACV,YACA,UACA,uBACC,cACA,YAAc,mBACf,YAEK,aAAc,CAAC,EAAI,MACxB,UAAU,OAAS,cAAgB,wBAAwB,eAAe,IAAI,OAAS,SAAW,KAAK;AAAA,EAElG,mBACL,aAAe,QAAQ,mBACpB,IAAI,QAAQ,qBACZ,GAEJ,GAAI,UAAY,UAAU,MAAO,WAAa,aAAa;AAAA,EAE3D,IAAM,cAAgB,OAAO,QAAS,CACrC,MAAO,MAAM,OAAO,MACrB,CAAC,EAED,GAAI,QAAS,CACZ,IAAM,mBACH,MAAM,OAAO,QAAU,UAAU,MAAQ,UAAU,KAEtD,GAAI,QAAQ,OAAO,QAAS,WAAa,QAAQ,OAAO,QAExD,WAAa;AAAA,MAEb,IAAI,OACH,OAAO,MAAM,QAAU,SACpB,MAAM,MACN,MAAM,QAAQ,MAAM,KAAK,GAAK,MAAM,MAAM,SAAW,EACpD,OAAO,MAAM,MAAM,KAAO,SACzB,MAAM,MAAM,GACZ,OAAO,MAAM,MAAM,GAAG,KAAO,SAC5B,MAAM,MAAM,GAAG,GACf,OACF,OAEL,IAAK,QAAU,UAAU,OAAS,MAAM,OAAO,OAAQ,CACtD,IAAM,OAAS,UAAU,KAAK,OAC9B,GACC,QACA,OAAO,OACP,OAAO,SAAU,SACjB,OAAO,OAAO,SAAW,GACzB,OAAO,OAAO,KAAK,CAAC,IAAkB,EAAE,SAAU,YAAY,EAE9D,OAAS,WAGX,GAAI,QAAU,eAAe,SAAS,MAAM,EAAG,CAC9C,IAAM,SAAW,OAAO,QAAS,CAChC,MAAO,MAAM,OAAO,MACrB,CAAC,EAEK,iBAAmB,UAAU,MAAM,WAEzC,OAAQ,YACF,WACA,mBACJ,WAAa,QAAQ,OAAO,KAAK,cAAc,EAC/C,UAEI,WACA,aACJ,WAAa,QAAQ,OAAO,KAAK,cAAc,EAE/C,UAEI,iBACA,oCACJ,WAAa,QAAQ,OAAO,WAAW,cAAc,EAErD,UAEI,kBACA,2BACJ,WAAa,QAAQ,OAAO,YAAY,cAAc,EAEtD,UAEI,eACA,sBACJ,WAAa,QAAQ,OAAO,SAAS,cAAc,EACnD,cAGA,GAAK,OAAO,KAAiB,IAAI,WAChC,WAAa,WACV,8CACA,0DAEH,WACC;AAAA;AAAA;AAAA;AAAA,qBAKsB;AAAA;AAAA;AAAA;AAAA;AAAA,EAOxB,MAGF,SAAS,QAAQ,EACX,QAAI,iBAAkB,CAC5B,WAAa;AAAA,EAEb,IAAM,YAAc,MAAM,OAAO,OAAS,MAAQ,QAClD,WAAa,WACV,GAAG;AAAA,EACH,GAAG;AAAA,EAEN,IAAI,iBAAmB,GACvB,GAAI,MAAM,OAAO,OAChB,WACC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMG,KACJ,iBAAmB,GACnB,IAAM,iBAAmB,UAAU,MAAM,WAEzC,WACC;AAAA,WAGA,QAAQ,OAAO,KAAK,cAAc,EAClC;AAAA,WAGA,QAAQ,OAAO,WAAW,cAAc,EACxC;AAAA,WAGA,QAAQ,OAAO,YAAY,cAAc,EACzC;AAAA,WAGA,QAAQ,OAAO,SAAS,cAAc,EACtC;AAAA,8CAIA,QAAQ,OAAO,KAAK,cAAc,EAClC;AAAA,GAKF,IAAM,SAAW,OAAO,QAAS,CAChC,MAAO,MAAM,OAAO,MACrB,CAAC,EAED,GAAI,MAAM,MACT,QAAS,EAAI,EAAG,EAAI,MAAM,MAAM,OAAQ,IAAK,CAC5C,IAAM,KAAO,KAAK,IAClB,GAAI,IAAM,EAAG,WAAa;AAAA,YAE1B,GAAI,OAAO,MAAM,MAAM,GAAG,KAAO,SAAU,CAC1C,IAAM,QAAU,SAAS,aACxB,MAAM,MAAM,GAAG,EAChB,EAEM,iBAAmB,UAAU,MAAM,WAEzC,OAAQ,MAAM,MAAM,GAAG,QACjB,WACA,mBACJ,iBAAmB,GACnB,WAAa,QAAQ,OAAO,KAAK,cAAc,EAE/C,UAEI,WACA,aACJ,iBAAmB,GACnB,WAAa,QAAQ,OAAO,KAAK,cAAc,EAE/C,UAEI,iBACA,oCACJ,iBAAmB,GACnB,WACC,QAAQ,OAAO,WAAW,cAAc,EAEzC,UAEI,kBACA,2BACJ,iBAAmB,GACnB,WACC,QAAQ,OAAO,YAAY,cAAc,EAE1C,UAEI,eACA,sBACJ,iBAAmB,GACnB,WACC,QAAQ,OAAO,SAAS,cAAc,EAEvC,cAGA,WACC,OAAO,gBAAgB,MAAM,MAAM,GAAG;AAAA,KAChC,2BAA2B,cAAc;AAAA,KACzC,4BAA4B;AAAA,EAGrC,QAAQ,EACF,KACN,IAAM,QAAU,SAAS,aACxB,MAAM,MAAM,GAAG,GAAG,IACnB,EAEA,WACC,OAAO,gBAAgB;AAAA,EACpB,QAAQ;AAAA,KACL,2BAA2B,cAAc;AAAA,KACzC,4BAA4B,kBAEnC,QAAQ,EAGT,GAAI,IAAM,EAAG,WAAa,IAE1B,GAAI,iBAAkB,MAKxB,GAFA,SAAS,QAAQ,GAEZ,iBAAkB,CACtB,IAAM,iBAAmB,UAAU,MAAM,WAEzC,GAAI,MAAM,OAAO,OAChB,WACC;AAAA;AAAA;AAAA,EAGF,WAAa,uBAEb,WACC;AAAA,EACA,QAAQ,OAAO,KAAK,cAAc,EAClC;AAAA,oBAEA,QAAQ,OAAO,KAAK,cAAc,EAClC;AAAA,2CAGA,QAAQ,OAAO,WAAW,cAAc,EACxC;AAAA,kCAGA,QAAQ,OAAO,YAAY,cAAc,EACzC;AAAA,6BAGA,QAAQ,OAAO,SAAS,cAAc,EACtC;AAAA,EAGD,QAAW,OAAO,OAAO,KAAK,IAAI,UAAU,EAC3C,WACC,SAAS,cACA,eAAe;AAAA,OAChB,4BAA4B,eAAe;AAAA,OAC3C;AAAA,OACA,4BAA4B;AAAA;AAAA,EAItC,GAAI,MAAM,OAAO,OAAQ,WAAa,IAEtC,WAAa,IAGd,GAAI,MAAM,OAAO,OAAQ,WAAa;AAAA,sBAGvC,WAAa,6CAKd,GAFA,cAAc,QAAQ,EAElB,OAAO,UAAW,CACrB,IAAM,SAAW,OAAO,YAAa,CACpC,MAAO,MAAM,UAAU,MACxB,CAAC,EAED,GAAI,MAAM,UAAU,OAAQ,WAAa;AAAA,EAEzC,QAAS,EAAI,EAAG,EAAI,MAAM,UAAU,OAAQ,IAAK,CAChD,IAAM,UAAY,MAAM,UAAU,GAE5B,QAAU,SAAS,aAAa,UAAU,GAAG,IAAI,EAMvD,GAJA,WAAa,QAAQ,SAAS,EAC3B,iCAAiC;AAAA,EACjC,2BAA2B;AAAA,EAE1B,UAAU,UAAY,YACzB,WACC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAaD,gBACC;AAAA;AAAA,EAGF,QAAQ,EAGT,SAAS,QAAQ,EAGlB,IAAM,WAAqC,CAAC,EAE5C,GAAI,UAAW,CACd,GAAI,UAAU,QAAS,CACtB,GAAI,UAAU,QAAQ,WACrB,QAAY,IAAK,SAAU,OAAO,QACjC,OAAM,QAEL,UAAU,QAAQ,OAClB,CAAC,CACF,CACD,EAAG,CACF,IAAM,OACL,OAAO,QAAU,SACd,KAAK,UAAU,KAAK,EACpB,OAAO,QAAU,SAChB,IAAI,SACJ,MAEL,GAAI,SAAW,OACd,WAAa,cAAc,WAAW;AAAA,EAUzC,GAPA,WAAa,eAAe,CAC3B,KAAM,YACN,OAAQ,UAAU,QAClB,KAAM,UACN,SACD,CAAC,EAEG,UAAU,QAAQ,WACrB,WAAa,6BAEd,GAAI,UAAU,MAAM,QAAQ,aAAe,GAC1C,WACC,oDACA,WAAW,SAAS,SAAS,EAC7B,IAEF,GAAI,UAAU,QAAQ,aACrB,WAAa;AAAA,EAEd,GAAI,UAAU,QAAQ,WAAY,WAAa,IAGhD,GAAI,UAAU,OAAQ,CACrB,GAAI,UAAU,OAAO,WACpB,QAAY,IAAK,SAAU,OAAO,QACjC,OAAM,QAEL,UAAU,OAAO,OACjB,CAAC,CACF,CACD,EAAG,CACF,IAAM,OACL,OAAO,QAAU,SACd,KAAK,UAAU,KAAK,EACpB,OAAO,QAAU,SAChB,IAAI,SACJ,MAEL,GAAI,SAAW,OACd,WAAa,aAAa,WAAW;AAAA,EAGxC,GAAI,UAAU,QAAQ,QAAQ,aAAe,GAC5C,WACC,gDACA,WAAW,SAAS,QAAQ,EAC5B,IAEF,GAAI,UAAU,OAAO,aACpB,WAAa;AAAA,EAGf,GAAI,UAAU,MAAO,CACpB,GAAI,UAAU,MAAM,WACnB,QAAY,IAAK,SAAU,OAAO,QACjC,OAAM,QAEL,UAAU,MAAM,OAChB,CAAC,CACF,CACD,EAAG,CACF,IAAM,OACL,OAAO,QAAU,SACd,KAAK,UAAU,KAAK,EACpB,OAAO,QAAU,SAChB,IAAI,SACJ,MAEL,GAAI,SAAW,OACd,WAAa,eAAe,8BAA8B,SAAS;AAAA,EAEpE,WAAa,eAAe,CAC3B,KAAM,UACN,OAAQ,UAAU,MAClB,KAAM,QACN,SACD,CAAC,EAGH,GAAI,UAAU,MAAM,WACnB,WAAa,2BAEd,GAAI,UAAU,OAAO,QAAQ,aAAe,GAC3C,WACC,8CACA,WAAW,SAAS,OAAO,EAC3B,IAEF,GAAI,UAAU,MAAM,aACnB,WAAa;AAAA,EAEd,GAAI,UAAU,MAAM,WAAY,WAAa,IAG9C,GAAI,SAAW,UAAU,KAAM,CAC9B,GAAI,UAAU,KAAK,cAAgB,UAAU,KAAK,WACjD,WAAa;AAAA,EAEd,IAAM,SAAW,QAAQ,UAAU,KAAK,MAAM,EAC1C,2BAA6B,GAEjC,GAAI,UAAU,KAAK,WAAY,CAC9B,IAAI,MAAQ,OAAM,QACjB,UAAU,KAAK,OACf,UAAU,KAAK,OAAO,OAAS,UAC7B,UAAU,KAAK,OAAO,SAAU,UAChC,UAAU,KAAK,OAAO,MACrB,UAAU,KAAK,OAAO,MACrB,SAAU,SACX,CAAC,EACD,MACJ,EAEA,IACE,UACD,OACA,OAAO,QAAU,WAChB,QAAQ,OAAQ,UAAU,KAAK,MAAM,GACrC,QAAQ,QAAS,UAAU,KAAK,MAAM,GACtC,CACD,2BAA6B,GAE7B,QAAY,GAAG,KAAM,OAAO,QAAQ,KAAK,EACxC,GAAI,IAAM,QAAU,IAAM,QAEzB,OAAO,MAAM,IAEf,IAAK,WAAW,KAAK,EAAG,MAAQ,OAGjC,IAAM,OACL,OAAO,QAAU,SACd,KAAK,UAAU,KAAK,EACpB,OAAO,QAAU,SAChB,IAAI,SACJ,MAEL,GAAI,QAAU,QAAa,QAAU,KACpC,GAAI,MAAM,QAAQ,KAAK,EACtB,WAAa,qBAAqB;AAAA,EAC9B,QAAI,OAAO,QAAU,SACzB,WAAa,wBAAwB;AAAA,EACjC,gBAAa,UAAU;AAAA,EAU7B,GAPA,WAAa,eAAe,CAC3B,KAAM,SACN,OAAQ,UAAU,KAClB,KAAM,OACN,SACD,CAAC,EAEG,UAAU,MAAM,QAAQ,aAAe,GAC1C,GAAI,UAAU,KAAK,WAClB,WACC,8DACA,WAAW,SAAS,MAAM,EAC1B,IAED,gBACC,4CACA,WAAW,SAAS,MAAM,EAC1B,IAUH,QAPA,WAAa,eAAe,CAC3B,KAAM,SACN,OAAQ,UAAU,KAClB,KAAM,OACN,SACD,CAAC,EAEG,UAAU,MAAM,QAAQ,aAAe,GAC1C,GAAI,UAAU,KAAK,WAClB,WACC,8DACA,WAAW,SAAS,MAAM,EAC1B,IAED,gBACC,4CACA,WAAW,SAAS,MAAM,EAC1B,IAIJ,GAAI,UAAU,KAAK,aAClB,WAAa;AAAA,EAEd,GAAI,UAAY,UAAU,KAAK,OAAO,OAAO,OAAQ,CACpD,IAAM,SAAW,OAAO,OACvB,UAAU,KAAK,OAAO,KACvB,EAEA,QAAS,EAAI,EAAG,EAAI,SAAS,OAAQ,IAAK,CACzC,IAAM,KAAO,SAAS,GAEtB,GAAI,QAAQ,OAAQ,IAAI,GAAK,QAAQ,QAAS,IAAI,EAAG,CACpD,IAAM,UAAY,mBAAmB,KAAM,CAE1C,QAAS,IAAI,YAAY,QACzB,SAAU,IAAI,OAAO,IAErB,OAAQ,IAAI,YAAY,KACxB,UAAW,IAAI,OAAO,UACtB,iBAAkB,oBAAoB,EACtC,SAAU,IAAM,IAAI,OAAO,QAC5B,CAAC,EAED,GAAI,UAAW,CACd,IAAM,QAAU,WAAW,SAAW,EAEhC,UAAW,OAAO,QACvB,KAAK,UACN,EAEI,WAAY,QAAU;AAAA,EAAO,SACjC,YAAa,iBAAiB,WAAW,0BAEzC,IAAI,cAAe,GACf,gBAAkB,EACtB,QAAS,GAAI,EAAG,GAAI,UAAS,OAAQ,KAAK,CACzC,IAAO,GAAG,GAAK,UAAS,IAExB,IACE,EAAE,WACF,EAAE,SAAU,QAAU,EAAE,SAAU,QAEnC,SAED,GAAI,gBAAiB,eAAgB,IACrC,eAAgB,gCAAgC,MAAK,KAAK,UAAU,EAAE,SAAS,WAAW,OAE1F,kBAGD,GAAI,cAAc,CACjB,GAAI,kBAAoB,EACvB,YAAa,SAAS;AAAA,EAClB,QAAI,gBAAkB,EAC1B,YAAa,sBAAsB;AAAA,EAEpC,YAAa,IAEb,WAAa,WACb,WAAW,KAAK,SAAS,MAKvB,QACN,6BACE,WACA,QAAQ,OAAQ,UAAU,KAAK,MAAM,GACrC,QAAQ,QAAS,UAAU,KAAK,MAAM,GACvC,CACD,IAAI,cAAe,GAEf,EAAI,EACR,QAAY,GAAG,KAAM,OAAO,QAC3B,UAAU,KAAK,OAAO,UACvB,EAA0B,CACzB,IACE,EAAE,WACF,EAAE,SAAU,QAAU,EAAE,SAAU,QAEnC,SAED,GAAI,EAAG,eAAgB,IACvB,eAAgB,gCAAgC,MAAK,KAAK,UAAU,EAAE,SAAS,WAAW,OAE1F,IAGD,GAAI,EAAG,WAAa;AAAA,EAEpB,GAAI,IAAM,EAAG,WAAa,SAAS;AAAA,EAC9B,QAAI,EAAI,EACZ,WAAa,sBAAsB;AAAA,GAItC,GAAI,UAAU,OAAQ,CAErB,IAAM,gBAAkB,mBAAmB,CAE1C,QAAS,IAAI,YAAY,QACzB,UAAW,UAAU,OACrB,cAAe,IAAI,OAAO,OAC1B,UAAW,IAAI,OAAO,IACtB,OAAQ,UAAU,QAAQ,QAAU,CAAC,EAErC,OAAQ,IAAI,YAAY,IACzB,CAAC,EAOD,GALA,WACC;AAAA;AAAA,EAIG,gBAAgB,WACnB,QAAY,IAAK,SAAU,OAAO,QACjC,OAAM,QAAQ,gBAAgB,OAAQ,CAAC,CAAC,CACzC,EACC,WAAa,gBAAgB,WAC5B,OAAO,QAAU,SACd,KAAK,UAAU,KAAK,EACpB;AAAA,EAIN,GAAI,gBAAgB,WACnB,WAAa,4BAEd,GAAI,UAAU,MAAM,QAAQ,aAAe,GAC1C,WACC,mDACA,WAAW,SAAS,SAAU,aAAa,EAC3C,IAGF,GAAI,gBAAgB,aACnB,WACC;AAAA,EAGF,GAAI,gBAAgB,WAAY,WAAa,KAI/C,GAAI,OAAO,aAAc,CACxB,IAAM,SAAW,OAAO,eAAgB,CACvC,MAAO,MAAM,aAAa,MAC3B,CAAC,EAEG,WAAa,GAEjB,QAAS,EAAI,EAAG,EAAI,MAAM,aAAa,OAAQ,IAAK,CACnD,IAAM,aAAe,MAAM,aAAa,GAElC,QAAU,SAAS,aAAa,aAAa,GAAG,IAAI,EAEpD,UAAY,UAAU,YAAY,EAKxC,GAHC,aAAa,UAAY,WACzB,aAAa,UAAY,aAEV,CACf,IAAK,WACJ,WAAa,GACb,WAAa;AAAA;AAAA,EAOd,GAJA,WAAa,QAAQ,YAAY,EAC9B,iCAAiC;AAAA,EACjC,2BAA2B;AAAA,EAE1B,aAAa,UAAY,aAC5B,WACC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAcD,gBACC;AAAA;AAAA,EAEI,SAAK,UACX,WAAa,QAAQ,YAAY,EAC9B,wBAAwB;AAAA,EACxB,kBAAkB;AAAA,EAErB,QAAQ,EACF,KAUN,GATA,WAAa,QAAQ,YAAY,EAC9B,2BAA2B;AAAA,EAC3B,qBAAqB;AAAA,EAExB,QAAQ,IAAI,EAEZ,WAAa,sBACb,SAAS,QAAQ,EAEb,MAAM,aAAa,OAAQ,CAC9B,OAAO,SAAU,CAChB,KAAM,WACF,QAAqB,KACtB,MACJ,CAAC,EAAE,QAAQ,EAEX,IAAM,UAAW,OAAO,cAAe,CACtC,MAAO,MAAM,YAAY,MAC1B,CAAC,EAED,QAAS,GAAI,EAAG,GAAI,MAAM,YAAY,OAAQ,KAAK,CAClD,IAAM,KAAO,MAAM,YAAY,IACzB,WAAY,UAAU,IAAI,EAC1B,SAAU,UAAS,aAAa,KAAK,GAAG,IAAI,EAIlD,GAFA,WAAa;AAAA,GAER,WACJ,WAAa,QAAQ,KAAK,EAAE,EACzB,uBAAuB;AAAA,EACvB,iBAAiB;AAAA,EAEpB,gBAAa,QAAQ,KAAK,EAAE,EACzB,0BAA0B;AAAA,EAC1B,oBAAoB;AAAA,EAEvB,WAAa;AAAA,EAGd,SAAQ,IAAI,EAEb,UAAS,QAAQ,EAGlB,GAAI,UAAU,SAAU,WAAa,WAAW,SAAS,IAAI,EAE7D,IAAM,oBAAsB,OAAO,cAAe,CACjD,MAAO,MAAM,aAAa,MAC3B,CAAC,EAED,GAAI,MAAM,aAAa,OAAQ,CAC9B,WAAa;AAAA,EAEb,QAAS,GAAI,EAAG,GAAI,MAAM,YAAY,OAAQ,KAAK,CAClD,IAAM,aAAc,MAAM,YAAY,IAEhC,SAAU,oBAAoB,aACnC,aAAY,GAAG,IAChB,EAEA,WACC,yBACM,YAAY,YAAW,EAAI,SAAW,mBAAmB;AAAA,qCAIhE,SAAQ,GAIV,oBAAoB,QAAQ,EAE5B,WAAa,aAAa,EAC1B,WAAa,2BAA2B,uBACvC;AAAA,GAKH,SAAS,QAAQ,EAGlB,GAAI,MAAM,aAAa,OAAQ,CAC9B,IAAM,eAAiB,OAAO,SAAU,CACvC,KAAM,WAAc,QAAqB,KAAO,MACjD,CAAC,EAED,GAAI,MAAM,YAAY,OACrB,WAAa,eACV,0BAA0B;AAAA,EAC1B,oBAAoB;AAAA,EAEvB,gBAAa,eACV,eAAe;AAAA,EACf,SAAS;AAAA,EAEb,eAAe,QAAQ,EAEvB,IAAM,SAAW,OAAO,cAAe,CACtC,MAAO,MAAM,YAAY,MAC1B,CAAC,EAED,QAAS,EAAI,EAAG,EAAI,MAAM,YAAY,OAAQ,IAAK,CAClD,IAAM,KAAO,MAAM,YAAY,GACzB,UAAY,UAAU,IAAI,EAC1B,QAAU,SAAS,aAAa,KAAK,GAAG,IAAI,EAElD,IAAK,UACJ,WAAa,QAAQ,KAAK,EAAE,EACzB,uBAAuB;AAAA,EACvB,iBAAiB;AAAA,EAEpB,QAAQ,EAQR,QANA,WAAa,QAAQ,KAAK,EAAE,EACzB,0BAA0B;AAAA,EAC1B,oBAAoB;AAAA,EAEvB,QAAQ,IAAI,EAER,UAAU,SACb,WAAa,sBACb,SAAS,QAAQ,EAEjB,WAAa,WAAW,SAAS,IAAI,EAErC,WAAa,iBAEb,gBAAa,sBACb,SAAS,QAAQ,EAEjB,WAAa,iBAShB,GAJA,SAAS,QAAQ,EAEjB,WAAa;AAAA,EAET,UAAU,SAAU,WAAa,WAAW,SAAS,EAEzD,WAAa,aAAa,EAE1B,IAAM,oBAAsB,OAAO,cAAe,CACjD,MAAO,MAAM,aAAa,MAC3B,CAAC,EACD,GAAI,MAAM,aAAa,OACtB,QAAS,EAAI,EAAG,EAAI,MAAM,YAAY,OAAQ,IAAK,CAClD,IAAM,aAAc,MAAM,YAAY,GAEhC,QAAU,oBAAoB,aACnC,aAAY,GAAG,IAChB,EAEA,WACC,MACC,YAAY,YAAW,EAAI,SAAW,mBACtB;AAAA;AAAA,EAGlB,QAAQ,EAGV,oBAAoB,QAAQ,EAE5B,WAAa,aAAY,EACnB,KACN,IAAM,eAAiB,OAAO,SAAU,CACvC,KAAM,WAAc,QAAqB,KAAO,MACjD,CAAC,EAED,GAAI,UAAU,UAAY,MAAM,aAAa,OAAQ,CAOpD,GANA,WAAa,eACV,eAAe;AAAA,EACf,SAAS;AAAA,EAEZ,eAAe,QAAQ,EAEnB,UAAU,SAAU,WAAa,WAAW,SAAS,EAEzD,OAAO,aAAa,EAAE,QAAQ,EAE9B,IAAM,oBAAsB,OAAO,cAAe,CACjD,MAAO,MAAM,aAAa,MAC3B,CAAC,EAED,GAAI,MAAM,aAAa,OAAQ,CAC9B,WAAa;AAAA;AAAA,EAEb,QAAS,EAAI,EAAG,EAAI,MAAM,YAAY,OAAQ,IAAK,CAClD,IAAM,aAAc,MAAM,YAAY,GAEhC,QAAU,oBAAoB,aACnC,aAAY,GAAG,IAChB,EAEA,WACC;AAAA,wBACM,YAAY,YAAW,EAAI,SAAW,mBAAmB;AAAA;AAAA,EAIhE,QAAQ,GAOV,GAJA,oBAAoB,QAAQ,EAE5B,WAAa,aAAa,EAEtB,mBAAmB,SACtB,WAAa,UAAU,IACpB,qGAIkC,eAAe,uBACjD,kCAEc,iBACd,UAAU,iBAEb,WAAa;AAAA,EACP,gBAAa,aAAY,EAC1B,QAAI,WAAa,SAAU,CACjC,WAAa,eACV,eAAe;AAAA,EACf,SAAS;AAAA,EAEZ,eAAe,QAAQ,EAEvB,OAAO,aAAa,EAAE,QAAQ,EAE9B,IAAM,oBAAsB,OAAO,cAAe,CACjD,MAAO,MAAM,aAAa,MAC3B,CAAC,EACD,GAAI,MAAM,aAAa,OAAQ,CAC9B,WAAa;AAAA,EAEb,QAAS,EAAI,EAAG,EAAI,MAAM,YAAY,OAAQ,IAAK,CAClD,IAAM,aAAc,MAAM,YAAY,GAEhC,QAAU,oBAAoB,aACnC,aAAY,GAAG,IAChB,EAEA,WACC,yBACM,YAAY,YAAW,EAAI,SAAW,mBAAmB;AAAA,oCAIhE,QAAQ,GAGV,oBAAoB,QAAQ,EAE5B,WAAa,aAAa,EAAI,aAAY,EACpC,KACN,eAAe,QAAQ,EAEvB,IAAM,QAAU,eAAiB,SAAS,SAAW,OAIrD,GAFA,OAAO,aAAa,EAAE,QAAQ,EAE1B,mBAAmB,SACtB,WAAa,UAAU,IACpB,qGAIqB,eAAe,uBACpC;AAAA,cAEc;AAAA,EACd,UAAU;AAAA,EACP,gBAAa,aAAY,OAAO,GAMzC,GAFA,WAAa;AAAA,iBAER,YAAc,MAAM,OAAO,OAAQ,WAAa,oBAKrD,GAJA,WACC;AAAA;AAAA,EAGG,UAAW,WAAa,aAAa,EAEzC,GAAI,UAAY,MAAM,MACrB,QAAS,EAAI,EAAG,EAAI,MAAM,MAAM,OAAQ,IAEvC,WAAa,SAAS,gCAAgC;AAAA,EAExD,IAAM,cAAgB,OAAO,QAAS,CACrC,MAAO,MAAM,OAAO,MACrB,CAAC,EAED,GAAI,MAAM,OAAO,OAAQ,CAGxB,GAFA,WAAa;AAAA,EAET,cACH,WACC;AAAA,wEAKG,gBAAa;AAAA,EAElB,WAAa;AAAA,EAEb,QAAS,EAAI,EAAG,EAAI,MAAM,MAAM,OAAQ,IAAK,CAC5C,IAAM,QAAU,cAAc,aAAa,MAAM,MAAM,GAAG,GAAG,IAAI,EAEjE,GAAI,QAAQ,MAAM,MAAM,EAAE,EACzB,WAAa,oBAAoB;AAAA,EAEjC,gBACC,cAAc;AAAA;AAAA,EAGhB,QAAQ,EAER,IAAM,oBAAsB,OAAO,cAAe,CACjD,MAAO,MAAM,aAAa,MAC3B,CAAC,EAED,GAAI,MAAM,aAAa,OACtB,QAAS,GAAI,EAAG,GAAI,MAAM,YAAY,OAAQ,KAAK,CAClD,IAAM,aAAc,MAAM,YAAY,IAEhC,SAAU,oBAAoB,aACnC,aAAY,GAAG,IAChB,EAEA,WACC;AAAA,mBACoB;AAAA;AAAA,EAGrB,SAAQ,EASV,GALA,oBAAoB,QAAQ,EAE5B,WAAa,6BAA6B;AAAA,EAC1C,WAAa,UAET,UAAY,MAAM,MAAO,CAC5B,QAAS,GAAI,EAAG,GAAI,MAAM,MAAM,OAAQ,KACvC,WAAa,SAAS;AAAA,EAEvB,cAAc,QAAQ,EAGvB,WAAa,cAOf,GAHA,cAAc,QAAQ,EAEtB,WAAa,oCACR,YAAc,MAAM,OAAO,OAAQ,WAAa,OAGrD,GAFA,WAAa,IAET,kBAAoB,SAAU,CAGjC,GAFA,WAAa,aAER,WAAY,WAAa,eAE9B,IAAM,SAAW,OAAO,gBAAiB,CACxC,MAAO,MAAM,eAAe,MAC7B,CAAC,EAED,GAAI,kBAAoB,MAAM,cAC7B,QAAS,EAAI,EAAG,EAAI,MAAM,cAAc,OAAQ,IAAK,CACpD,IAAM,QAAU,SAAS,aACxB,MAAM,cAAc,GAAG,GAAG,IAC3B,EACA,WAAa;AAAA,wBAA2B;AAAA,EACxC,QAAQ,EAMV,GAFA,SAAS,QAAQ,GAEZ,WAAY,WAAa,OAE9B,WAAa,IAGd,IAAM,iBAAmB,QAAQ,OAC9B,OAAO,KAAK,QAAQ,MAAM,EAAE,KAAK,GAAG,EAAI,IACxC,GAEC,KACH,uCAIA,WAAW,aAAc,aAAa,EACtC,qEAKA,WAAW,cAAe,OAAO,EACjC,WAAW,qBAAsB,QAAQ,EACzC,YAEA,WAAW,mBAAoB,aAAa,EAC5C,WAAW,aAAc,OAAO,EAChC,yDAKA,WAAW,eAAgB,SAAS,EACpC,WAAW,cAAe,SAAS,EACnC,WAAW,sBAAuB,QAAQ,EAC1C,8BACA,WAAW,gBAAiB,QAAQ,EACpC,WAAW,qBAAsB,QAAQ,EACzC,WAAW,UAAW,MAAM,OAAO,MAAM,EACzC,WAAW,aAAc,UAAU,MAAM,EACzC,WAAW,cAAe,WAAW,MAAM,EAC3C,iBACA,WAAW,eAAgB,aAAa,EACxC;AAAA;AAAA,SAEU,WAAa,SAAW,wBAEnC,GAAI,MAAM,cAAc,OAAQ,MAAQ;AAAA,EACxC,GAAI,MAAM,aAAa,OAAQ,MAAQ;AAAA,EACvC,GAAI,MAAM,aAAa,OAAQ,MAAQ;AAAA,EACvC,GAAI,UAAW,MAAQ;AAAA;AAAA,EAEvB,UAAY,KAAO,UAAY,IAC/B,KAAO,GAEP,GAAI,CACH,OAAO,SACN,QACA;AAAA,EAAoB,SACrB,EAAE,CACD,QACA,MAAO,cAAc,IAAK,KAAM,CAAC,EACjC,UAAW,cAAgB,UAAY,OAEvC,YAAa,IAAI,YACjB,YAAa,eAAe,YAC5B,mBAAoB,eAAe,mBACnC,iBAAkB,eAAe,iBACjC,WACA,MAAO,CACN,WAAY,QAAU,WAAa,OACnC,kBAAmB,SAAW,kBAAoB,MACnD,EACA,MAAO,CACN,gBAAiB,cAAgB,gBAAkB,OACnD,WAAY,QAAU,WAAa,MACpC,EACA,sBACA,OAAQ,IAAI,OAAO,QAEnB,YAAa,IAAI,YAAY,KAC7B,WACA,YAAa,UAAY,YAAc,OACvC,WAAY,UAAY,WAAa,OACrC,mBAAoB,SAAW,0CAAS,OACxC,2BACA,aAAc,SAAW,aAAe,OACxC,kBAAmB,SAAW,kBAAoB,OAElD,UAAW,IAAM,IAAI,UAAU,EAC/B,WAAY,WAAW,OAAS,WAAa,OAC7C,aAAc,cAAgB,aAAe,OAC7C,OAAQ,IAAI,cACT,QAAQ,MACZ,CAAC,EACA,MAAO,OAAO,CACf,IAAM,WAAa,cAAc,KAAK,EAEtC,QAAQ,IAAI,iDAAiD,EAC7D,QAAQ,IAAI,KAAK,EACjB,QAAQ,IAAI,CACX,QACC,OAAO,UAAY,WAAa,QAAQ,SAAS,EAAI,QACtD,YAAa,UACb,MAAO,IACH,WAEH,UAAW,YAAY,WAAW,MAAM,CAAC,IAAM,EAAE,SAAS,CAAC,EAE3D,QAAS,YAAY,SAAS,MAAM,CAAC,IAAM,EAAE,SAAS,CAAC,EAEvD,aAAc,YAAY,cAAc,MAAM,CAAC,IAC9C,EAAE,SAAS,CACZ,EAEA,YAAa,YAAY,aAAa,MAAM,CAAC,IAC5C,EAAE,SAAS,CACZ,EAEA,YAAa,YAAY,aAAa,MAAM,CAAC,IAC5C,EAAE,SAAS,CACZ,EAEA,MAAO,YAAY,OAAO,MAAM,CAAC,IAAM,EAAE,SAAS,CAAC,EAEnD,MAAO,YAAY,OAAO,MAAM,CAAC,IAAM,EAAE,SAAS,CAAC,EAEnD,cAAe,YAAY,eAAe,MAAM,CAAC,IAChD,EAAE,SAAS,CACZ,EAEA,KAAM,YAAY,MAAM,MAAM,CAAC,IAAM,EAAE,SAAS,CAAC,CAClD,EACA,UAEA,YAAa,IAAI,YAAY,KAC7B,YACD,CAAC,EACD,QAAQ,IAAI,KAAK,EAEjB,QAAQ,KAAK,CAAC,IAiBH,uBAAyB,CACrC,IACA,QACI,CACJ,IAAI,UAAY,GAWV,SATS,aAAa,CAC3B,MAAO,IAAI,MAAM,MACjB,MACC,QACC,CAAC,OAAS,CACV,WAAa,MAEhB,CAAC,EAEuB,UAAW,CAClC,MAAO,IAAI,MAAM,SAAS,MAC3B,CAAC,EAED,GAAI,IAAI,MAAM,SAAS,OAAQ,CAC9B,WAAa,OAEb,QAAS,EAAI,EAAG,EAAI,IAAI,MAAM,QAAQ,OAAQ,IAAK,CAClD,IAAM,KAAO,IAAI,MAAM,QAAQ,GACzB,WAAa,UAAU,IAAI,EAC3B,WAAa,QAAQ,IAAI,EAEzB,QAAU,SAAS,aAAa,IAAI,MAAM,QAAQ,GAAG,GAAG,IAAI,EAElE,GAAI,WACH,WACC,uBACG,WAAa,SAAW,eAAe;AAAA,EAG3C,QAAQ,IAAI,EACZ,WAAa;AAAA,EAEb,gBAAa,GAAG,WAAa,SAAW,eAAe;AAAA,EACvD,QAAQ,EAIV,WAAa,uDAKd,OAFA,SAAS,QAAQ,EAEV,WAGK,UAAY,CAAC,IAAgB,OAAS,QAAU,CAE5D,IAAM,IAAM,IAAI,SAAS,qBAEzB,IAAK,IAAI,OAAQ,MAAO,UAAY,OAEpC,IAAM,QAAU,IAAI,YAAY,sBAE5B,QAAU,OAEd,QAAS,EAAI,EAAG,EAAI,IAAI,OAAQ,IAC/B,QAAU,OAAO,MAAM,WAAW,QAAQ,cAE3C,MAAO,0BAA0B,QAAQ,sBAAsB,WAAW,QAAQ,gBAGtE,sBAAwB,CAAC,MAAmB,CACxD,IAAM,QAAU,IAAI,YAAY,sBAChC,IAAI,OAAO,KAAK,MAAM,EAEtB,IAAM,SAAW,QAAQ,WACtB,IAAI,MAAM,SAAS,SACnB,IAAI,MAAM,OAAO,MACpB,EAEM,SAAW,IAAI,MAAM,OAAO,OAE9B,UAAY,GAEV,OAAS,IAAI,OAEf,iBAAmB,OAAO,KAAK,KAAK,GACrC,wGACA,sCAEH,kBAAoB,OAAO,KAAK,KAAK,IAAM;AAAA,EAA6B;AAAA,EAExE,kBAAoB,SAAS,KAE7B,kBACC;AAAA;AAAA;AAAA;AAAA,EAID,IAAI,UAAY,GAChB,QAAY,KAAM,WAAY,OAAO,QAAQ,OAAO,MAAM,EAAG,CAG5D,GAFA,WAAa,QAAQ,SAEjB,IAAI,OAAO,aAAe,GAC7B,WAAa,QAAQ,aAAa,IAAI,MAEvC,IAAM,QAAU,WAAW,IAAI,EAC/B,GAAI,OAAS,QAAS,WAAa,QAAQ,YAI3C,GAFA,WAAa,oBAET,QAAS,SAAW,OAAQ,QAAS,CAGxC,GAFA,WAAa,cAET,OAAQ,QACX,WACC,uDACa,QAAQ;AAAA,EAEvB,GAAI,QAAS,QACZ,WAAa,aAAa,QAAQ;AAAA,EAGpC,QAAY,OAAQ,SAAU,OAAO,QAAQ,OAAO,EAAG,CACtD,GAAI,SAAW,OAAS,SAAW,OAAS,SAAW,KACtD,SAED,WAAa,SAAS,qBAAqB;AAAA,EAG5C,GAAI,QAAS,QACZ,WAAa,qBAAqB,QAAQ;AAAA,EACtC,gBAAa;AAAA,EAElB,WAAa,IAGd,IAAM,aAAe,IAAI,MAAM,SAAS,KAAK,OAAO,EAE9C,iBAAmB,QAAQ,OAC9B,OAAO,KAAK,QAAQ,MAAM,EAAE,KAAK,GAAG,EAAI,IACxC,GAwBH,GAtBA,WACC;AAAA,iFAQA,WAAW,gBAAiB,QAAQ,EACpC,WAAW,qBAAsB,QAAQ,EACzC,iBACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUG,IAAI,MAAM,SAAS,OACtB,WAAa;AAAA,EAId,GAFA,WAAa,SAAS,QAElB,IAAI,MAAM,OAAO,OACpB,WACC,SACA,IAAI,MAAM,MACR,IAAI,CAAC,GAAG,IAAM,KAAK,qBAAqB,OAAO,EAC/C,KAAK,GAAG,EACV;AAAA,EAIF,GAFA,WAAa,GAAG,WAAa,SAAW,kBAAkB,QAAQ,eAE9D,IAAI,MAAM,SAAS,OAAQ,WAAa;AAAA,EAI5C,GAFA,WAAa,QAAQ,cAAc,GAAG,EAElC,IAAI,MAAM,OAAO,OACpB,WACC,oBACA,IAAI,MAAM,MAAM,IAAI,CAAC,GAAG,IAAM,KAAK,MAAM,EAAE,KAAK,GAAG,EACnD;AAAA,EAIF,GAFA,WAAa,uBAAuB,GAAG,EAEnC,UAAW,WAAa;AAAA;AAAA,EAAwB,UAAY,IAEhE,WAAa,iBAAmB;AAAA,EAAQ,UAAU,GAAG,EAGrD,IAAI,YAAc,oBAAoB,GAAG,EAEzC,IAAM,GAAK,SACV,OACA;AAAA,EAAoB,SACrB,EAAE,CACD,IACA,iBAAkB,IAAI,YAAY,QAAW,iBAC7C,cACA,SAEA,YAAa,IAAI,YACjB,OACA,SACA,aAAc,SAAW,aAAe,OACxC,kBAAmB,SAAW,kBAAoB,UAC/C,QAAQ,MACZ,CAAC,EAED,GAAI,MAAO,IAAI,GAAG,EAAK,EAEvB,OAAO,IAGK,oBAAsB,CAAC,MAAmB,CACtD,IAAM,MAAQ,IAAI,MACd,UAAY,GAEV,QAAU,IAAI,YAAY,aAC1B,iBAAmB,QAAQ,OAC9B,OAAO,KAAK,QAAQ,MAAM,EAAE,KAAK,GAAG,EAAI,IACxC,GAEG,WAAa,IAAI,MAAM,OAAO,OAwBpC,GAtBA,WACC,4DAIA,WAAW,WAAY,IAAI,MAAM,KAAK,EACtC,WAAW,iBAAkB,IAAI,MAAM,aAAa,EACpD,WAAW,SAAU,IAAI,MAAM,KAAK,EACpC,WAAW,iBAAkB,IAAI,MAAM,WAAW,EAClD,WAAW,gBAAiB,QAAQ,EACpC,WAAW,qBAAsB,QAAQ,EACzC,iBACA;AAAA,EAED,WAAa,UACZ,IAAI,MAAM,OAAO,KAAK,OAAO,GAAK,IAAI,MAAM,aAAa,KAAK,OAAO,EAClE,SACA,wCAGJ,WAAa,GAET,SAAU,WAAa;AAAA,EAE3B,IAAM,OAAS,aAAa,CAC3B,QAAS,UACT,MAAO,MAAM,MACb,MAAO,CAAC,OAAS,CAChB,WAAa,KAEf,CAAC,EAYD,GAVA,WACC;AAAA;AAAA;AAAA;AAAA;AAAA,+BASG,QAAQ,QAAS,WAAa,QAAQ,QAE1C,IAAM,aACL,YACE,MAAM,eAAe,UACrB,MAAM,eAAe,OACpB,sBACA,GAEJ,GAAI,IAAI,MAAM,MACb,QAAS,EAAI,EAAG,EAAI,IAAI,MAAM,MAAM,OAAQ,IAAK,CAChD,IAAM,QAAU,IAAI,MAAM,MAAM,GAE1B,SAAW,GAChB,QAAQ,OAAO,EAAI,SAAW,aACpB;AAAA,EAIX,GAFA,WAAa,yBAET,UAAU,OAAO,EAAG,CACvB,WACC,MAAM;AAAA,wEACgD,QAAQ;AAAA;AAAA;AAAA,EAO/D,IAAM,qBAAsB,OAAO,cAAe,CACjD,MAAO,MAAM,aAAa,OAC1B,KAAM,SACP,CAAC,EAED,GAAI,MAAM,aAAa,OACtB,QAAS,GAAI,EAAG,GAAI,MAAM,YAAY,OAAQ,KAAK,CAClD,IAAM,aAAc,MAAM,YAAY,IAEhC,QAAU,qBAAoB,aACnC,aAAY,GAAG,IAChB,EAEA,WACC,yBACM,YAAY,YAAW,EAAI,SAAW,mBAAmB;AAAA,EAEhE,QAAQ,EAIV,qBAAoB,QAAQ,EAE5B,WAAa,sBAAsB,qBAAqB,QAAQ,uBAC1D,gBAAa,SAEpB,WAAa,IAGf,WACC;AAAA;AAAA;AAAA,EAGA,QAAQ,gBACR;AAAA;AAAA,EAED,WACC;AAAA;AAAA,EAEA,QAAQ,aACR;AAAA,GAED,IAAM,oBAAsB,OAAO,cAAe,CACjD,MAAO,MAAM,aAAa,OAC1B,KAAM,SACP,CAAC,EAKD,GAHA,WACC;AAAA;AAAA,EAEG,MAAM,aAAa,OAAQ,CAC9B,WAAa;AAAA,EAEb,QAAS,EAAI,EAAG,EAAI,MAAM,YAAY,OAAQ,IAAK,CAClD,IAAM,aAAc,MAAM,YAAY,GAEhC,QAAU,oBAAoB,aACnC,aAAY,GAAG,IAChB,EAEA,WACC,yBACM,YAAY,YAAW,EAAI,SAAW,mBAAmB;AAAA,8CAIhE,QAAQ,GAIV,oBAAoB,QAAQ,EAE5B,WAAa;AAAA,qBAAwB,wBAAwB,QAAQ,uBAErE,IAAM,MAAQ,CAAC,IACd,OAAO,IAAM,WAAa,EAAI,EAAE,GAEjC,OAAO,SACN,SACA;AAAA,EAAoB,SACrB,EAAE,CACD,YAAa,IAAI,YAAY,QAAQ,YACrC,WACA,2BACA,QAAS,IAAI,MAAM,OAAO,IAAI,KAAK,EACnC,cAAe,IAAI,MAAM,eAAe,IAAI,KAAK,EACjD,MAAO,IAAI,MAAM,OAAO,IAAI,KAAK,EACjC,cAAe,IAAI,MAAM,aAAa,IAAI,KAAK,EAC/C,aAAc,SAAW,aAAe,OACxC,kBAAmB,SAAW,kBAAoB,UAC/C,QAAQ,MACZ,CAAC,GK/7EK,IAAM,aAAc,CAC1B,SACA,KACA,UACc,CACd,GAAI,WAAW,KAAI,OAAO,GAAK,KAAI,SAAW,KAAO,KAAI,OAGxD,OAFA,UAAU,IAAG,EAEL,UAAU,aAAa,UACzB,SACJ,OAAO,IAAI,SAAS,SAAoB,IAAU,MAE9C,YACA,SAEJ,OADA,KAAI,QAAQ,gBAAkB,mBACvB,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,IAAU,MAEpD,aACJ,OAAO,WAAY,SAAwB,KAAa,MAEpD,OACJ,OAAO,WAAW,SAAkB,IAAU,MAE1C,OACJ,OAAO,WAAW,SAAkB,IAAU,MAE1C,6BAGJ,OAFA,KAAI,OAAU,SAA6C,KAEpD,aACL,SAA6C,SAC9C,KACA,OACD,MAEI,iBACJ,IACE,KAAI,QAAQ,iBAAiB,WAC7B,mBACD,EAEA,KAAI,QAAQ,gBACX,mCAeF,OAbA,SAAS,QAAQ,iBAChB,QACA,CACC,WAAW,EAAG,CACb,GAAI,SAAS,SAAW,SAAS,QAAQ,QACvC,SAA4B,OAAO,EAEvC,EACA,CACC,KAAM,EACP,CACD,EAEO,IAAI,SAAS,SAA4B,IAAU,MAEtD,QACJ,IAAK,SAAU,OAAO,IAAI,SAAS,GAAI,IAAU,EAEjD,OAAO,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,IAAU,MAEpD,WACJ,OAAO,gBAAe,SAAsB,KAAK,OAAO,MAEpD,QACJ,OAAO,iBAAgB,SAAmB,IAAG,MAEzC,UACJ,OAAQ,SAA0B,KAAK,CAAC,IACvC,aAAY,EAAG,KAAK,OAAO,CAC5B,MAEI,WACJ,OAAO,aAAa,SAAsB,EAAG,KAAK,OAAO,MAErD,aACA,UACJ,OAAO,IAAI,SACT,SAA8B,SAAS,EACxC,IACD,MAEI,SACJ,GAAI,oBAAoB,OACvB,OAAO,IAAI,SAAS,SAAS,MAAO,IAAU,EAE/C,OAAO,IAAI,SAAS,UAAU,SAAS,EAAG,IAAU,MAEhD,WACJ,OAAO,IAAI,SAAS,SAAsB,IAAU,UAIpD,GAAI,oBAAoB,SACvB,OAAO,gBAAe,SAAsB,KAAK,OAAO,EAEzD,GAAI,oBAAoB,QACvB,OAAO,SAAS,KAAK,CAAC,IAAM,aAAY,EAAG,IAAG,CAAC,EAEhD,GAAI,oBAAoB,MACvB,OAAO,iBAAgB,SAAmB,IAAG,EAE9C,GAAI,oBAAoB,2BAKvB,OAJA,KAAI,OACH,SACC,KAEK,aACL,SAA6C,SAC9C,KACA,OACD,EAID,GAAI,OAAO,UAAU,OAAS,WAC7B,OAAO,cAAa,SAAiB,KAAK,OAAO,EAGlD,GAAI,OAAO,UAAU,OAAS,WAE7B,OAAO,SAAS,KAAK,CAAC,IAAM,aAAY,EAAG,IAAG,CAAC,EAGhD,GAAI,OAAO,UAAU,aAAe,WACnC,OAAO,aAAa,SAAiB,WAAW,EAAG,IAAG,EAEvD,GAAI,eAAiB,SAAkB,CACtC,IAAM,KAAQ,SAAiB,WAAW,CAAC,EAE3C,GAAI,OAAS,KAAO,OAAS,GAAI,CAChC,IAAK,KAAI,QAAQ,gBAChB,KAAI,QAAQ,gBAAkB,mBAE/B,OAAO,IAAI,SACV,KAAK,UAAU,QAAQ,EACvB,IACD,GAIF,OAAO,IAAI,SAAS,SAAiB,IAAU,EAIlD,GACC,oBAAoB,WAClB,SAAsB,QAAQ,IAAI,gBAAgB,GACnD,SAAsB,QAAQ,IAAI,mBAAmB,IAAM,UAE5D,OAAO,cACN,eAAe,QAAQ,EACvB,qBAAqB,SAAsB,IAAG,EAC9C,OACD,EAGD,GAEC,OAAO,UAAU,OAAS,YAC1B,oBAAoB,eAEpB,OAAO,cAAa,SAAiB,KAAK,OAAO,EAElD,OAAO,oBAAmB,SAAU,OAAO,GAG/B,kBAAmB,CAC/B,SACA,KACA,UAC0B,CAC1B,GAAI,WAAa,QAAa,WAAa,KAAM,OAEjD,GAAI,WAAW,KAAI,OAAO,GAAK,KAAI,SAAW,KAAO,KAAI,OAGxD,OAFA,UAAU,IAAG,EAEL,UAAU,aAAa,UACzB,SACJ,OAAO,IAAI,SAAS,SAAoB,IAAU,MAE9C,YACA,SAEJ,OADA,KAAI,QAAQ,gBAAkB,mBACvB,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,IAAU,MAEpD,aACJ,OAAO,WAAY,SAAwB,KAAa,MAEpD,OACJ,OAAO,WAAW,SAAkB,IAAU,MAE1C,OACJ,OAAO,WAAW,SAAyB,IAAG,MAE1C,6BAGJ,OAFA,KAAI,OAAU,SAA6C,KAEpD,kBACL,SAA6C,SAC9C,KACA,OACD,MAEI,iBACJ,IACE,KAAI,QAAQ,iBAAiB,WAC7B,mBACD,EAEA,KAAI,QAAQ,gBACX,mCAeF,OAbA,SAAS,QAAQ,iBAChB,QACA,CACC,WAAW,EAAG,CACb,GAAI,SAAS,SAAW,SAAS,QAAQ,QACvC,SAA4B,OAAO,EAEvC,EACA,CACC,KAAM,EACP,CACD,EAEO,IAAI,SAAS,SAA4B,IAAU,MAEtD,QACJ,IAAK,SAAU,OAEf,OAAO,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,IAAU,MAEpD,WACJ,OAAO,gBAAe,SAAsB,KAAK,OAAO,MAEpD,UAEJ,OAAQ,SAA8B,KAAK,CAAC,IAC3C,kBAAiB,EAAG,IAAG,CACxB,MAEI,QACJ,OAAO,iBAAgB,SAAmB,IAAG,MAEzC,WACJ,OAAO,kBAAkB,SAAsB,EAAG,IAAG,MAEjD,aACA,UACJ,OAAO,IAAI,SACT,SAA8B,SAAS,EACxC,IACD,MAEI,WACJ,OAAO,IAAI,SAAS,QAAoB,MAEpC,SACJ,GAAI,oBAAoB,OACvB,OAAO,IAAI,SAAS,SAAS,MAAO,IAAU,EAE/C,OAAO,IAAI,SAAS,UAAU,SAAS,EAAG,IAAU,UAGpD,GAAI,oBAAoB,SACvB,OAAO,gBAAe,SAAU,KAAK,OAAO,EAE7C,GAAI,oBAAoB,QACvB,OAAO,SAAS,KAAK,CAAC,IAAM,kBAAiB,EAAG,IAAG,CAAC,EAErD,GAAI,oBAAoB,MACvB,OAAO,iBAAgB,SAAmB,IAAG,EAE9C,GAAI,oBAAoB,2BAKvB,OAJA,KAAI,OACH,SACC,KAEK,kBACL,SAA6C,SAC9C,KACA,OACD,EAID,GAAI,OAAO,UAAU,OAAS,WAC7B,OAAO,cAAa,SAAiB,KAAK,OAAO,EAGlD,GAAI,OAAO,UAAU,OAAS,WAE7B,OAAO,SAAS,KAAK,CAAC,IAAM,kBAAiB,EAAG,IAAG,CAAC,EAGrD,GAAI,OAAO,UAAU,aAAe,WACnC,OAAO,kBAAkB,SAAiB,WAAW,EAAG,IAAG,EAE5D,GAAI,eAAiB,SAAkB,CACtC,IAAM,KAAQ,SAAiB,WAAW,CAAC,EAE3C,GAAI,OAAS,KAAO,OAAS,GAAI,CAChC,IAAK,KAAI,QAAQ,gBAChB,KAAI,QAAQ,gBAAkB,mBAE/B,OAAO,IAAI,SACV,KAAK,UAAU,QAAQ,EACvB,IACD,GAIF,OAAO,IAAI,SAAS,SAAiB,IAAU,EAGjD,YAAQ,UAAU,aAAa,UACzB,SACJ,OAAO,IAAI,SAAS,QAAkB,MAElC,YACA,SAEJ,OADA,KAAI,QAAQ,gBAAkB,mBACvB,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,IAAU,MAEpD,aACJ,OAAO,WAAY,SAAwB,KAAa,MAEpD,OACJ,OAAO,WAAW,SAAkB,IAAU,MAE1C,OACJ,OAAO,WAAW,SAAyB,IAAG,MAE1C,6BAGJ,OAFA,KAAI,OAAU,SAA6C,KAEpD,kBACL,SAA6C,SAC9C,KACA,OACD,MAEI,iBAcJ,OAbA,SAAS,QAAQ,iBAChB,QACA,CACC,WAAW,EAAG,CACb,GAAI,SAAS,SAAW,SAAS,QAAQ,QACvC,SAA4B,OAAO,EAEvC,EACA,CACC,KAAM,EACP,CACD,EAEO,IAAI,SAAS,SAA4B,CAC/C,QAAS,CACR,eAAgB,kCACjB,CACD,CAAC,MAEG,QACJ,IAAK,SAAU,OAAO,IAAI,SAAS,EAAE,EAErC,OAAO,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,CAC7C,QAAS,CACR,eAAgB,kBACjB,CACD,CAAC,MAEG,WACJ,IACG,SAAsB,QAAQ,IAAI,gBAAgB,GACnD,SAAsB,QAAQ,IAAI,mBAAmB,IACrD,UAED,OAAO,cACN,eAAe,QAAoB,EACnC,qBAAqB,QAAoB,EACzC,OACD,EAED,OAAO,aAEH,UAEJ,OAAQ,SAA8B,KAAK,CAAC,IAAM,CACjD,IAAM,EAAI,kBAAiB,EAAG,IAAG,EACjC,GAAI,IAAM,OAAW,OAAO,EAC5B,MAEG,QACJ,OAAO,iBAAgB,SAAmB,IAAG,MAEzC,WACJ,OAAO,oBAAoB,SAAsB,EAAG,OAAO,MAEvD,aACA,UACJ,OAAO,IAAI,SAAU,SAA8B,SAAS,CAAC,MAEzD,SACJ,GAAI,oBAAoB,OACvB,OAAO,IAAI,SAAS,SAAS,MAAO,IAAU,EAE/C,OAAO,IAAI,SAAS,UAAU,SAAS,EAAG,IAAU,MAEhD,WACJ,OAAO,IAAI,SAAS,QAAoB,UAGxC,GAAI,oBAAoB,SAAU,OAAO,SAEzC,GAAI,oBAAoB,QACvB,OAAO,SAAS,KAAK,CAAC,IAAM,kBAAiB,EAAG,IAAG,CAAC,EAErD,GAAI,oBAAoB,MACvB,OAAO,iBAAgB,SAAmB,IAAG,EAE9C,GAAI,oBAAoB,2BAKvB,OAJA,KAAI,OACH,SACC,KAEK,kBACL,SAA6C,SAC9C,KACA,OACD,EAID,GAAI,OAAO,UAAU,OAAS,WAC7B,OAAO,cAAa,SAAiB,KAAK,OAAO,EAGlD,GAAI,OAAO,UAAU,OAAS,WAE7B,OAAO,SAAS,KAAK,CAAC,IAAM,kBAAiB,EAAG,IAAG,CAAC,EAGrD,GAAI,OAAO,UAAU,aAAe,WACnC,OAAO,kBAAkB,SAAiB,WAAW,EAAG,IAAG,EAE5D,GAAI,eAAiB,SAAkB,CACtC,IAAM,KAAQ,SAAiB,WAAW,CAAC,EAE3C,GAAI,OAAS,KAAO,OAAS,GAAI,CAChC,IAAK,KAAI,QAAQ,gBAChB,KAAI,QAAQ,gBAAkB,mBAE/B,OAAO,IAAI,SACV,KAAK,UAAU,QAAQ,EACvB,IACD,GAIF,OAAO,IAAI,SAAS,QAAe,IAI1B,oBAAqB,CACjC,SACA,UACc,CACd,OAAQ,UAAU,aAAa,UACzB,SACJ,OAAO,IAAI,SAAS,QAAkB,MAElC,aACA,QACJ,OAAO,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,CAC7C,QAAS,CACR,eAAgB,kBACjB,CACD,CAAC,MAEG,aACJ,OAAO,WAAY,SAAwB,KAAa,MAEpD,OACJ,OAAO,WAAW,QAAgB,MAE9B,OACJ,OAAO,WAAW,QAAuB,MAErC,6BACJ,OAAO,aACL,SAA6C,SAC9C,CACC,OAAS,SAA6C,KACtD,QAAS,CAAC,CACX,CACD,MAEI,iBAcJ,OAbA,SAAS,QAAQ,iBAChB,QACA,CACC,WAAW,EAAG,CACb,GAAI,SAAS,SAAW,SAAS,QAAQ,QACvC,SAA4B,OAAO,EAEvC,EACA,CACC,KAAM,EACP,CACD,EAEO,IAAI,SAAS,SAA4B,CAC/C,QAAS,CACR,eAAgB,kCACjB,CACD,CAAC,MAEG,QACJ,IAAK,SAAU,OAAO,IAAI,SAAS,EAAE,EAErC,OAAO,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,CAC7C,QAAS,CACR,eAAgB,kBACjB,CACD,CAAC,MAEG,WACJ,GACE,SAAsB,QAAQ,IAAI,mBAAmB,IACtD,UAEA,OAAO,cACN,eAAe,QAAoB,EACnC,qBAAqB,QAAoB,EACzC,OACD,EAED,OAAO,aAEH,QACJ,OAAO,iBAAgB,QAAiB,MAEpC,UACJ,OAAQ,SAAqC,KAAK,CAAC,IAClD,oBAAmB,EAAG,OAAO,CAC9B,MAGI,WACJ,OAAO,oBAAoB,SAAsB,EAAG,OAAO,MAEvD,aACA,UACJ,OAAO,IAAI,SAAU,SAA8B,SAAS,CAAC,MAEzD,WACJ,OAAO,IAAI,SAAS,QAAoB,UAGxC,GAAI,oBAAoB,SAAU,OAAO,SAEzC,GAAI,oBAAoB,QACvB,OAAO,SAAS,KAAK,CAAC,IACrB,oBAAmB,EAAG,OAAO,CAC9B,EAED,GAAI,oBAAoB,MACvB,OAAO,iBAAgB,QAAiB,EAEzC,GAAI,oBAAoB,2BACvB,OAAO,aACL,SAA6C,SAC9C,CACC,OAAS,SACP,KACF,QAAS,CAAC,CACX,CACD,EAGD,GAAI,OAAO,UAAU,OAAS,WAC7B,OAAO,cAAa,SAAiB,OAAW,OAAO,EAGxD,GAAI,OAAO,UAAU,OAAS,WAE7B,OAAO,SAAS,KAAK,CAAC,IAAM,aAAY,EAAG,GAAG,CAAC,EAGhD,GAAI,OAAO,UAAU,aAAe,WACnC,OAAO,oBAAoB,SAAiB,WAAW,CAAC,EAEzD,GAAI,eAAiB,SAAkB,CACtC,IAAM,KAAQ,SAAiB,WAAW,CAAC,EAE3C,GAAI,OAAS,KAAO,OAAS,GAC5B,OAAO,IAAI,SAAS,KAAK,UAAU,QAAQ,EAAG,CAC7C,QAAS,CACR,eAAgB,kBACjB,CACD,CAAC,EAIH,OAAO,IAAI,SAAS,QAAe,IAIzB,iBAAkB,CAAC,OAAc,OAC7C,IAAI,SACH,KAAK,UAAU,CACd,KAAM,QAAO,KACb,QAAS,QAAO,QAChB,MAAO,QAAO,KACf,CAAC,EACD,CACC,OACC,MAAK,SAAW,IAAQ,MAAK,QAAqB,IAAO,IAC1D,QAAS,MAAK,OACf,CACD,EAEY,qBAAsB,CAClC,OACA,MACA,WAAwC,CAAC,IACP,CAClC,GAAI,OAAO,SAAW,WAAY,OAElC,IAAM,SAAW,aAAY,OAAQ,CACpC,QAAS,UACV,CAAC,EAED,IACE,MAAM,OAAO,SACb,MAAM,WAAW,SACjB,MAAM,cAAc,SACpB,MAAM,aAAa,OAEpB,OAAO,SAAS,MAAM,KAAK,QAAQ,GAG/B,gBAAiB,sBAAsB,CAC5C,yBACA,sCACD,CAAC,EAEK,cAAe,oBAAoB,CACxC,yBACA,sCACD,CAAC,EC1pBD,IAAM,YAAa,CAAC,MAAe,YAClC,UAAY,MAAQ,GAEf,cAAgB,CACrB,IACA,MACA,UACA,SAAW,KACP,CACJ,IAAI,UAAY,GAGV,eAAiB,IAAI,WAErB,WAAa,IAAI,MAAM,OAAO,OACpC,GAAI,SAAU,WAAa;AAAA,EAE3B,IAAM,UAAY,OAAO,KAAK,MAAM,IAAI,EAIlC,MACL,uCAHwB,IAAI,OAAO,SAAS,kBAAoB,GAI1B,GAAK;AAAA,EAG5C,GAAI,UAAU,MAAO,WAAa,MAElC,IAAM,SAAW,UAAU,KACxB,IACC,UACA,SAAS,MAAM,SACf,eACA,UAAU,MAAQ,GAAK,OACxB;AAAA;AAAA,IAwBH,GApBA,WACC,YAAW,YAAa,QAAQ,EAChC,kBAEA,YAAW,MAAO,UAAU,KAAK,EACjC,YAAW,yBAA0B,SAAS,EAC9C,QACA,YACC,mBACA,UAAY,UAAU,KAAO,UAAU,KACxC,EACA,8CAIC,WAAW,cAAc,EACvB,mCACA,uBACH,eAEG,UAAU,OAAQ,WAAa,wCAEnC,GAAI,SAAU,WAAa,0BAE3B,CACC,IAAI,kBAAoB,GAExB,QAAW,OAAO,OAAO,KAAK,IAAI,UAAU,SAAS,EACpD,mBAAqB,KAAK,mBAAmB,QAE9C,WAAa,iBACd,CAIA,OAFA,WAAa;AAAA,EAEN,WAGK,sBAAwB,CAAC,IAAgB,QAAyB,CAC9E,IAAM,WAAa,IAAI,MAAM,OAAO,OAE9B,SAAW,IAAI,SAAS,qBAAqB,OAE/C,UAAY,QACf,MAAM,MAEN,IAAI,SACL,EACA,UAAY,QACX,CACC,QAAS,MAAM,OAChB,EACA,SACD,EAEA,IAAI,UACH,oKAOA,YAAW,0BAA2B,QAAQ,EAC9C,YAAW,4CAA6C,QAAQ,EAChE,YAAW,kCAAmC,QAAQ,EACtD,YAAW,oBAAqB,QAAQ,EACxC,YAAW,gBAAiB,MAAM,EAClC;AAAA,EAED,GAAI,IAAI,MAAM,SAAS,OACtB,WAAa;AAAA,EAKd,GAHA,WAAa,GAAG,IAAI,MAAM,SAAS,KAAK,OAAO,EAAI,QAAU,4BAGzD,UAAY,UAAU,OAAS,IAAI,MAAM,SAAS,OACrD,WAAa,cAAc,IAAK,MAAO,SAAS,EAChD,WAAa,uBAAuB,GAAG,EAEvC,WAAa,qBAEb,gBAAa,kBAAkB,cAAc,IAAK,MAAO,UAAW,EAAI,MAIzE,OAFA,WAAa,UAAU,GAAG,EAEnB,SACN,OACA,SACD,EAAE,CACD,IACA,QAAS,MAAM,UAAU,GAAK,MAAM,SACpC,SACA,OAEA,IAAK,IAAI,SAAS,qBAAqB,IAAI,CAAC,IAAM,EAAE,EAAE,EACtD,MAAO,IAAI,MACX,UAAW,IAAI,UACf,MAAO,MAAM,KACb,SAAU,SAAW,SAAW,OAChC,aAAc,SAAW,aAAe,OACxC,kBAAmB,SAAW,kBAAoB,OAClD,MAAO,SAAW,IAAI,MAAM,OAAO,IAAI,CAAC,IAAM,GAAG,IAAM,CAAC,EAAI,OAC5D,iBAAkB,iBACnB,CAAC,GCpJK,IAAM,0BAA4B,CACxC,OACA,MACA,WAAwC,CAAC,IACO,CAChD,GAAI,OAAO,SAAW,YAAc,kBAAkB,KAAM,OAE5D,GACC,OAAO,SAAW,UAClB,QAAQ,SAAS,IAAM,sBAGvB,MAAO,IAAM,OAEd,IAAM,SAAW,aAAY,OAAQ,CACpC,QAAS,UACV,CAAC,EAED,IACE,MAAM,OAAO,SACb,MAAM,WAAW,SACjB,MAAM,cAAc,SACpB,MAAM,aAAa,OACnB,CACD,GAAI,oBAAoB,QACvB,OAAO,SAAS,KAAK,CAAC,YAAa,CAClC,IAAK,UAAU,OAEf,IAAK,UAAS,QAAQ,IAAI,cAAc,EACvC,UAAS,QAAQ,OAAO,eAAgB,YAAY,EAErD,OAAO,UAAS,MAAM,EACtB,EAEF,IAAK,SAAS,QAAQ,IAAI,cAAc,EACvC,SAAS,QAAQ,OAAO,eAAgB,YAAY,EAErD,OAAO,SAAS,MAAM,KAAK,QAAQ,ICzB9B,IAAM,UAAmC,CAC/C,IAAI,CAAC,GAAI,CACR,GAAG,KAAK,OAAO,EAAE,GAElB,OAAO,CAAC,GAAI,QAAS,CACpB,GAAG,KAAK,UAAU,GAAI,OAAO,GAE9B,KAAK,CAAC,GAAI,CACT,GAAG,KAAK,QAAQ,EAAE,GAEnB,KAAK,CAAC,GAAI,KAAM,OAAQ,CACvB,GAAG,KAAK,QAAQ,GAAI,KAAM,MAAM,EAElC,EAOO,MAAM,QAEb,CAYS,IAIA,KAGA,KAlBR,WACC,aAIG,GAAE,EAAG,CAER,OAAO,KAAK,KAAK,GAGlB,WAAW,CACH,IAIA,KAGA,KAAsB,OAC5B,CARM,aAIA,eAGA,eAEP,KAAK,UAAY,IAAI,MAAM,UAE3B,KAAK,SAAW,IAAI,SAAS,KAAK,GAAG,EACrC,KAAK,WAAa,IAAI,WAAW,KAAK,GAAG,EACzC,KAAK,MAAQ,IAAI,MAAM,KAAK,GAAG,EAC/B,KAAK,UAAY,IAAI,UAAU,KAAK,GAAG,EACvC,KAAK,YAAc,IAAI,YAAY,KAAK,GAAG,EAC3C,KAAK,cAAgB,IAAI,cAAc,KAAK,GAAG,EAC/C,KAAK,UAAY,IAAI,UAAU,KAAK,GAAG,EACvC,KAAK,YAAc,IAAI,YAAY,KAAK,GAAG,EAC3C,KAAK,aAAe,IAAI,aAAa,KAAK,GAAG,EAC7C,KAAK,KAAO,IAAI,KAAK,KAAK,GAAG,EAC7B,KAAK,cAAgB,IAAI,cACzB,KAAK,WAAa,IAAI,WACtB,KAAK,KAAO,IAAI,KAEhB,KAAK,KAAO,KAAK,KAAK,KAAK,IAAI,EAC/B,KAAK,KAAO,KAAK,KAAK,KAAK,IAAI,EAC/B,KAAK,KAAO,KAAK,KAAK,KAAK,IAAI,EAC/B,KAAK,QAAU,KAAK,QAAQ,KAAK,IAAI,EAatC,IAAI,CACH,KACA,SAC4B,CAC5B,GAAI,OAAO,SAAS,IAAI,EACvB,OAAO,KAAK,IAAI,KAAK,KAAiC,QAAQ,EAE/D,GAAI,KAAK,WAAW,MAAM,IAAI,IAAM,GACnC,OAAO,KAAK,IAAI,KACf,IAAI,gBAAgB,UAAW,KAAK,UAAW,IAAI,EAAE,OACtD,EAED,GAAI,OAAO,OAAS,SAAU,KAAO,KAAK,UAAU,IAAI,EAExD,OAAO,KAAK,IAAI,KAAK,KAA2B,QAAQ,EAQzD,IAAI,CACH,KAC4B,CAC5B,GAAI,OAAO,SAAS,IAAI,EACvB,OAAO,KAAK,IAAI,KAAK,IAA+B,EAErD,GAAI,KAAK,WAAW,MAAM,IAAI,IAAM,GACnC,OAAO,KAAK,IAAI,KACf,IAAI,gBAAgB,UAAW,KAAK,UAAW,IAAI,EAAE,OACtD,EAED,GAAI,OAAO,OAAS,SAAU,KAAO,KAAK,UAAU,IAAI,EAExD,OAAO,KAAK,IAAI,KAAK,IAAc,EAQpC,IAAI,CACH,KAC4B,CAC5B,GAAI,OAAO,SAAS,IAAI,EACvB,OAAO,KAAK,IAAI,KAAK,IAA+B,EAErD,GAAI,KAAK,WAAW,MAAM,IAAI,IAAM,GACnC,OAAO,KAAK,IAAI,KACf,IAAI,gBAAgB,UAAW,KAAK,UAAW,IAAI,EAAE,OACtD,EAED,GAAI,OAAO,OAAS,SAAU,KAAO,KAAK,UAAU,IAAI,EAExD,OAAO,KAAK,IAAI,KAAK,IAAc,EAcpC,OAAO,CACN,MACA,KACA,SAC4B,CAC5B,GAAI,OAAO,SAAS,IAAI,EACvB,OAAO,KAAK,IAAI,QACf,MACA,KACA,QACD,EAED,GAAI,KAAK,WAAW,MAAM,IAAI,IAAM,GACnC,OAAO,KAAK,IAAI,KACf,IAAI,gBAAgB,UAAW,KAAK,UAAW,IAAI,EAAE,OACtD,EAED,GAAI,OAAO,OAAS,SAAU,KAAO,KAAK,UAAU,IAAI,EAExD,OAAO,KAAK,IAAI,QAAQ,MAAO,KAA2B,QAAQ,EAGnE,SACA,WACA,MACA,UACA,YACA,cACA,UACA,YACA,aACA,KACA,cACA,cAEI,WAAU,EAAG,CAChB,OAAO,KAAK,IAAI,WAElB,CAEO,IAAM,sBAAwB,CACpC,SACI,CACJ,IAAM,QAAU,OAAO,SAAU,WAAa,CAAC,MAAK,EAAI,OAExD,OAAO,eAAe,YAAY,CAAC,GAA0B,QAAc,CAC1E,GAAI,OAAO,UAAY,SAAU,CAChC,IAAM,MAAQ,SAAS,WAAW,CAAC,EAEnC,GAAI,QAAU,IAAM,QAAU,IAAM,QAAU,IAAM,QAAU,IAC7D,GAAI,CACH,QAAU,KAAK,MAAM,OAAO,EAC3B,KAAM,EAGJ,QAAI,gBAAgB,OAAO,EAAG,SAAW,QACzC,QAAI,UAAY,OAAQ,QAAU,GAClC,QAAI,UAAY,QAAS,QAAU,GACnC,QAAI,UAAY,OAAQ,QAAU,KAGxC,GAAI,QACH,QAAS,EAAI,EAAG,EAAI,QAAQ,OAAQ,IAAK,CACxC,IAAI,KAAO,QAAQ,GAAG,GAAW,OAAO,EACxC,GAAI,gBAAgB,QAAS,KAAO,MAAM,KAE1C,GAAI,OAAS,OAAW,OAAO,KAGjC,OAAO,UAII,uBAAyB,CACrC,mBACI,CACJ,IAAM,iBAAmB,CACxB,GACA,OACa,CACb,GAAI,gBAAgB,QACnB,OAAO,KAAK,KAAK,CAAC,QAAS,iBAAiB,GAAI,KAAI,CAAC,EAEtD,GAAI,OAAO,SAAS,IAAI,EAAG,OAAO,GAAG,KAAK,KAAK,SAAS,CAAC,EAEzD,GAAI,OAAS,OAAW,OAExB,IAAM,KAAO,CAAC,QAAmB,CAChC,GAAI,kBAAkB,MAAM,KAAK,IAAM,GACtC,OAAO,GAAG,KACT,IAAI,gBAAgB,UAAW,iBAAkB,KAAK,EACpD,OACH,EAED,GAAI,OAAO,QAAU,SAAU,OAAO,GAAG,KAAK,KAAK,UAAU,KAAK,CAAC,EAEnE,GAAG,KAAK,KAAK,GAGd,GAAI,OAAQ,MAAoB,OAAS,WACxC,OAAO,KAAK,KAAK,IAAI,EAEtB,IAAM,KAAQ,KAAoC,KAAK,EAEvD,GAAI,gBAAgB,QACnB,OAAQ,SAAY,CACnB,IAAM,MAAQ,MAAM,KAEpB,GAAI,kBAAkB,MAAM,KAAK,IAAM,GACtC,OAAO,GAAG,KACT,IAAI,gBAAgB,UAAW,iBAAkB,KAAK,EACpD,OACH,EAID,GAFA,KAAK,MAAM,KAAY,GAElB,MAAM,KACV,cAAiB,SAAS,KAAmB,KAAK,KAAK,IACtD,EAIJ,GAFA,KAAK,KAAK,KAAK,GAEV,KAAK,KAAM,QAAW,SAAS,KAAmB,KAAK,KAAK,GAGlE,OAAO,kBCvPR,IAAM,cAAgB,iBAEhB,kBAAoB,CAAC,OAAiB,CAC3C,IAAM,MAAQ,cAAc,KAAK,IAAI,EAErC,IAAK,MAAO,MAAO,CAAC,IAAI,EAExB,IAAM,OAAmB,CAAC,EAEpB,KAAO,KAAK,MAAM,EAAG,MAAM,KAAK,EAChC,MAAQ,MAAM,GAAG,MAAM,EAAG,EAAE,EAC5B,KAAO,KAAK,MAAM,MAAM,MAAQ,MAAM,GAAG,MAAM,EAErD,OAAO,KAAK,KAAK,MAAM,EAAG,EAAE,CAAC,EAC7B,OAAO,KAAK,KAAO,KAAK,EAExB,QAAW,YAAY,kBAAkB,IAAI,EAAG,CAC/C,IAAK,SAAU,SAEf,IAAK,SAAS,WAAW,IAAI,EAC5B,OAAO,KAAK,KAAK,MAAM,EAAG,EAAE,EAAI,QAAQ,EAEzC,OAAO,KAAK,KAAO,MAAQ,QAAQ,EAGpC,OAAO,QAGF,iBAAmB,CACxB,IAAK,GACL,KAAM,GACN,QAAS,GACT,OAAQ,GACR,MAAO,GACP,KAAM,GACN,IAAK,EACN,EAEM,UAAY,CAAC,MAAmB,CACrC,IAAK,IAAI,OAAO,MAAQ,IAAI,OAAO,aAAc,OAEjD,IAAM,OAA6D,CAAC,EAE9D,IAAM,CACX,MAIA,UACI,CACJ,GAAI,OAAO,MAAM,OAEhB,IAAK,OAAO,MAAM,MAAM,MAAM,QAE7B,OAAO,MAAM,MAAM,MAAM,QAAU,QAEpC,YAAO,MAAM,MAAQ,EACnB,MAAM,QAAS,OACjB,GAII,KAAO,IAAI,UAEjB,QAAW,SAAS,IAAI,OAAO,QAAS,CACvC,GAAI,OAAO,MAAM,UAAY,WAAY,SAEzC,IAAM,OAAS,MAAM,OAErB,GACE,SAAW,OAAS,MAAM,MAAM,SAAU,MAC3C,SAAW,MACX,MAAM,KAAK,WAAW,MAAM,KAAK,OAAS,CAAC,IAAM,MAC/C,UAAU,kBAEZ,SAED,GAAI,SAAW,MAAO,CACrB,KAAM,MAAM,MAAM,SAAU,MAC3B,OAAO,MAAM,MAAQ,MAAM,OAAO,QAAQ,MACvC,MAAM,MAAM,OACb,IAAI,MAAM,OAEV,IAAI,SAAS,qBACX,sBAAsB,IAAK,KAAK,EAChC,MAAM,MAAM,OAAS,MAAM,QAC5B,MAAM,QAEV,SAGD,IAAI,SAEE,QAAU,IAAI,OAAO,WACxB,sBAAsB,IAAK,KAAK,EAChC,CAAC,UAAqB,CACtB,GAAI,SAAU,OAAO,SAAS,OAAO,EAErC,OAAQ,SAAW,sBAAsB,IAAK,KAAK,GAClD,OACD,GAGH,QAAW,QAAQ,kBAAkB,MAAM,IAAI,EAC9C,IACC,CACC,OACA,IACD,EACA,OACD,EAGF,OAAO,QAKF,YAAc,CAAC,GAAY,KAAgB,CAChD,IAAK,GAAI,OAAO,GAEhB,QAAW,OAAO,OAAO,KAAK,EAAE,EAAG,CAClC,GAAI,GAAG,OAAS,GAAG,KAAM,SAEzB,IAAK,GAAG,KAAM,CACb,GAAG,KAAO,GAAG,KACb,SAGD,GAAI,GAAG,MAAQ,GAAG,KAAM,CACvB,GAAI,OAAO,GAAG,OAAS,YAAc,GAAG,eAAgB,SAAU,CACjE,GAAG,KAAO,GAAG,KACb,SAGD,GAAG,KAAO,IACN,GAAG,QACH,GAAG,IACP,GAIF,OAAO,IAGK,WAA4B,IACrC,mBACH,KAAM,MACN,QAAS,CACR,yBACA,mCACA,uCACA,yCACA,yBACD,EACA,eAAgB,IACZ,mBAAmB,eACtB,QAAS,mBACN;AAAA,EACA;AAAA;AAAA,CAGJ,EACA,MAAM,CAAC,IAAK,CACX,MAAO,CAAC,QAAS,WAAa,CAC7B,GAAI,OAAO,MAAQ,YAClB,MAAM,IAAI,MACT,+JACD,EAID,GAFA,IAAI,QAAQ,EAER,OAAO,UAAY,SAAU,CAChC,IAAK,gBAAgB,OAAO,EAC3B,MAAM,IAAI,MAAM,8BAA8B,EAE/C,QAAU,SAAS,OAAO,EAG3B,IAAM,kBAAoB,CAGzB,UACE,UAAY,IAAqC,CAAC,IAW9C,CACN,IAAM,aAML,CAAC,EACI,IAAsB,CAAC,EAE7B,QAAY,KAAM,SAAU,OAAO,QAAQ,QAAQ,EAClD,GAAI,8BAA+B,CAClC,IAAK,MAAO,SAEZ,QAAY,OAAQ,SAAU,OAAO,QAAQ,KAAK,EAAG,CACpD,IAAK,SAAW,UAAU,kBACzB,SAED,GAAI,iBAAiB,QAAS,CAC7B,GAAI,UAAW,CACd,IAAK,aAAa,MACjB,aAAa,MAAQ,CAAC,EAEvB,IAAI,KACH,MAAM,KAAK,CAAC,UAAY,CACvB,GAAI,mBAAmB,SAEtB,aAAa,MAAM,QAClB,QACF,CACF,EAGD,SAGD,KAAM,iBAAiB,UAAW,SAElC,IAAK,aAAa,MAAO,aAAa,MAAQ,CAAC,EAG/C,aAAa,MAAM,QAAU,OAExB,KACN,IAAK,MAAO,SAEZ,GAAI,iBAAiB,QAAS,CAC7B,GAAI,UAAW,CACd,IAAK,aAAa,MAAO,aAAa,MAAQ,CAAC,EAE/C,IAAI,KACH,MAAM,KAAK,CAAC,UAAY,CACvB,GAAI,mBAAmB,SAEtB,aAAa,MAAQ,QACtB,CACF,EAGD,SAGD,KAAM,iBAAiB,UAAW,SAElC,aAAa,MAAQ,MAIvB,GAAI,UACH,OAAO,QAAQ,IAAI,GAAG,EAAE,KAAK,IAAM,YAAY,EAEhD,OAAO,cAGF,MACL,OAAO,UAAY,SACf,CACD,aAAc,aACd,UAAW,MACP,IAAI,OAAO,OAAS,CAAC,KACrB,SAAW,CAAC,EAEhB,OAAQ,YACP,YACC,kBAAkB,IAAI,OAAO,QAAQ,EACrC,UAAU,GAAG,CACd,EAEA,IAAI,OAAO,OAAO,MACnB,EACA,UAAW,IACN,IAAI,OAAO,WAAa,CAAC,KACzB,WAAa,CAAC,CACnB,EACA,MAAO,IAAI,KAEZ,EACE,CACD,aAAc,aACd,UAAW,MACP,IAAI,OAAO,OAAS,CAAC,EAEzB,OAAQ,YACP,YACC,kBAAkB,IAAI,OAAO,QAAQ,EACrC,UAAU,GAAG,CACd,EAEA,IAAI,OAAO,OAAO,MACnB,EACA,UAAW,IACN,IAAI,OAAO,WAAa,CAAC,KACzB,WAAa,CAAC,CACnB,EACA,KAAM,QACN,MAAO,IAAI,KAEZ,EAIH,GAFA,IAAI,OAAS,IAAI,MAAM,KAAY,EAE/B,IAAI,MAAM,MACb,QAAS,EAAI,EAAG,EAAI,IAAI,MAAM,MAAM,OAAQ,IAC3C,IAAI,MAAM,MAAM,GAAG,GAAG,GAAG,EAE3B,GAAI,SAAU,SAAS,IAAI,MAAO,EAElC,QAAQ,GAAG,aAAc,IAAM,CAC9B,GAAI,IAAI,QAIP,GAHA,IAAI,OAAO,OAAO,EAClB,IAAI,OAAS,KAET,IAAI,MAAM,KACb,QAAS,EAAI,EAAG,EAAI,IAAI,MAAM,KAAK,OAAQ,IAC1C,IAAI,MAAM,KAAK,GAAG,GAAG,GAAG,GAE3B,EAGD,IAAI,gBAAgB,KAAK,SAAY,CACpC,IAAI,QAAQ,OAAO,IACf,MACH,MAAO,IAAI,MAEX,OAAQ,YACP,YACC,MAAM,kBAAkB,IAAI,OAAO,SAAU,CAC5C,UAAW,EACZ,CAAC,EACD,UAAU,GAAG,CACd,EAEA,IAAI,OAAO,OAAO,MACnB,CACD,CAAC,EAED,KAAK,GAAG,EAAK,EACb,IAGH,EAAE,CAAC,IAAK,KAAM,QAAS,CAEtB,IAAQ,aAAO,KAAM,YAAa,MAAS,QAErC,gBAAkB,mBAAmB,KAAM,CAEhD,QAAS,IAAI,YAAY,QAEzB,OAAQ,IAAI,YAAY,KACxB,UAAW,IAAI,OAAO,SACvB,CAAC,EAEK,iBAAmB,mBAAmB,SAAiB,CAE5D,QAAS,IAAI,YAAY,QAEzB,OAAQ,IAAI,YAAY,KACxB,UAAW,IAAI,OAAO,SACvB,CAAC,EAED,IAAI,MACH,KACA,KACA,MAAO,UAAiB,CAEvB,IAAM,OAAS,IAAI,UAAU,GAIrB,SAAK,WAAM,GAAI,QAAS,MAAO,QAAW,QAKlD,GAFA,QAAQ,UAAY,iBAEhB,QAAQ,SACX,GAAI,OAAO,QAAQ,UAAY,WAAY,CAC1C,IAAM,KAAO,QAAQ,QAAQ,OAAc,EAC3C,GAAI,gBAAgB,QAAS,MAAM,KAC7B,QAAI,QAAQ,QAClB,OAAO,OACN,KAAI,QACJ,QAAQ,OACT,EAGF,GAAI,KAAI,QAAU,WAAW,KAAI,MAAM,EAAG,CACzC,IAAM,OAAS,gBAAgB,KAAI,MAAM,EAEzC,GAAI,OAAQ,KAAI,QAAQ,cAAgB,OAGzC,GACC,KAAI,QAAQ,eACZ,MAAM,QAAQ,KAAI,QAAQ,aAAa,EAEvC,KAAI,QAAU,gBACb,IAAI,QAAQ,KAAI,OAAc,EAC9B,KAAI,QAAQ,aACb,EAED,IAAM,gBAAiB,uBAAuB,gBAAgB,EACxD,aAAe,sBAAsB,MAAK,EAE5C,IAEE,cAAgB,CACrB,GAAI,MAAM,QAAQ,QAAQ,KAAK,EAC5B,QAAQ,MACR,CAAC,QAAQ,KAAK,EACjB,IAAI,IAAI,MAAM,OAAS,CAAC,GAAG,IAAI,CAAC,IAC/B,OAAO,IAAM,WAAa,EAAI,EAAE,EACjC,CACD,EAAE,OAAO,CAAC,IAAM,CAAC,EAEX,cAAgB,cAAc,OACjC,IAAM,GACN,MAAO,GAA0B,SAAmB,CACpD,QAAW,eAAe,cAAe,CACxC,IAAI,UAAW,YACd,OAAO,OAAO,QAAS,CAAE,YAAM,CAAC,CACjC,EACA,GAAI,qBAAoB,QACvB,UAAW,MAAM,UAIlB,GAFA,MAAM,gBAAe,GAAI,SAAQ,EAE7B,UAAU,QAIlB,GACC,QAAQ,QAAa,QAAQ,QAAS,CACrC,QAAS,WAAW,KAAI,OAAO,EAC3B,KAAI,QACL,OACH,KAAM,IACF,WACC,GAAE,EAAG,CACR,GAAI,IAAK,OAAO,IAEhB,OAAQ,IAAM,SAAS,GAExB,UAAW,iBACX,IAAI,CAAC,KAAgB,CACpB,QAAQ,OAAO,IAAI,GAEpB,IAAI,CAAC,KAAgB,CACpB,QAAQ,OAAO,IAAI,GAEpB,IAAI,CAAC,GAA0B,CAC9B,GAAI,CACH,gBACC,GACA,QAAQ,OACP,IAAI,SAAS,GAAI,OAAc,CAChC,CACD,EACC,MAAO,OAAO,CACf,aAAa,GAAI,MAAK,IAGxB,QAAS,MACR,GACA,WACI,CACJ,IAAM,QAAU,MAAM,aAAa,GAAI,QAAQ,EAE/C,GAAI,iBAAiB,MAAM,OAAO,IAAM,GACvC,OAAO,KAAK,GAAG,KACd,IAAI,gBACH,UACA,gBACA,OACD,EAAE,OACH,EAED,GAAI,CACH,gBACC,GACA,QAAQ,UACP,IAAI,SACH,GACA,QACA,OACD,EACA,OACD,CACD,EACC,MAAO,OAAO,CACf,aAAa,GAAI,MAAK,IAGxB,KAAK,CAAC,GAA0B,CAC/B,GAAI,CACH,gBACC,GACA,QAAQ,QACP,IAAI,SAAS,GAAI,OAAc,CAChC,CACD,EACC,MAAO,OAAO,CACf,aAAa,GAAI,MAAK,IAGxB,KAAK,CACJ,GACA,KACA,OACC,CACD,GAAI,CACH,gBACC,GACA,QAAQ,QACP,IAAI,SAAS,GAAI,OAAc,EAC/B,KACA,MACD,CACD,EACC,MAAO,OAAO,CACf,aAAa,GAAI,MAAK,GAGzB,CACD,CAAC,EAED,OAGD,OADA,KAAI,OAAS,IACN,mCAER,IACI,KACH,UAAW,OACZ,CACD,EAEF,EC5kBO,IAAM,KAAM,MAChB,IAAI,IACJ,OAAO,UAAY,aAAe,SAAS,IAC1C,QAAQ,IACR,CAAC,ECJL,0DA8BA,IAAM,oBAAsB,CAC3B,YACA,MACI,CACJ,QAAY,IAAK,aAAc,OAAO,QAErC,YAAY,OAAO,UACpB,EAEC,IAAI,OAAS,UAAU,SAIZ,qBAAuB,CAAC,MAAmB,CACvD,IAAQ,yBAAa,oCAAqB,IAAI,YAAY,QAE1D,MAAO,OAAO,UAAwC,CACrD,IAAM,IAAM,QAAQ,IACnB,EAAI,IAAI,QAAQ,IAAK,EAAE,EACvB,GAAK,IAAI,QAAQ,IAAK,EAAI,CAAC,EAC3B,KAAO,KAAO,GAAK,IAAI,UAAU,CAAC,EAAI,IAAI,UAAU,EAAG,EAAE,EAEpD,KAAsB,CAC3B,OAAQ,CAAC,EACT,OAAQ,IACR,QAAS,CAAC,CACX,EAEM,QAAU,OAAO,OACtB,CAAC,EAED,IAAI,UAAU,UACd,CACC,SAEA,MAAO,IAAI,UAAU,MACrB,QACA,KACA,GACA,MAAO,OACP,OACA,QACD,CACD,EAIA,GAAI,CACH,GAAI,IAAI,MAAM,QACb,QAAS,EAAI,EAAG,EAAI,IAAI,MAAM,QAAQ,OAAQ,IAAK,CAClD,IAAM,UAAY,IAAI,MAAM,QAAQ,GAAG,GACnC,UAAW,UAAU,OAAc,EACvC,GAAI,qBAAoB,QAAS,UAAW,MAAM,UAGlD,GADA,UAAW,kBAAiB,UAAU,IAAG,EACrC,UAAU,OAAQ,QAAQ,SAAW,UAG3C,IAAM,QACL,IAAI,OAAO,QAAQ,KAAK,QAAQ,OAAQ,IAAI,GAC5C,IAAI,OAAO,QAAQ,KAAK,MAAO,IAAI,EAEpC,IAAK,QAAS,MAAM,IAAI,cAExB,IAAQ,OAAQ,MAAO,UAAW,QAAS,OAAU,QAAQ,MAEzD,KACJ,GAAI,QAAQ,SAAW,OAAS,QAAQ,SAAW,OAClD,GAAI,QACH,OAAQ,aACF,mBACJ,KAAQ,MAAM,QAAQ,KAAK,EAC3B,UAEI,aACJ,KAAO,MAAM,QAAQ,KAAK,EAC1B,UAEI,oCACJ,KAAO,WAAW,MAAM,QAAQ,KAAK,CAAC,EACtC,UAEI,2BACJ,KAAO,MAAM,QAAQ,YAAY,EACjC,UAEI,sBACJ,KAAO,CAAC,EAER,IAAM,MAAO,MAAM,QAAQ,SAAS,EACpC,QAAW,OAAO,MAAK,KAAK,EAAG,CAC9B,GAAI,KAAK,KAAM,SAEf,IAAM,MAAQ,MAAK,OAAO,GAAG,EAC7B,GAAI,MAAM,SAAW,EAAG,KAAK,KAAO,MAAM,GACrC,UAAK,KAAO,MAGlB,MAEI,KACN,IAAI,YAAc,QAAQ,QAAQ,IAAI,cAAc,EAEpD,GAAI,YAAa,CAChB,IAAM,MAAQ,YAAY,QAAQ,GAAG,EACrC,GAAI,QAAU,GACb,YAAc,YAAY,MAAM,EAAG,KAAK,EAKzC,GAFA,QAAQ,YAAc,YAElB,MAAM,MACT,QAAS,EAAI,EAAG,EAAI,MAAM,MAAM,OAAQ,IAAK,CAC5C,IAAM,KAAO,MAAM,MAAM,GAAG,GACxB,KAAO,KAAK,QAAgB,WAAW,EAC3C,GAAI,gBAAgB,QAAS,KAAO,MAAM,KAE1C,GAAI,KAAM,CACT,KAAO,KACP,OAQH,GAHA,OAAO,QAAQ,YAGX,OAAS,OACZ,OAAQ,iBACF,mBACJ,KAAQ,MAAM,QAAQ,KAAK,EAC3B,UAEI,aACJ,KAAO,MAAM,QAAQ,KAAK,EAC1B,UAEI,oCACJ,KAAO,WAAW,MAAM,QAAQ,KAAK,CAAC,EACtC,UAEI,2BACJ,KAAO,MAAM,QAAQ,YAAY,EACjC,UAEI,sBACJ,KAAO,CAAC,EAER,IAAM,MAAO,MAAM,QAAQ,SAAS,EACpC,QAAW,OAAO,MAAK,KAAK,EAAG,CAC9B,GAAI,KAAK,KAAM,SAEf,IAAM,MAAQ,MAAK,OAAO,GAAG,EAC7B,GAAI,MAAM,SAAW,EACpB,KAAK,KAAO,MAAM,GACd,UAAK,KAAO,MAGlB,QAON,QAAQ,MAAQ,MAChB,QAAQ,KAAO,KACf,QAAQ,OAAS,SAAS,QAAU,OAGpC,QAAQ,MAAQ,KAAO,GAAK,CAAC,EAAI,WAAW,IAAI,UAAU,GAAK,CAAC,CAAC,EAEjE,QAAQ,QAAU,CAAC,EACnB,QAAY,IAAK,SAAU,QAAQ,QAAQ,QAAQ,EAClD,QAAQ,QAAQ,KAAO,MAExB,IAAM,WAAa,OAAO,OACzB,CAAC,EACD,IAAI,QAAQ,OACZ,WAAW,QAAQ,MACpB,EAMM,kBAAoB,QAAQ,QAAQ,IAAI,QAAQ,EAEtD,QAAQ,OAAU,MAAM,YACvB,QAAQ,IACR,kBACA,WACG,CACA,QACC,WAAW,UAAY,OACpB,OAAO,WAAW,UAAY,SAC7B,WAAW,QACX,WAAW,QAAQ,KAAK,GAAG,EAC5B,OACJ,KACC,WAAW,OAAS,GACjB,GACA,WAAW,OAAS,OACnB,OAAO,WAAW,OAAS,SAC1B,WAAW,KACX,WAAW,KAAK,KAAK,GAAG,EACzB,MACN,EACC,MACJ,EAEA,IAAM,gBAAkB,WAAW,gBAAgB,EACnD,GAAI,gBACH,oBAAoB,gBAAiB,QAAQ,OAAO,EAErD,IAAM,gBAAkB,WAAW,eAAe,EAClD,GAAI,gBACH,oBAAoB,gBAAiB,QAAQ,MAAM,EAEpD,IAAM,eAAiB,WAAW,cAAc,EAChD,GAAI,eACH,oBAAoB,eAAgB,QAAQ,KAAK,EAElD,GAAI,MAAM,UACT,QAAS,EAAI,EAAG,EAAI,MAAM,UAAU,OAAQ,IAAK,CAChD,IAAM,KAAO,MAAM,UAAU,GACvB,UAAY,KAAK,GAAG,OAAO,EAEjC,GAAI,KAAK,UAAY,SACpB,GAAI,qBAAqB,QACxB,OAAO,OAAO,QAAS,MAAM,SAAS,EAClC,YAAO,OAAO,QAAS,SAAS,EAC/B,QAAI,qBAAqB,QAAS,MAAM,UAGjD,GAAI,UAAW,CACd,GAAI,gBAAiB,CACpB,IAAM,QAAU,gBAAgB,QAAQ,OAAO,EAC/C,QAAY,IAAK,SAAU,QAAQ,QAClC,QAAQ,KAAO,MAEhB,GAAI,UAAU,QAAS,MAAM,OAAO,IAAM,GACzC,MAAM,IAAI,gBACT,SACA,UAAU,QACV,OACD,EACK,QAAI,UAAU,SAAS,OAE7B,QAAQ,QAAU,UAAU,QAAQ,OAAO,QAAQ,OAAO,EAE3D,GAAI,iBAAiB,MAAM,QAAQ,MAAM,IAAM,GAC9C,MAAM,IAAI,gBACT,SACA,UAAU,OACV,QAAQ,MACT,EACM,QAAI,UAAU,QAAQ,OAE5B,QAAQ,OAAS,UAAU,OAAO,OAAO,QAAQ,MAAM,EAExD,GAAI,gBAAgB,MAAM,QAAQ,KAAK,IAAM,GAC5C,MAAM,IAAI,gBACT,QACA,UAAU,MACV,QAAQ,KACT,EACI,QAAI,UAAU,OAAO,OACzB,QAAQ,MAAQ,UAAU,MAAM,OAAO,QAAQ,KAAK,EAErD,GAAI,UAAU,eAAe,EAAG,CAC/B,IAAI,YAAuC,CAAC,EAC5C,QAAY,IAAK,SAAU,OAAO,QAAQ,QAAQ,MAAM,EACvD,YAAY,KAAO,MAAM,MAE1B,GAAI,UAAU,OAAQ,MAAM,WAAW,IAAM,GAC5C,MAAM,IAAI,gBACT,SACA,UAAU,OACV,WACD,EACI,QAAI,UAAU,QAAQ,OAC1B,YAAc,UAAU,OAAO,OAC9B,WACD,EAGF,GAAI,UAAU,aAAa,GAAG,MAAM,IAAI,IAAM,GAC7C,MAAM,IAAI,gBAAgB,OAAQ,UAAU,KAAO,IAAI,EACnD,QAAI,UAAU,MAAM,OACxB,QAAQ,KAAO,UAAU,KAAK,OAAO,IAAI,EAG3C,GAAI,MAAM,aACT,QAAS,EAAI,EAAG,EAAI,MAAM,aAAa,OAAQ,IAAK,CACnD,IAAM,KAAO,MAAM,aAAa,GAC5B,UAAW,KAAK,GAAG,OAAO,EAE9B,GAAI,KAAK,UAAY,UAAW,CAC/B,GAAI,qBAAoB,2BAA4B,CACnD,IAAM,OAAS,kBACd,UACA,QAAQ,GACT,EACA,GAAI,OACH,OAAQ,QAAQ,SAAW,OAE7B,GAAI,qBAAoB,QACvB,OAAO,OAAO,QAAS,MAAM,SAAQ,EACjC,YAAO,OAAO,QAAS,SAAQ,EAEpC,SACM,QAAI,qBAAoB,QAC9B,UAAW,MAAM,UAGlB,GAAI,YAAa,OAAW,CAO3B,GALC,QAGC,SAAW,UAET,MAAM,YACT,QAAS,GAAI,EAAG,GAAI,MAAM,YAAY,OAAQ,KAAK,CAClD,IAAI,YAAc,MAAM,YAAY,IAAG,GACtC,OAGD,EACA,GAAI,uBAAuB,QAC1B,YAAc,MAAM,YAErB,GAAI,YAAa,UAAW,YAG9B,IAAM,OAAS,kBAAiB,UAAU,QAAQ,GAAG,EAErD,GAAI,OAAQ,OAAQ,QAAQ,SAAW,QAI1C,IAAI,SACH,OAAO,SAAW,WAAa,OAAO,OAAO,EAAI,OAClD,GAAI,oBAAoB,QAAS,SAAW,MAAM,SAElD,GAAI,MAAM,YACT,IAAK,MAAM,YAAY,OAAQ,CAC9B,IAAM,QACL,oBAAoB,2BACjB,SAAS,KACT,KAAI,OACH,OAAO,KAAI,SAAW,SACrB,UAAU,KAAI,QACd,KAAI,OACL,IAEC,kBACL,WAAW,iBAAiB,IAAI,SAEjC,GAAI,mBAAmB,MAAM,QAAQ,IAAM,GAC1C,MAAM,IAAI,gBACT,WACA,kBACA,QACD,EACI,QAAI,mBAAmB,OAC3B,SAAW,kBAAkB,OAAO,QAAQ,EACvC,KAEL,QAGC,SAAW,SAEb,QAAS,EAAI,EAAG,EAAI,MAAM,YAAY,OAAQ,IAAK,CAClD,IAAI,YAAc,MAAM,YAAY,GAAG,GACtC,OAGD,EACA,GAAI,uBAAuB,QAC1B,YAAc,MAAM,YAErB,IAAM,OAAS,kBACd,YACA,QAAQ,GACT,EACA,GAAI,SAAW,OAAW,CACzB,IAAM,kBAEL,WAAW,WAAW,OAAO,QAE9B,GAAI,mBAAmB,MAAM,MAAM,IAAM,GACxC,MAAM,IAAI,gBACT,WACA,kBACA,MACD,EACI,QAAI,mBAAmB,OAC3B,SAAW,kBAAkB,OAAO,QAAQ,EAG7C,OAAQ,QAAQ,SAAW,SAK/B,GAAI,QAAQ,IAAI,QAAU,YAAY,KAAM,CAC3C,IAAM,QAAU,WAAW,QACxB,OACA,OAAO,WAAW,UAAY,SAC7B,WAAW,QACX,WAAW,QAAQ,GAEvB,GAAI,WAAW,OAAS,GACvB,QAAY,IAAK,UAAW,OAAO,QAClC,QAAQ,IAAI,MACb,EACC,QAAQ,IAAI,OAAO,KAAK,MAAQ,MAAM,WACrC,OAAO,MACP,WACD,EACG,KACJ,IAAM,WAAa,WAAW,QAAQ,QAAQ,WAE9C,QAAW,QAAQ,WAAW,KAAM,CACnC,KAAM,QAAQ,YAAa,SAE3B,GAAI,QAAQ,IAAI,OAAO,OAAO,MAC7B,QAAQ,IAAI,OAAO,MAAM,MAAQ,MAAM,WACtC,QAAQ,IAAI,OAAO,MAAM,MACzB,MACD,IAOJ,OAAO,aAAa,QAAQ,SAAW,SAAW,QAAQ,GAAG,EAC5D,MAAO,OAAO,CACf,IAAM,cACL,kBAAiB,sBAAwB,OAAM,MAC5C,OAAM,MACN,OAOJ,OAAO,IAAI,YAAY,QAAS,aAAa,SAC5C,CACD,GAAI,IAAI,MAAM,cACb,QAAW,iBAAiB,IAAI,MAAM,cACrC,MAAM,cAAc,GAAG,OAAc,KAK7B,0BAA4B,CAAC,MAAmB,CAC5D,IAAQ,0BAAgB,IAAI,YAAY,QAExC,MAAO,OACN,QAGA,SACI,CACJ,IAAM,aAAe,OAAO,OAAO,QAAS,CAAE,aAAO,KAAM,OAAM,IAAK,CAAC,EAGvE,GAFA,aAAa,IAAM,QAAQ,IAEvB,IAAI,MAAM,MACb,QAAS,EAAI,EAAG,EAAI,IAAI,MAAM,MAAM,OAAQ,IAAK,CAEhD,IAAI,SADS,IAAI,MAAM,MAAM,GACT,GAAG,YAAmB,EAC1C,GAAI,oBAAoB,QAAS,SAAW,MAAM,SAClD,GAAI,WAAa,QAAa,WAAa,KAC1C,OAAQ,QAAQ,SAAW,aAC1B,SACA,QAAQ,GACT,EAGH,OAAO,IAAI,SACV,OAAO,OAAM,QAAU,SAAW,OAAM,MAAQ,OAAM,QACtD,CACC,QAAS,QAAQ,IAAI,QACrB,OAAQ,OAAM,QAAU,GACzB,CACD,IxBunMF,2BAAS,iDAn9MT,MAAqB,MAkCnB,CACD,OAEA,OAAwB,KAChB,aAAgD,CAAC,EAEzD,UAAY,GACZ,aAAe,KACf,eAAiB,KACjB,YAAc,KACd,aAAe,KACf,YAAc,KACd,UAAY,KAEF,UAAY,CACrB,UAAW,CAAC,EACZ,MAAO,CAAC,EACR,OAAQ,CAAC,EACT,QAAS,CAAC,CACX,KAEI,MAAK,EAAuB,CAC/B,OAAO,KAAK,UAAU,SAGnB,UAAS,EAA2B,CACvC,OAAO,KAAK,UAAU,UAGb,YAAc,CACvB,QAAS,EAAE,OAAO,CAAC,CAAC,EACpB,KAAM,CAAC,EACP,MAAO,CAAC,CACT,EAEU,SAAW,CACpB,OAAsB,CAAC,EACvB,qBAA4D,CAAC,CAC9D,EAEU,UAA4B,CACrC,OAAQ,KACR,OAAQ,KACR,MAAO,KACP,YAAY,EAAG,CACd,OAAO,qBACN,qBAAqB,KAAK,OAAQ,KAAK,MAAM,EAC7C,KAAK,KACN,EAEF,EAEU,oBAA2C,CACpD,OAAQ,KACR,OAAQ,KACR,MAAO,IACR,EAEA,MAAiC,CAAC,EAExB,UAMV,OAAS,CACR,QAAS,UAML,KAAI,EAAG,CACV,IAAK,KAAK,SAAU,KAAK,SAAW,IAAI,EAAU,CAAE,KAAM,EAAK,CAAC,EAEhE,OAAO,KAAK,UAEb,WAAY,UAER,QAAO,EAAG,CACb,IAAK,KAAK,YAAa,KAAK,YAAc,IAAI,EAE9C,OAAO,KAAK,aAGb,OAAQ,CAAC,EAET,SAAU,CAAC,EAKX,QAAS,CAAC,CACX,EAEU,UAAoC,CAAC,KAE3C,OAAM,EAAoB,CAC7B,OAAO,KAAK,OAAO,QAGV,eAAe,EAAoB,CAC5C,OAAO,KAAK,OAAO,QAGV,oBAAoB,EAAG,CAChC,OAAO,KAAK,YAGH,UAA+B,CACxC,KAAM,GACN,OAAQ,GACR,QAAS,GACT,MAAO,GACP,IAAK,GACL,OAAQ,GACR,KAAM,GACN,MAAO,GACP,IAAK,EACN,EAEQ,SAAS,EAAG,CACnB,OAAO,KAAK,OAGL,SAAS,EAAkB,CAClC,OAAO,KAGR,UAAsD,CAAC,EAE/C,oBACI,gBAAe,EAAG,CAC7B,IAAK,KAAK,iBACT,KAAK,iBAAmB,IAAI,aAAa,QAAQ,MAAO,IAAM,EAE7D,EAEF,OAAO,KAAK,iBAGb,WAAW,CAAC,OAAiC,CAAC,EAAG,CAChD,GAAI,OAAO,KACV,IAAK,OAAO,OACX,OAAO,OAAS,CACf,KAAM,OAAO,IACd,EACI,YAAO,OAAO,KAAO,OAAO,KAuBlC,GApBA,KAAK,OAAS,CACb,OAAQ,GACR,IAAK,KAAI,aAAe,QACxB,qBAAsB,GACtB,aAAc,GACd,aAAc,GACd,UAAW,MACR,OACH,OAAQ,CACP,KAAM,OACH,QAAQ,MACZ,EACA,aAAc,QAAQ,cAAgB,CAAC,EACvC,KAAM,QAAQ,OAAS,OAAY,GAAK,QAAQ,IACjD,EAEA,KAAK,YACJ,OAAO,UACN,OAAO,MAAQ,YAAc,WAAa,oBAExC,QAAQ,WAAa,QAAQ,MAAQ,QAAQ,OAAS,QACzD,KAAK,UAAY,CAChB,MAAO,IAAI,MAAM,EAAE,KACpB,EAGF,WAEA,GAAG,CAAC,MAAqB,KAAO,KAAK,CASpC,GARkB,mBAAmB,MAAO,CAC3C,QAAS,KAAK,YAAY,QAC1B,QAAS,GACT,qBAAsB,GACtB,OAAQ,GACR,SAAU,IAAM,KAAK,OAAO,QAC7B,CAAC,EAEa,MAAM,IAAI,IAAM,GAAO,CACpC,IAAM,OAAQ,IAAI,gBAAgB,MAAO,MAAO,IAAI,EAEpD,MAAM,IAAI,MAAM,OAAM,IAAI,IAAI,CAAC,IAAM,EAAE,OAAO,EAAE,KAAK;AAAA,CAAI,CAAC,EAG3D,OAAO,KAUR,IAAI,CAAC,GAAyB,CAY7B,OAXA,KAAK,SAAS,qBAAqB,KAAK,CACvC,SAAU,SACT,KAAK,UAAU,CACd,KAAM,KAAK,OAAO,KAClB,KAAM,KAAK,OAAO,KAClB,QAAS,GAAG,SAAS,CACtB,CAAC,CACF,EACA,EACD,CAAC,EAEM,KAGA,UAAU,CAAC,UAAyB,CAC3C,GAAI,KAAK,SAAS,OAAO,OAAQ,CAChC,IAAM,OAAS,mBAAmB,CACjC,WAAY,KAAK,MACjB,SACD,CAAC,EAEK,QAAwB,CAC7B,OAAQ,CACP,OAAQ,KAAK,MACb,MAAO,SACR,KACI,QAAO,EAAG,CACb,OAAO,OAAO,OAAO,MAElB,YAAW,EAAG,CACjB,OAAO,OAAO,WAAW,MAEtB,eAAc,EAAG,CACpB,OAAO,OAAO,cAAc,MAEzB,cAAa,EAAG,CACnB,OAAO,OAAO,aAAa,MAExB,YAAW,EAAG,CACjB,OAAO,OAAO,aAAa,MAExB,gBAAe,EAAG,CACrB,OAAO,OAAO,eAAe,MAE1B,QAAO,EAAG,CACb,OAAO,OAAO,OAAO,EAEvB,EAEA,QAAW,SAAS,KAAK,SAAS,OACjC,eAAe,MAAM,GAAG,OAAO,EAAG,UAAW,MAAM,MAIlD,OAAM,EAMR,CACD,IAAM,OAAmD,CAAC,EAE1D,QAAW,QAAQ,OAAO,KAAK,KAAK,YAAY,IAAI,EACnD,OAAO,MAAQ,mBACd,KAAK,YAAY,QAAQ,OAAO,IAAa,CAC9C,EAKD,OAFA,OAAO,QAAU,KAAK,YAAY,QAE3B,OAGA,GAAG,CACV,OACA,KACA,OACA,UACA,QAIA,qBACC,CACD,IAAM,WAAa,SAAS,YAAc,GACpC,UAAY,SAAS,WAAa,GAIxC,GAFA,YAAc,CAAC,EAEX,uBAAyB,OAAW,CAGvC,GAFA,qBAAuB,CAAC,EAEpB,KAAK,oBAAoB,MAC5B,qBAAuB,qBAAqB,OAC3C,KAAK,oBAAoB,KAC1B,EAED,GAAI,KAAK,oBAAoB,OAC5B,qBAAuB,qBAAqB,OAC3C,KAAK,oBAAoB,MAC1B,EAED,GAAI,KAAK,oBAAoB,OAC5B,qBAAuB,qBAAqB,OAC3C,KAAK,oBAAoB,MAC1B,EAGF,GAAI,OAAS,IAAM,KAAK,WAAW,CAAC,IAAM,GAAI,KAAO,IAAM,KAC3D,GAAI,KAAK,OAAO,SAAW,WAAY,KAAO,KAAK,OAAO,OAAS,KAEnE,GAAI,WAAW,KACd,OAAQ,UAAU,UACZ,OACJ,UAAU,KAAO,aACjB,UAEI,OACJ,UAAU,KAAO,mBACjB,UAEI,WACJ,UAAU,KAAO,sBACjB,UAEI,aACJ,UAAU,KAAO,oCACjB,UAEI,cACJ,UAAU,KAAO,2BACjB,cAGA,MAGH,IAAM,kBAAoB,KAAK,UAAU,aAAa,EAEhD,OAAS,CACd,KAAM,WAAW,MAAS,mBAAmB,KAC7C,QAAS,WAAW,SAAY,mBAAmB,QACnD,OAAQ,WAAW,QAAW,mBAAmB,OACjD,MAAO,WAAW,OAAU,mBAAmB,MAC/C,OAAQ,WAAW,QAAW,mBAAmB,OACjD,SACC,WAAW,UAAa,mBAAmB,QAC7C,EAEM,iBACL,KAAK,OAAO,aAAe,IAC1B,OAAO,KAAK,OAAO,aAAe,UAClC,KAAK,OAAO,WAAW,UAAY,GAE/B,gBAAkB,IAAM,CAC7B,IAAM,OAAS,KAAK,YAAY,KAC1B,SAAW,KAAK,OAAO,IAEvB,UAAY,KAAK,OAAO,UACxB,QAAU,KAAK,YAAY,QAE3B,UAAW,IAAM,KAAK,OAAO,SAE7B,gBAAkB,IAAM,CAC7B,GAAI,OAAO,QAAU,qBAAqB,KAAK,CAAC,IAAM,EAAE,MAAM,EAC7D,OAAO,mBAAmB,CACzB,QACA,UAAW,OAAO,OAClB,cAAe,KAAK,OAAO,OAC3B,OAAQ,OAAO,QAAQ,QAAU,CAAC,EAClC,QACA,OACA,WAAY,qBAAqB,IAAI,CAAC,IAAM,EAAE,MAAM,EACpD,kBACD,CAAC,GAGH,OAAO,iBACJ,CACA,KAAM,mBAAmB,OAAO,KAAM,CACrC,QACA,QACA,OACA,UACA,iBAAkB,oBAAoB,EACtC,WAAY,qBAAqB,IAAI,CAAC,IAAM,EAAE,IAAI,EAClD,kBACD,CAAC,EACD,QAAS,mBAAmB,OAAO,QAAS,CAC3C,QACA,QACA,OACA,qBAAsB,GACtB,OAAQ,GACR,iBAAkB,2BAA2B,EAC7C,WAAY,qBAAqB,IAChC,CAAC,IAAM,EAAE,OACV,EACA,kBACD,CAAC,EACD,OAAQ,mBAAmB,OAAO,OAAQ,CACzC,QACA,QACA,OACA,OAAQ,GACR,iBAAkB,2BAA2B,EAC7C,WAAY,qBAAqB,IAChC,CAAC,IAAM,EAAE,MACV,EACA,kBACD,CAAC,EACD,MAAO,mBAAmB,OAAO,MAAO,CACvC,QACA,QACA,OACA,UACA,OAAQ,GACR,iBAAkB,2BAA2B,EAC7C,WAAY,qBAAqB,IAChC,CAAC,IAAM,EAAE,KACV,EACA,kBACD,CAAC,EACD,OAAQ,gBAAgB,EACxB,SAAU,2BAA2B,OAAO,SAAU,CACrD,QACA,QACA,OACA,UACA,WAAY,qBAAqB,IAChC,CAAC,IAAM,EAAE,QACV,EACA,kBACD,CAAC,CACF,EACE,CACD,UAAU,EAAG,CACZ,GAAI,KAAK,KAAM,OAAO,KAAK,KAE3B,OAAQ,KAAK,KAAO,mBACnB,OAAO,KACP,CACC,QACA,QACA,OACA,UACA,iBAAkB,oBAAoB,EACtC,WAAY,qBAAqB,IAChC,CAAC,IAAM,EAAE,IACV,EACA,kBACD,CACD,GAED,aAAa,EAAG,CACf,GAAI,KAAK,QAAS,OAAO,KAAK,QAE9B,OAAQ,KAAK,QAAU,mBACtB,OAAO,QACP,CACC,QACA,QACA,OACA,sBAAuB,UACvB,OAAQ,GACR,iBACC,2BAA2B,EAC5B,WAAY,qBAAqB,IAChC,CAAC,IAAM,EAAE,OACV,EACA,kBACD,CACD,GAED,YAAY,EAAG,CACd,GAAI,KAAK,OAAQ,OAAO,KAAK,OAE7B,OAAQ,KAAK,OAAS,mBACrB,OAAO,OACP,CACC,QACA,QACA,OACA,OAAQ,GACR,iBACC,2BAA2B,EAC5B,WAAY,qBAAqB,IAChC,CAAC,IAAM,EAAE,MACV,EACA,kBACD,CACD,GAED,WAAW,EAAG,CACb,GAAI,KAAK,MAAO,OAAO,KAAK,MAE5B,OAAQ,KAAK,MAAQ,mBACpB,OAAO,MACP,CACC,QACA,QACA,OACA,OAAQ,GACR,iBACC,2BAA2B,EAC5B,WAAY,qBAAqB,IAChC,CAAC,IAAM,EAAE,KACV,EACA,kBACD,CACD,GAED,YAAY,EAAG,CACd,GAAI,KAAK,OAAQ,OAAO,KAAK,OAE7B,OAAQ,KAAK,OAAS,gBAAgB,GAEvC,cAAc,EAAG,CAChB,GAAI,KAAK,SAAU,OAAO,KAAK,SAE/B,OAAQ,KAAK,SAAW,2BACvB,OAAO,SACP,CACC,QACA,QACA,OACA,UACA,WAAY,qBAAqB,IAChC,CAAC,IAAM,EAAE,QACV,EACA,kBACD,CACD,EAEF,GAGH,GACC,kBAAkB,MAClB,kBAAkB,QAClB,kBAAkB,SAClB,kBAAkB,QAClB,kBAAkB,OAClB,kBAAkB,SAElB,UAAY,UAAU,UAAW,iBAAiB,EAEnD,GAAI,UAAU,KACb,IAAK,UAAU,OACd,UAAU,OAAS,CAClB,KAAM,UAAU,IACjB,EACI,eAAU,OAAO,KAAO,UAAU,KAGxC,GAAI,WAAW,KAAK,OAAO,MAAM,EAChC,UAAU,OAAS,UAClB,OAAO,OAAO,CAAC,EAAG,KAAK,OAAO,MAAO,EACrC,UAAU,MACX,EAED,KAAK,WAAW,SAAS,EAEzB,IAAM,MAAQ,WAAW,KAAK,KAAK,EAChC,UAAU,KAAK,MAAO,0BAA0B,SAAS,CAAC,EAC1D,iBAAiB,0BAA0B,SAAS,CAAC,EAExD,GAAI,KAAK,OAAO,MAAQ,GAAO,CAC9B,IAAM,UAAY,gBAAgB,EAElC,KAAK,OAAO,QAAQ,IAAI,OAAQ,KAAM,CACrC,UACA,MACA,QAAS,WAAW,KACpB,OACA,MAAO,IACR,CAAC,EAED,IAAM,QAAU,WAAW,KAAM,CAAE,QAAS,EAAK,CAAC,EAClD,GAAI,OAAS,QACZ,KAAK,OAAO,QAAQ,IAAI,OAAQ,QAAS,CACxC,UACA,MACA,QAAS,WAAW,KACpB,OACA,MAAO,IACR,CAAC,EAGF,GAAI,KAAK,OAAO,aAAe,GAAO,CACrC,IAAM,UAAY,aAAa,IAAI,EACnC,KAAK,OAAO,QAAQ,IAAI,OAAQ,UAAW,CAC1C,UACA,MACA,QAAS,WAAW,KACpB,OACA,MAAO,IACR,CAAC,EAED,IAAM,SAAU,WAAW,SAAS,EACpC,GAAI,YAAc,SACjB,KAAK,OAAO,QAAQ,IAAI,OAAQ,UAAW,CAC1C,UACA,MACA,QAAS,WAAW,KACpB,OACA,MAAO,IACR,CAAC,EAGH,KAAK,OAAO,QAAQ,KAAK,CACxB,OACA,KACA,SAAU,KACV,QAAS,OACT,QAAS,OACT,MACA,oBACD,CAAC,EAED,OAGD,IAAM,QAAU,KAAK,YAAY,QAE3B,oBACL,OAAO,SAAW,WACf,IAAM,CACN,IAAM,GAAK,QAAQ,4BAClB,OACA,MACA,KAAK,UACN,EAEA,OAAO,cAAc,QAClB,GAAG,KAAK,CAAC,MAAO,CAChB,GAAI,IAAI,OAAO,IACf,EACA,KAAK,GAER,OAEE,wBACL,KAAK,OAAO,uBAAyB,GAEhC,gBAAkB,CAAC,QAAiB,CACzC,IAAK,0BAA4B,oBAAqB,OAEtD,GAAI,8BACH,GAAI,KAAK,OAAO,SAAS,OAExB,KAAK,OAAO,SAAS,OAAO,QAAU,oBAAoB,EAE1D,UAAK,OAAO,SAAS,OAAQ,EAC3B,QAAS,oBAAoB,CAC/B,EAED,UAAK,OAAO,SAAS,OAAQ,oBAAoB,GAInD,gBAAgB,IAAI,EAEpB,IAAI,UACE,SAAU,IAAM,CACrB,GAAI,UAAW,OAAO,UAEtB,OAAQ,UAAY,eAAe,CAClC,IAAK,KACL,KACA,OACA,MACA,UAAW,gBAAgB,EAC3B,QACC,OAAO,SAAW,YAClB,OAAO,QAAQ,sBAAwB,WACpC,IAAM,OACN,OACJ,UACA,UAAW,KAAK,SACjB,CAAC,GAGE,SACJ,GAAI,GAAG,UAAU,SAAU,KAAK,UAC/B,QAAS,EAAI,EAAG,EAAI,KAAK,OAAO,QAAQ,OAAQ,IAAK,CACpD,IAAM,MAAQ,KAAK,OAAO,QAAQ,GAClC,GAAI,MAAM,OAAS,MAAQ,MAAM,SAAW,OAAQ,CACnD,SAAW,EACX,OAGE,UAAK,UAAU,GAAG,UAAU,QAAU,KAAK,OAAO,QAAQ,OAE/D,IAAM,MAAQ,UAAY,KAAK,OAAO,QAAQ,OAExC,YAAc,iBACjB,SAAQ,EACR,CAAC,OAEC,KAAK,OAAO,QAAQ,OAAO,SAC3B,SAAS,GACT,GAAG,EAER,GAAI,WAAa,OAChB,KAAK,OAAO,QAAQ,UAAY,OAAO,OACtC,CACC,OACA,KACA,SAAU,YACV,QAAS,SACT,QAAS,OACT,KACD,EACA,qBAAqB,OAClB,CACA,oBACD,EACC,OACH,UAAU,UACP,CAAE,UAAW,UAAU,SAAiB,EACxC,MACJ,EAEA,UAAK,OAAO,QAAQ,KACnB,OAAO,OACN,CACC,OACA,KACA,SAAU,YACV,QAAS,SACT,QAAS,OACT,KACD,EACA,qBAAqB,OAClB,CACA,oBACD,EACC,OACH,UAAU,UACP,CAAE,UAAW,UAAU,SAAiB,EACxC,MACJ,CACD,EAED,IAAM,QAAU,CACf,QAAS,iBAAmB,YAAc,OAC1C,OAAO,EAAG,CACT,OAAQ,KAAK,QAAU,SAAS,EAElC,EAEM,aAAe,KAAK,OAAO,OAC3B,aACL,KAAK,QAAQ,GAAG,IAAM,IAAM,KAAK,QAAQ,GAAG,IAAM,GAEnD,GAAI,SAAW,KAAM,CACpB,GAAI,aAAc,CACjB,GAAI,QAAQ,aAAc,aAAa,MAAM,QAAU,MAEtD,kBAAa,MAAQ,EACnB,QAAS,KACX,EAED,OAKD,GAFA,KAAK,OAAO,KAAK,IAAI,KAAM,KAAM,OAAO,GAEnC,KAAK,OAAO,WAChB,KAAK,OAAO,KAAK,IAAI,KAAM,aAAa,IAAI,EAAG,OAAO,EAEvD,IAAM,QAAU,WAAW,KAAM,CAAE,QAAS,EAAK,CAAC,EAClD,GAAI,OAAS,QAAS,KAAK,OAAO,KAAK,IAAI,KAAM,QAAS,OAAO,EAIjE,OAGD,GAAI,aAAc,CACjB,GAAI,QAAQ,aAAc,aAAa,MAAM,QAAU,MAEtD,kBAAa,MAAQ,EACnB,QAAS,KACX,EAED,IAAK,KAAK,OAAO,WAAY,gBAAgB,aAAa,IAAI,CAAC,EAGzD,KACN,KAAK,OAAO,KAAK,IAAI,OAAQ,KAAM,OAAO,EAE1C,IAAM,cACL,OAAO,SAAW,YAClB,OAAO,QAAQ,sBAAwB,WACpC,QAAQ,oBACR,OACA,MACA,KAAK,UACN,EACC,OAEJ,IAAK,KAAK,OAAO,WAAY,CAC5B,IAAM,UAAY,aAAa,IAAI,EAEnC,gBAAgB,SAAS,EACzB,KAAK,OAAO,KAAK,IAAI,OAAQ,UAAW,OAAO,EAGhD,IAAM,QAAU,WAAW,KAAM,CAAE,QAAS,EAAK,CAAC,EAClD,GAAI,OAAS,QACZ,KAAK,OAAO,KAAK,IAAI,OAAQ,QAAS,OAAO,EAE7C,gBAAgB,OAAO,GAKlB,WACR,OAAO,CAAC,OAA+C,CACtD,IAAK,OAAQ,OAAO,KAEpB,IAAK,KAAK,WAAY,KAAK,WAAa,CAAC,EAIzC,OAFA,KAAK,WAAa,UAAU,KAAK,WAAY,MAAM,EAE5C,KAiBR,OAAO,CAAC,QAA4C,CAGnD,OAFA,KAAK,GAAG,QAAS,OAAc,EAExB,KAgBR,SAA2C,CAC1C,QAiBC,CAGD,OAFA,KAAK,GAAG,UAAW,OAAc,EAE1B,KAoHR,OAAO,CACN,QACA,QACU,CACV,IAAK,QAAS,CACb,GAAI,OAAO,UAAY,SACtB,OAAO,KAAK,GAAG,QAAS,KAAK,WAAW,QAAe,EAExD,OAAO,KAAK,GAAG,QAAS,OAAc,EAGvC,OAAO,KAAK,GACX,QACA,QACA,OACD,EAsBD,MAqBC,CACA,KACA,OAeC,CAGD,OAFA,KAAK,WAAW,MAAQ,OAEjB,KAyGR,WAAW,CACV,QACA,QACC,CACD,IAAK,QAAS,OAAO,KAAK,GAAG,YAAa,OAAc,EAExD,OAAO,KAAK,GACX,QACA,YACA,OACD,EA4KD,OAAO,CACN,iBACA,QACC,CACD,IAAK,QACJ,QAAU,iBACV,iBAAmB,CAAE,GAAI,OAAQ,EAGlC,IAAM,KAAsB,CAC3B,QAAS,UACT,GAAI,OACL,EAEA,OAAO,KAAK,eAAe,iBAAyB,IAAW,EA6HhE,UAAU,CACT,iBACA,OACC,CACD,IAAK,OACJ,OAAS,iBACT,iBAAmB,CAAE,GAAI,OAAQ,EAGlC,IAAM,KAAsB,CAC3B,QAAS,aACT,GAAI,MACL,EAEA,OAAO,KAAK,eAAe,iBAAyB,IAAW,EA4GhE,cAAc,CACb,QACA,QACC,CACD,IAAK,QAAS,OAAO,KAAK,GAAG,eAAgB,OAAc,EAE3D,OAAO,KAAK,GACX,QACA,eACA,OACD,EAqGD,aAAa,CACZ,QACA,QACC,CACD,IAAK,QAAS,OAAO,KAAK,GAAG,cAAe,OAAc,EAE1D,OAAO,KAAK,GACX,QACA,cACA,OACD,EAkGD,WAAW,CACV,QACA,QACC,CACD,IAAK,QAAS,OAAO,KAAK,GAAG,cAAe,OAAc,EAE1D,OAAO,KAAK,GACX,QACA,cACA,OACD,EAiGD,eAAe,CACd,QACA,QACC,CACD,IAAK,QAAS,OAAO,KAAK,GAAG,gBAAiB,OAAc,EAE5D,OAAO,KAAK,GACX,QACA,gBACA,OACD,EA4DD,KAAK,CACJ,QACA,QACC,CACD,IAAK,QACJ,QAAU,QACV,QAAU,CAAE,GAAI,OAAQ,EAGzB,IAAK,MAAM,QAAQ,OAAO,EAAG,QAAU,CAAC,OAAO,EAE/C,QAAW,MAAM,QAChB,KAAK,GACJ,QACA,QACA,aAAa,EAAS,CACvB,EAED,OAAO,KAiIR,KAAK,CAEJ,KAUA,OAGY,CACZ,OAAQ,OAAO,UACT,SAOJ,OALA,OAAM,UAAU,YAAc,KAG9B,KAAK,YAAY,MAAM,MAAQ,OAExB,SAEH,WAGJ,OAFA,KAAK,YAAY,MAAQ,KAAK,KAAK,YAAY,KAAK,EAE7C,KAGT,QAAY,KAAM,UAAU,OAAO,QAAQ,IAAI,EAE9C,OAAM,UAAU,YAAc,KAE9B,KAAK,YAAY,MAAM,MAAQ,OAGhC,OAAO,KAyHR,OAAO,CACN,QACA,QACC,CACD,IAAK,QAAS,OAAO,KAAK,GAAG,QAAS,OAAc,EAEpD,OAAO,KAAK,GACX,QACA,QACA,OACD,EAgBD,MAAM,CAAC,QAA4C,CAGlD,OAFA,KAAK,GAAG,OAAQ,OAAc,EAEvB,KAgDR,EAAE,CACD,cACA,eACA,SACC,CACD,IAAI,KAEJ,OAAQ,OAAO,mBACT,SACJ,KAAO,cACP,SAAW,eAEX,UAEI,SAGJ,GAFA,KAAO,gBAGL,MAAM,QAAQ,cAAc,GAC7B,OAAO,iBAAmB,SAE1B,SAAW,eAEZ,MAGF,GAAI,MAAM,QAAQ,QAAQ,EAAG,SAAW,cAAc,QAAQ,EAE7D,QAAI,OAAO,WAAa,WACvB,SAAW,CACV,CACC,GAAI,QACL,CACD,EACI,cAAW,CAAC,QAAS,EAG3B,IAAM,QAAU,SAEhB,QAAW,UAAU,QAOpB,GANA,OAAO,MACN,OAAO,gBAAkB,SACtB,QACC,eAAe,IAAM,QAGtB,OAAS,WAAa,OAAS,SAAU,OAAO,QAAU,KAG/D,GAAI,OAAS,QACZ,KAAK,UAAY,QAChB,EACE,MAAO,QAAQ,IAAI,CAAC,IAAM,EAAE,EAAE,CAChC,EACA,KAAK,SACN,EAED,QAAW,UAAU,QAAS,CAC7B,IAAM,GAAK,WAAW,OAAQ,SAAU,CAAE,cAAe,EAAK,CAAC,EAE/D,OAAQ,UACF,QACJ,KAAK,MAAM,QAAU,CAAC,EACtB,KAAK,MAAM,MAAM,KAAK,EAAS,EAC/B,UAEI,UACJ,KAAK,MAAM,UAAY,CAAC,EACxB,KAAK,MAAM,QAAQ,KAAK,EAAS,EACjC,UAEI,QACJ,KAAK,MAAM,QAAU,CAAC,EACtB,KAAK,MAAM,MAAM,KAAK,EAAS,EAC/B,UAEI,YACJ,KAAK,MAAM,YAAc,CAAC,EAC1B,KAAK,MAAM,UAAU,KAAK,EAAS,EACnC,UAGI,SACJ,KAAK,MAAM,YAAc,CAAC,EAC1B,KAAK,MAAM,UAAU,KACpB,cAAc,GAAW,QAAQ,CAClC,EACA,UAEI,eACJ,KAAK,MAAM,eAAiB,CAAC,EAC7B,KAAK,MAAM,aAAa,KAAK,EAAS,EACtC,UAII,UACJ,KAAK,MAAM,eAAiB,CAAC,EAC7B,KAAK,MAAM,aAAa,KACvB,cAAc,GAAW,SAAS,CACnC,EACA,UAEI,cACJ,KAAK,MAAM,cAAgB,CAAC,EAC5B,KAAK,MAAM,YAAY,KAAK,EAAS,EACrC,UAEI,cACJ,KAAK,MAAM,cAAgB,CAAC,EAC5B,KAAK,MAAM,YAAY,KAAK,EAAS,EACrC,UAEI,gBACJ,KAAK,MAAM,gBAAkB,CAAC,EAC9B,KAAK,MAAM,cAAc,KAAK,EAAS,EACvC,UAEI,QACJ,KAAK,MAAM,QAAU,CAAC,EACtB,KAAK,MAAM,MAAM,KAAK,EAAS,EAC/B,UAEI,QACJ,KAAK,MAAM,QAAU,CAAC,EACtB,KAAK,MAAM,MAAM,KAAK,EAAS,EAC/B,UAEI,OACJ,KAAK,MAAM,OAAS,CAAC,EACrB,KAAK,MAAM,KAAK,KAAK,EAAS,EAC9B,OAIH,OAAO,KAiER,EAAE,CAAC,KAA2B,CAU7B,GATA,aAAa,KAAK,MAAM,MAAO,IAAI,EACnC,aAAa,KAAK,MAAM,UAAW,IAAI,EACvC,aAAa,KAAK,MAAM,aAAc,IAAI,EAC1C,aAAa,KAAK,MAAM,YAAa,IAAI,EACzC,aAAa,KAAK,MAAM,YAAa,IAAI,EACzC,aAAa,KAAK,MAAM,cAAe,IAAI,EAC3C,aAAa,KAAK,MAAM,MAAO,IAAI,EACnC,aAAa,KAAK,MAAM,MAAO,IAAI,EAE/B,OAAS,SACZ,KAAK,UAAU,OAAS,qBACvB,KAAK,UAAU,OACf,KAAK,UAAU,KAChB,EACA,KAAK,UAAU,MAAQ,KACjB,QAAI,OAAS,SACnB,KAAK,UAAU,OAAS,qBACvB,KAAK,UAAU,OACf,qBACC,KAAK,UAAU,OACf,KAAK,UAAU,KAChB,CACD,EAEA,KAAK,UAAU,OAAS,KACxB,KAAK,UAAU,MAAQ,KAGxB,OAAO,KAuIR,KAAK,CACJ,OACA,YACA,IACY,CACZ,IAAM,SAAW,IAAI,OAAO,IACxB,KAAK,OACR,OAAQ,EACT,CAAC,EAED,SAAS,UAAY,IAAK,KAAK,SAAU,EACzC,SAAS,YAAc,IAAK,KAAK,WAAY,EAC7C,SAAS,UAAY,IAAM,KAAK,UAAU,EAC1C,SAAS,UAAY,eAAe,KAAK,SAAS,EAClD,SAAS,SAAW,IAAK,KAAK,QAAS,EACvC,SAAS,WAAa,KAAK,WAC3B,SAAS,oBAAsB,CAC9B,MAAO,CAAC,GAAI,KAAK,oBAAoB,OAAS,CAAC,CAAE,EACjD,OAAQ,CAAC,GAAI,KAAK,oBAAoB,QAAU,CAAC,CAAE,EACnD,OAAQ,CAAC,GAAI,KAAK,oBAAoB,QAAU,CAAC,CAAE,CACpD,EAEA,IAAM,SAAW,OAAO,cAAgB,SAClC,SAAW,SAAW,IAAO,aAAa,QAAQ,EAIxD,GAHA,KAAK,UAAY,UAAU,KAAK,UAAW,SAAS,SAAS,EAC7D,KAAK,YAAc,UAAU,KAAK,YAAa,SAAS,WAAW,EAE/D,QAAQ,MAAM,SAAS,OAC1B,KAAK,MAAM,QAAU,CACpB,GAAI,KAAK,MAAM,SAAW,CAAC,EAC3B,GAAK,QAAQ,MAAM,SAAW,CAAC,CAChC,EAED,GAAI,QAAQ,MAAM,aAAa,OAC9B,KAAK,MAAM,YAAc,CACxB,GAAI,KAAK,MAAM,aAAe,CAAC,EAC/B,GAAK,QAAQ,MAAM,aAAe,CAAC,CACpC,EAkDD,OAhDA,KAAK,MAAM,QAAQ,YAAY,IAAI,EAEnC,OAAO,OAAO,SAAS,OAAO,OAAO,EAAE,QACtC,EAAG,OAAQ,KAAM,QAAS,MAAO,wBAA2B,CAG3D,GAFA,MAAQ,SAAW,GAAK,KAAK,OAAO,QAAU,OAAS,KAEnD,SAAU,CACb,IAAM,KAAO,YACP,UAAY,MAElB,KAAK,IACJ,OACA,KACA,QACA,UAAU,KAAM,IACX,WAAa,CAAC,EAClB,OAAQ,UAAU,MACf,QAAQ,MAAM,MACd,MAAM,QAAQ,UAAU,KAAK,EAC5B,CACA,GAAI,UAAU,OAAS,CAAC,EACxB,GAAI,QAAQ,MAAM,OAAS,CAAC,CAC7B,EACC,CACA,UAAU,MACV,GAAI,QAAQ,MAAM,OAAS,CAAC,CAC7B,CACJ,CAAC,EACD,OACA,oBACD,EAEA,UAAK,IACJ,OACA,KACA,QACA,UAAU,MAAuB,CAChC,MAAO,QAAQ,MAAM,KACtB,CAAC,EACD,CACC,WAAY,EACb,EACA,oBACD,EAGH,EAEO,KAsXR,KAAK,CACJ,KAKA,IACY,CACZ,IAAK,IAAK,CACT,GAAI,OAAO,OAAS,SAAU,CAG7B,GAFA,KAAK,WAAW,IAAI,EAEhB,KAAK,OACR,GAAI,KAAK,OAAO,OACf,KAAK,OAAO,OAAS,UACpB,OAAO,OAAO,CAAC,EAAG,KAAK,OAAO,MAAM,EACpC,KAAK,MACN,EACI,UAAK,OAAO,OAAS,KAAK,OAGhC,GAAI,KAAK,KACR,IAAK,KAAK,OAAO,OAChB,KAAK,OAAO,OAAS,CACpB,KAAM,KAAK,IACZ,EACI,UAAK,OAAO,OAAO,KAAO,KAAK,KAGrC,IAAM,KAAsB,KAAK,IAAM,QAEvC,GAAI,KAAK,SAAW,aAAc,CACjC,IAAK,KAAK,oBAAoB,MAC7B,KAAK,oBAAoB,MAAQ,CAAC,EAEnC,IAAM,SACL,MAAM,UACN,OAAO,MAAM,WAAa,UACzB,MAAM,UAAY,SAAQ,KAAK,SAC7B,CACA,IAAK,KAAK,QACX,EACC,MAAM,SAWV,OATA,KAAK,oBAAoB,MAAM,KAAK,CACnC,KAAM,KAAK,KACX,QAAS,KAAK,QACd,OAAQ,KAAK,OACb,MAAO,KAAK,MACZ,SACA,OAAQ,KAAK,MACd,CAAC,EAEM,KAYR,GATA,KAAK,UAAU,MAAQ,CACtB,KAAM,KAAK,MAAQ,KAAK,UAAU,OAAO,KACzC,QAAS,KAAK,SAAW,KAAK,UAAU,OAAO,QAC/C,OAAQ,KAAK,QAAU,KAAK,UAAU,OAAO,OAC7C,MAAO,KAAK,OAAS,KAAK,UAAU,OAAO,MAC3C,SAAU,KAAK,UAAY,KAAK,UAAU,OAAO,SACjD,OAAQ,KAAK,QAAU,KAAK,UAAU,OAAO,MAC9C,EAEI,KAAK,MAAO,KAAK,GAAG,CAAE,GAAI,IAAK,EAAG,QAAS,KAAK,KAAK,EACzD,GAAI,KAAK,UACR,KAAK,GAAG,CAAE,GAAI,IAAK,EAAG,YAAa,KAAK,SAAS,EAElD,GAAI,KAAK,OAAQ,KAAK,GAAG,CAAE,GAAI,IAAK,EAAG,SAAU,KAAK,MAAM,EAC5D,GAAI,KAAK,aACR,KAAK,GAAG,CAAE,GAAI,IAAK,EAAG,eAAgB,KAAK,YAAY,EAExD,GAAI,KAAK,QAAS,KAAK,GAAG,CAAE,GAAI,IAAK,EAAG,UAAW,KAAK,OAAO,EAC/D,GAAI,KAAK,YACR,KAAK,GAAG,CAAE,GAAI,IAAK,EAAG,cAAe,KAAK,WAAW,EACtD,GAAI,KAAK,YACR,KAAK,GAAG,CAAE,GAAI,IAAK,EAAG,cAAe,KAAK,WAAW,EACtD,GAAI,KAAK,cACR,KAAK,GAAG,CAAE,GAAI,IAAK,EAAG,gBAAiB,KAAK,aAAa,EAC1D,GAAI,KAAK,MAAO,KAAK,GAAG,CAAE,GAAI,IAAK,EAAG,QAAS,KAAK,KAAK,EAEzD,OAAO,KAGR,OAAO,KAAK,MAAM,CAAC,EAAU,IAAI,EAGlC,IAAM,SAAW,IAAI,OAAO,IACxB,KAAK,OACR,OAAQ,EACT,CAAC,EACD,SAAS,UAAY,IAAK,KAAK,SAAU,EACzC,SAAS,YAAc,IAAK,KAAK,WAAY,EAC7C,SAAS,UAAY,eAAe,KAAK,SAAS,EAClD,SAAS,SAAW,IAAK,KAAK,QAAS,EAEvC,IAAM,QAAU,IAAI,QAAQ,EAO5B,GANA,KAAK,UAAY,UAAU,KAAK,UAAW,SAAS,SAAS,EAC7D,KAAK,YAAc,UAAU,KAAK,YAAa,SAAS,WAAW,EAGnE,QAAQ,UAAY,IAAM,KAAK,OAE3B,QAAQ,MAAM,SAAS,OAC1B,KAAK,MAAM,QAAU,CACpB,GAAI,KAAK,MAAM,SAAW,CAAC,EAC3B,GAAI,QAAQ,MAAM,SAAW,CAAC,CAC/B,EAED,GAAI,QAAQ,MAAM,aAAa,OAC9B,KAAK,MAAM,YAAc,CACxB,GAAI,KAAK,MAAM,aAAe,CAAC,EAC/B,GAAI,QAAQ,MAAM,aAAe,CAAC,CACnC,EA4BD,OA1BA,KAAK,MAAM,QAAQ,YAAY,IAAI,EAEnC,OAAO,OAAO,SAAS,OAAO,OAAO,EAAE,QACtC,EAAG,OAAQ,KAAM,QAAS,MAAO,aAAgB,CAChD,KAAK,IACJ,OACA,KACA,QACA,UAAU,KAAsB,IAC1B,WAAa,CAAC,EACnB,OAAQ,UAAU,MACf,QAAQ,MAAM,MACd,MAAM,QAAQ,UAAU,KAAK,EAC5B,CACA,GAAI,UAAU,OAAS,CAAC,EACxB,GAAI,QAAQ,MAAM,OAAS,CAAC,CAC7B,EACC,CACA,UAAU,MACV,GAAI,QAAQ,MAAM,OAAS,CAAC,CAC7B,CACJ,CAAC,CACF,EAEF,EAEO,KAkOR,GAAG,CACF,OAUA,QACY,CACZ,GAAI,MAAM,QAAQ,MAAM,EAAG,CAE1B,IAAI,IAAM,KACV,QAAW,KAAK,OAAQ,IAAM,IAAI,IAAI,CAAC,EACvC,OAAO,IAGR,GAAI,SAAS,OACZ,OAAO,KAAK,MAAM,CAAC,EAAU,CAAC,MAAQ,IAAI,IAAI,MAAa,CAAC,EAE7D,GAAI,MAAM,QAAQ,MAAM,EAAG,CAE1B,IAAI,QAAU,KAEd,QAAW,KAAK,OAAQ,QAAU,KAAK,IAAI,CAAC,EAE5C,OAAO,QAGR,GAAI,kBAAkB,QA2CrB,OA1CA,KAAK,gBAAgB,IACpB,OACE,KAAK,CAAC,UAAW,CACjB,GAAI,OAAO,UAAW,WAAY,OAAO,QAAO,IAAI,EAEpD,GAAI,mBAAkB,OACrB,OAAO,KAAK,KAAK,OAAM,EAAE,QAAQ,EAElC,GAAI,QAAO,YAAY,OAAS,SAC/B,OAAO,KAAK,KACX,OACD,EAAE,QAAQ,EAEX,GAAI,OAAO,QAAO,UAAY,WAC7B,OAAO,QAAO,QAAQ,IAAI,EAE3B,GAAI,QAAO,mBAAmB,OAC7B,OAAO,KAAK,KAAK,QAAO,OAAO,EAEhC,GAAI,QAAO,YAAY,OAAS,SAC/B,OAAO,KAAK,KAAK,QAAO,OAAO,EAEhC,GAAI,QAAO,YAAY,OAAS,UAC/B,OAAO,KAAK,KAAK,QAAO,OAAO,EAEhC,GAAI,CACH,OAAO,KAAK,KAAK,QAAO,OAAO,EAC9B,MAAO,OAAO,CAKf,MAJA,QAAQ,MACP,gJACD,EAEM,QAEP,EACA,KAAK,CAAC,IAAM,CACZ,GAAI,GAAK,OAAO,EAAE,UAAY,WAAY,EAAE,QAAQ,EAEpD,OAAO,EACP,CACH,EAEO,KAGR,OAAO,KAAK,KAAK,MAAM,EAGhB,uBAAuB,CAAC,OAAgB,CAC/C,GAAI,OAAO,gBAAgB,MAAQ,EAAG,OAAO,KAE7C,QAAW,WAAW,OAAO,gBAAgB,SAC5C,KAAK,gBAAgB,IACpB,QAAQ,KAAK,CAAC,IAAM,CACnB,IAAK,EAAG,OAER,IAAM,GAAI,KAAK,KAAK,CAAC,EACrB,GAAI,cAAa,QAChB,OAAO,GAAE,KAAK,CAAC,KAAO,CACrB,GAAI,GAAI,GAAG,QAAQ,EACd,OAAE,QAAQ,EACf,EAEF,OAAO,EAAE,QAAQ,EACjB,CACF,EAED,OAAO,KAGA,IAAI,CACX,OACC,CACD,GAAI,OAAO,SAAW,WAAY,CACjC,IAAM,SAAW,OAAO,IAAsB,EAE9C,GAAI,oBAAoB,QAgEvB,OA/DA,KAAK,gBAAgB,IACpB,SACE,KAAK,CAAC,UAAW,CACjB,GAAI,mBAAkB,OAAQ,CAC7B,QAAO,UAAY,IAAM,KAAK,UAAU,EACxC,QAAO,gBAAkB,IACxB,KAAK,gBAAgB,EACtB,QAAO,qBAAuB,IAC7B,KAAK,qBAAqB,EAK3B,QAAO,MAAM,KAAK,YAAY,IAAW,EACzC,QAAO,MAAM,KAAK,YAAY,KAAY,EAG1C,QACC,OACA,KACA,QACA,MACA,wBACI,OAAO,OAAO,QAAO,OAAO,OAAO,EACvC,KAAK,IACJ,OACA,KACA,QACA,WAAW,QAAO,MAAM,KAAK,EAC1B,UAAU,MAAuB,CACjC,MAAO,QAAO,MAAM,KACrB,CAAC,EACA,MACH,OACA,oBACD,EAED,GAAI,UAAW,KAAM,OAIrB,OAFA,KAAK,wBAAwB,OAAM,EAE5B,QAGR,GAAI,OAAO,UAAW,WACrB,OAAO,QACN,IACD,EAED,GAAI,OAAO,QAAO,UAAY,WAC7B,OAAO,QAAO,QACb,IACD,EAED,OAAO,KAAK,KAAK,OAAM,EACvB,EACA,KAAK,CAAC,IAAM,CACZ,GAAI,GAAK,OAAO,EAAE,UAAY,WAC7B,EAAE,QAAQ,EAEX,OAAO,EACP,CACH,EACO,KAGR,OAAO,SAGR,KAAK,wBAAwB,MAAM,EAEnC,IAAM,KAAO,OAAO,OAAO,KACrB,KAAO,OAAO,OAAO,KA+C3B,GA7CA,OAAO,UAAY,IAAM,KACzB,OAAO,UAAY,IAAM,KAAK,UAAU,EACxC,OAAO,gBAAkB,IAAM,KAAK,gBAAgB,EACpD,OAAO,qBAAuB,IAAM,KAAK,qBAAqB,EA0C1D,OAAO,qBAAqB,OAC/B,GAAI,KAAK,oBAAoB,MAC5B,KAAK,oBAAoB,MACxB,KAAK,oBAAoB,MAAM,OAC9B,OAAO,oBAAoB,MAC5B,EAED,UAAK,oBAAoB,MACxB,OAAO,oBAAoB,OAG9B,GAAI,OAAO,qBAAqB,OAC/B,GAAI,KAAK,oBAAoB,OAC5B,KAAK,oBAAoB,OACxB,KAAK,oBAAoB,OAAO,OAC/B,OAAO,oBAAoB,MAC5B,EAED,UAAK,oBAAoB,OACxB,OAAO,oBAAoB,OAS9B,GAAI,WAAW,OAAO,UAAU,EAC/B,KAAK,WAAa,IACd,OAAO,cACP,KAAK,UACT,EAED,GAAI,OAAO,WAAY,KAAK,QAAQ,OAAO,UAAU,EAErD,GAAI,KAAM,CACT,KAAM,QAAQ,KAAK,cAAe,KAAK,aAAa,MAAQ,CAAC,EAE7D,IAAM,QACL,OAAS,OAAY,SAAS,KAAO,KAAK,UAAU,IAAI,CAAC,EAAI,EAE9D,IACE,KAAK,aAAa,MAAM,KACxB,EAAG,sBAAe,UAAY,SAC/B,EAEA,KAAK,SAAS,OAAS,KAAK,SAAS,OAAO,OAC3C,OAAO,SAAS,MACjB,EAEA,KAAK,SAAS,qBACb,KAAK,SAAS,qBAAqB,OAClC,OAAO,SAAS,oBACjB,EAEI,KACN,GAAI,OAAO,SAAS,OAAO,OAC1B,KAAK,SAAS,OAAS,KAAK,SAAS,OAAO,OAC3C,OAAO,SAAS,MACjB,EAED,GAAI,OAAO,SAAS,qBAAqB,OACxC,KAAK,SAAS,qBACb,KAAK,SAAS,qBAAqB,OAClC,OAAO,SAAS,oBACjB,EAIH,oBAAoB,KAAK,SAAS,MAAM,EACxC,oBAAoB,KAAK,SAAS,oBAAoB,EAGtD,IAAM,UAAsB,CAAC,EAC7B,QAAS,EAAI,EAAG,EAAI,KAAK,SAAS,qBAAqB,OAAQ,IAAK,CACnE,IAAM,IAAM,KAAK,SAAS,qBAAqB,GAE/C,GAAI,IAAI,SAAU,CACjB,GAAI,UAAU,SAAS,IAAI,QAAQ,EAClC,KAAK,SAAS,qBAAqB,OAAO,EAAG,CAAC,EAC9C,IAGD,UAAU,KAAK,IAAI,QAAQ,GAO7B,GAJA,UAAU,OAAS,EAEnB,KAAK,UAAY,eAAe,KAAK,UAAW,OAAO,SAAS,EAE5D,WAAW,OAAO,UAAU,SAAS,EACxC,KAAK,SAAS,OAAO,UAAU,SAAS,EAEzC,GAAI,WAAW,OAAO,UAAU,KAAK,EACpC,KAAK,MAAM,OAAO,UAAU,KAAK,EAElC,GAAI,WAAW,OAAO,YAAY,IAAI,EACrC,KAAK,MAAM,OAAO,YAAY,IAAI,EAEnC,GAAI,WAAW,OAAO,YAAY,KAAK,EACtC,KAAK,MAAM,OAAO,YAAY,KAAY,EAE3C,GAAI,WAAW,OAAO,YAAY,KAAK,EACtC,OAAO,SAAS,OAAS,KAAK,SAAS,OAAO,OAC7C,OAAO,SAAS,MACjB,EAED,QACC,OACA,KACA,QACA,MACA,wBACI,OAAO,OAAO,OAAO,OAAO,OAAO,EACvC,KAAK,IACJ,OACA,KACA,QACA,WAAW,OAAO,MAAM,KAAK,EAC1B,UAAU,MAAuB,CACjC,MAAO,OAAO,MAAM,KACrB,CAAC,EACA,MACH,OACA,oBACD,EAGD,GAAI,KAAM,CACT,KAAM,QAAQ,KAAK,cAAe,KAAK,aAAa,MAAQ,CAAC,EAE7D,IAAM,QACL,OAAS,OAAY,SAAS,KAAO,KAAK,UAAU,IAAI,CAAC,EAAI,EAE9D,GACC,KAAK,aAAa,MAAM,KACvB,EAAG,sBAAe,UAAY,SAC/B,EAEA,OAAO,KAmCR,GAjCA,KAAK,aAAa,MAAM,KACvB,KAAK,QAAQ,SACT,CACD,KAAM,OAAO,OAAO,KACpB,KAAM,OAAO,OAAO,KACpB,SAAU,QACV,aAAc,OAAO,aACrB,MAAO,OAAO,WAAW,MACzB,OAAQ,OAAO,OAAO,QACtB,WAAY,OAAO,UACnB,MAAO,OAAO,UAAU,MACxB,MAAO,OAAO,YAAY,MAC1B,OAAQ,OAAO,MAAM,WAClB,OAAO,CAAC,IAAM,GAAG,UAAY,QAAQ,EACtC,IAAI,CAAC,KAAO,CACZ,GAAI,EAAE,SAAS,EACf,MAAO,IAAI,MAAM,EAAE,OAAS,EAC7B,EAAE,EACH,QAAS,OAAO,MAAM,WACnB,OAAO,CAAC,IAAM,GAAG,UAAY,SAAS,EACvC,IAAI,CAAC,KAAO,CACZ,GAAI,EAAE,SAAS,EACf,MAAO,IAAI,MAAM,EAAE,OAAS,EAC7B,EAAE,CACJ,EACC,CACA,KAAM,OAAO,OAAO,KACpB,KAAM,OAAO,OAAO,KACpB,SAAU,QACV,aAAc,OAAO,YACtB,CACH,EAEI,WAAW,OAAO,KAAK,EAC1B,KAAK,MAAQ,eACZ,KAAK,MACL,iBAAiB,OAAO,KAAK,EAC7B,OACD,EAED,QAAI,WAAW,OAAO,KAAK,EAC1B,KAAK,MAAQ,eACZ,KAAK,MACL,iBAAiB,OAAO,KAAK,CAC9B,EAGF,GAAI,OAAO,UAAU,OAEpB,KAAK,UAAU,OAAS,UAAU,KAAK,UAAU,OAAQ,IACrD,OAAO,UAAU,MACrB,CAAC,EAEF,GAAI,OAAO,UAAU,OAEpB,KAAK,UAAU,MAAQ,UAAU,KAAK,UAAU,MAAO,IACnD,OAAO,UAAU,MACrB,CAAC,EAEF,OAAO,KA4DR,KAAK,CAAC,MAA+C,CACpD,GAAI,OAAO,QAAU,WAAY,CAChC,IAAM,KAAmB,CACxB,SAAU,SACT,KAAK,UAAU,CACd,KAAM,KAAK,OAAO,KAClB,KAAM,KAAK,OAAO,KAClB,QAAS,MAAM,SAAS,CACzB,CAAC,CACF,EACA,GAAI,KACL,EAEA,KAAK,SAAS,OAAO,KAAK,IAAI,EACxB,QAAI,OAAO,QAAU,SAAU,CACrC,QAAW,QAAQ,OAAO,KAAK,KAAK,EACnC,GAAI,OAAO,MAAM,QAAU,SAAU,CACpC,IAAM,YAAc,IAAM,MAAM,KAAiB,EAEjD,MAAM,MAAQ,CAAC,IAAe,CAC7B,GAAI,IAAM,GAAM,OAAO,aAI1B,IAAM,KAAmB,CACxB,SAAU,SACT,KAAK,UAAU,CACd,KAAM,KAAK,OAAO,KAClB,KAAM,KAAK,OAAO,KAClB,QAAS,OAAO,QAAQ,KAAK,EAC3B,IAAI,EAAE,GAAG,KAAO,GAAG,MAAK,GAAG,EAC3B,KAAK,GAAG,CACX,CAAC,CACF,EACA,GAAI,IAAM,KACX,EAEA,KAAK,SAAS,OAAO,KAAK,IAAI,EAG/B,OAAO,KAaR,KAAK,CACJ,KAIA,eAIA,OACC,CACD,GACC,gBAAgB,QAChB,OAAO,OAAS,YAChB,KAAK,SAAW,GAChB,OAAS,IACR,CACD,IAAM,IACL,OAAO,OAAS,WACb,KACA,gBAAgB,OACf,KAAK,QAAQ,EAAE,MACf,0BAA0B,OACzB,eAAe,QAAQ,EAAE,MACzB,OAAO,iBAAmB,WACzB,gBACC,IAAM,CACP,MAAM,IAAI,MAAM,iBAAiB,IAC/B,EAEH,SAAmB,EAAG,QAAS,cACpC,IACC,IAAI,QAAQ,eAAe,QAAQ,IAAK,KAAI,EAAG,CAC9C,OAAQ,QAAQ,OAChB,QAAS,QAAQ,QACjB,OAAQ,QAAQ,OAChB,YAAa,QAAQ,YACrB,eAAgB,QAAQ,eACxB,OAAQ,QAAQ,OAChB,SAAU,QAAQ,SAClB,KAAM,QAAQ,KACd,UAAW,QAAQ,UACnB,UAAW,QAAQ,UACnB,KAAM,QAAQ,IACf,CAAC,CACF,EAcD,OAZA,KAAK,MAAM,MAAO,KAAM,SAAgB,CACvC,MAAO,UACJ,OACH,OAAQ,IACJ,QAAQ,OACX,KAAM,EACP,EACA,OAAQ,CACP,MAAO,GACR,CACD,CAAC,EAEM,KAGR,IAAM,OACL,0BAA0B,OACvB,eAAe,QAAQ,EAAE,MACzB,OAAO,iBAAmB,WACzB,gBACC,IAAM,CACP,MAAM,IAAI,MAAM,iBAAiB,IAC/B,EAED,OAAS,KAAK,QAAU,KAAK,SAAS,GAAG,EAAI,EAAI,GAEjD,QAAmB,EAAG,QAAS,cACpC,OACC,IAAI,QACH,eAAe,QAAQ,IAAK,MAAK,MAAM,MAAM,GAAK,GAAG,EACrD,CACC,OAAQ,QAAQ,OAChB,QAAS,QAAQ,QACjB,OAAQ,QAAQ,OAChB,YAAa,QAAQ,YACrB,eAAgB,QAAQ,eACxB,OAAQ,QAAQ,OAChB,SAAU,QAAQ,SAClB,KAAM,QAAQ,KACd,UAAW,QAAQ,UACnB,UAAW,QAAQ,UACnB,KAAM,QAAQ,IACf,CACD,CACD,EA+BD,OA7BA,KAAK,MAAM,MAAO,KAAM,QAAgB,CACvC,MAAO,UACJ,OACH,OAAQ,IACJ,QAAQ,OACX,KAAM,EACP,EACA,OAAQ,CACP,MAAO,MACR,CACD,CAAC,EAED,KAAK,MACJ,MACA,MAAQ,KAAK,SAAS,GAAG,EAAI,IAAM,MACnC,QACA,CACC,MAAO,UACJ,OACH,OAAQ,IACJ,QAAQ,OACX,KAAM,EACP,EACA,OAAQ,CACP,MAAO,MACR,CACD,CACD,EAEO,KAmBR,GA+BC,CACA,KACA,QACA,KA8BC,CAGD,OAFA,KAAK,IAAI,MAAO,KAAM,QAAgB,IAAI,EAEnC,KAmBR,IA+BC,CACA,KACA,QACA,KA8BC,CAGD,OAFA,KAAK,IAAI,OAAQ,KAAM,QAAgB,IAAI,EAEpC,KAmBR,GA+BC,CACA,KACA,QACA,KA8BC,CAGD,OAFA,KAAK,IAAI,MAAO,KAAM,QAAgB,IAAI,EAEnC,KAmBR,KA+BC,CACA,KACA,QACA,KA8BC,CAGD,OAFA,KAAK,IAAI,QAAS,KAAM,QAAgB,IAAI,EAErC,KAmBR,MA+BC,CACA,KACA,QACA,KA8BC,CAGD,OAFA,KAAK,IAAI,SAAU,KAAM,QAAgB,IAAI,EAEtC,KAmBR,OA+BC,CACA,KACA,QACA,KA8BC,CAGD,OAFA,KAAK,IAAI,UAAW,KAAM,QAAgB,IAAI,EAEvC,KAmBR,GA+BC,CACA,KACA,QACA,KA8BC,CAGD,OAFA,KAAK,IAAI,MAAO,KAAM,QAAgB,IAAI,EAEnC,KAmBR,IA+BC,CACA,KACA,QACA,KA8BC,CAGD,OAFA,KAAK,IAAI,OAAQ,KAAM,QAAgB,IAAI,EAEpC,KAmBR,OA+BC,CACA,KACA,QACA,KA8BC,CAGD,OAFA,KAAK,IAAI,UAAW,KAAM,QAAgB,IAAI,EAEvC,KAmBR,KAgCC,CACA,OACA,KACA,QACA,KAmCC,CAGD,OAFA,KAAK,IAAI,OAAO,YAAY,EAAG,KAAM,QAAgB,KAAM,MAAM,MAAM,EAEhE,KAoBR,EAiBC,CACA,KACA,QAqCC,CACD,GAAI,KAAK,YAAY,GAAI,KAAK,YAAY,GAAG,KAAM,KAAM,OAAc,EAClE,aAAQ,KAAK,2CAA2C,EAE7D,OAAO,KAiLR,KAAK,CACJ,QAKA,KAKA,MACC,CACD,GAAI,OAAS,OAKZ,MAAQ,QACR,QAAU,CAAE,GAAI,QAAS,EACzB,KAAO,GACD,QAAI,QAAU,QAQpB,GAAI,OAAO,UAAY,SACtB,MAAQ,KACR,KAAO,QACP,QAAU,CAAE,GAAI,QAAS,EACnB,QAAI,OAAO,UAAY,SAE7B,MAAQ,KACR,KAAO,GAIT,IAAQ,IAAO,QAEf,GAAI,OAAO,OAAS,SAAU,OAAO,KAErC,OAAQ,OAAO,WACT,SACJ,IAAK,QAAU,WAAW,KAAK,EAAG,OAAO,KAEzC,GAAI,KAAM,CACT,GAAI,QAAQ,KAAK,UAAU,MAC1B,KAAK,UAAU,MAAM,MAAQ,UAC5B,KAAK,UAAU,MAAM,MACrB,MACA,CACC,SAAU,KAAO,UAClB,CACD,EACI,UAAK,UAAU,MAAM,MAAQ,MAElC,OAAO,KAGR,GAAI,QAAU,KAAM,OAAO,KAM3B,OAJA,KAAK,UAAU,MAAQ,UAAU,KAAK,UAAU,MAAO,MAAO,CAC7D,SAAU,KAAO,UAClB,CAAC,EAEM,SAEH,WACJ,GAAI,MACH,GAAI,KAAO,cAAgB,QAAQ,KAAK,UAAU,OACjD,KAAK,UAAU,MAAM,MAAQ,MACxB,UAAK,UAAU,MAAQ,MAAM,KAAK,UAAU,KAAK,EAExD,OAAO,aAGP,GAAI,KAAO,cAAgB,QAAQ,KAAK,UAAU,OACjD,KAAK,UAAU,MAAM,MAAQ,MAE9B,OAAO,MAkLV,QAAQ,CACP,QAKA,KAKA,MACC,CACD,GAAI,OAAS,OAKZ,MAAQ,QACR,QAAU,CAAE,GAAI,QAAS,EACzB,KAAO,GACD,QAAI,QAAU,QAQpB,GAAI,OAAO,UAAY,SACtB,MAAQ,KACR,KAAO,QACP,QAAU,CAAE,GAAI,QAAS,EACnB,QAAI,OAAO,UAAY,SAE7B,MAAQ,KACR,KAAO,GAIT,IAAQ,IAAO,QAEf,GAAI,OAAO,OAAS,SAAU,OAAO,KAErC,OAAQ,OAAO,WACT,SACJ,GAAI,KAAM,CACT,GAAI,QAAQ,KAAK,UAAU,UAC1B,KAAK,UAAU,UAAU,MAAQ,UAChC,KAAK,UAAU,UAAU,MACzB,MACA,CACC,SAAU,KAAO,UAClB,CACD,EACI,UAAK,UAAU,UAAU,MAAQ,MAEtC,OAAO,KAGR,GAAI,QAAU,KAAM,OAAO,KAU3B,OARA,KAAK,UAAU,UAAY,UAC1B,KAAK,UAAU,UACf,MACA,CACC,SAAU,KAAO,UAClB,CACD,EAEO,SAEH,WACJ,GAAI,MACH,GACC,KAAO,cACL,QAAQ,KAAK,UAAU,WAEzB,KAAK,UAAU,UAAU,MAAQ,MAElC,UAAK,UAAU,UAAY,MAAM,KAAK,UAAU,SAAS,EAE1D,OAAO,aAGP,GAAI,KAAO,cAAgB,QAAQ,KAAK,UAAU,WACjD,KAAK,UAAU,UAAU,MAAQ,MAElC,OAAO,MA8KV,MAAM,CACL,mBACA,UACC,CACD,IAAK,UACJ,UAAY,mBACZ,mBAAqB,CAAE,GAAI,OAAQ,EAGpC,IAAM,KAAsB,CAC3B,QAAS,SACT,GAAI,SACL,EAEA,OAAO,KAAK,YAAY,mBAA2B,IAAW,EAiE/D,KAAK,CAAC,KAAmD,MAAiB,CACzE,OAAQ,OAAO,UACT,SACJ,IAAM,cAAgB,CAAC,EAEjB,IAAM,OAAO,QAAQ,IAAI,EAE/B,IAAK,IAAI,OAAQ,OAAO,KAExB,QAAY,IAAK,SAAU,IAAK,CAC/B,GAAI,OAAO,KAAK,YAAY,KAAM,SAElC,cAAc,KAAO,KAAK,YAAY,KAAK,KAAO,MAClD,cAAc,KAAK,MAAQ,wBAAwB,MASpD,OALA,KAAK,YAAY,QAAU,EAAE,OAAO,IAC/B,KAAK,YAAY,QAAQ,SAC1B,aACJ,CAAQ,EAED,SAEH,WACJ,IAAM,OAAS,KAAK,KAAK,YAAY,IAAI,EAIzC,OAHA,KAAK,YAAY,KAAO,OACxB,KAAK,YAAY,QAAU,EAAE,OAAO,MAAa,EAE1C,SAEH,SACJ,IAAK,MAAO,MAEZ,IAAM,SAAW,IACb,MACH,GAAI,MAAM,KAAO,wBAAwB,MAC1C,EAOA,OALA,KAAK,YAAY,KAAK,MAAQ,MAC9B,KAAK,YAAY,QAAU,EAAE,OAAO,IAC/B,KAAK,YAAY,QAAQ,SAC1B,QACJ,CAAQ,EACD,KAST,OANE,KAAK,YAAY,KAAiC,MAAQ,MAC5D,KAAK,YAAY,QAAU,EAAE,OAAO,IAChC,KAAK,YAAY,QAAQ,OAC3B,MAAO,KACT,CAAQ,EAED,KAGR,GAAoD,CAAC,IAAQ,CAC5D,OAAO,EAAE,IAAI,GAAG,EA2HjB,SAAS,CACR,gBACA,OACC,CACD,IAAK,OACJ,OAAS,gBACT,gBAAkB,CAAE,GAAI,OAAQ,EAGjC,IAAM,KAAsB,CAC3B,QAAS,YACT,GAAI,MACL,EAEA,OAAO,KAAK,YAAY,gBAAwB,IAAW,EAG5D,KAIC,CACA,KACA,KACA,KAqDC,CACD,GAAI,OAAS,GAAI,OAAO,KAExB,IAAM,WAAa,CAAC,IAAK,IAAK,GAAG,EAC3B,WAAa,CAAC,QACnB,MAAK,GAAG,YAAY,EAAI,MAAK,MAAM,CAAC,EAE/B,QACL,OAAS,SACN,CAAC,OAAgB,QACjB,WAAW,SAAS,OAAO,GAAG,EAAE,GAAK,EAAE,EACpC,OAAS,MACT,OAAS,WAAW,KAAI,EAC3B,WAAW,SAAS,KAAK,GAAG,EAAE,GAAK,EAAE,EACpC,CAAC,OAAgB,QAAiB,MAAO,OACzC,CAAC,OAAgB,QACjB,MAAO,WAAW,MAAM,EAEvB,MAAQ,CAAC,QAAoD,CAClE,IAAM,MAA6B,CAAC,EAEpC,OAAQ,WACF,YACJ,QAAW,OAAO,KAAK,UAAU,UAChC,MAAM,QAAQ,KAAM,GAAG,GACtB,KAAK,UAAU,UAAU,KAG3B,KAAK,UAAU,UAAY,MAC3B,UAEI,QACJ,QAAW,OAAO,KAAK,UAAU,MAChC,MAAM,QAAQ,KAAM,GAAG,GAAK,KAAK,UAAU,MAAM,KAElD,KAAK,UAAU,MAAQ,MACvB,UAEI,QACJ,QAAW,OAAO,KAAK,YAAY,KAClC,MAAM,QAAQ,KAAM,GAAG,GAAK,KAAK,YAAY,KAAK,KAEnD,KAAK,YAAY,KAAO,MACxB,UAEI,QACJ,QAAW,OAAO,KAAK,YAAY,MAClC,MAAM,QAAQ,KAAM,GAAG,GAAK,KAAK,YAAY,MAAM,KAEpD,KAAK,YAAY,MAAQ,MACzB,QAIG,MAAQ,MAAM,QAAQ,IAAI,EAAI,KAAO,CAAC,IAAI,EAEhD,QAAW,SAAQ,MAAM,KAAK,CAAC,IAAM,IAAM,KAAK,EAC7C,CAAC,YAAa,QAAS,QAAS,OAAO,EACvC,MACF,MAAM,KAAmB,EAE1B,OAAO,KAGR,MAGC,CAAC,KAAY,KAAY,CACzB,OAAO,KAAK,MAAM,SAAU,KAAM,IAAI,EAGvC,MAGC,CAAC,KAAY,KAAY,CACzB,OAAO,KAAK,MAAM,SAAU,KAAM,IAAI,EAGvC,OAAO,EAAG,CACT,GAAI,KAAK,YAAY,cAAe,CAKnC,GAJA,KAAK,MAAQ,KAAK,OAAO,IACtB,sBAAsB,IAAI,EAC1B,qBAAqB,IAAI,EAExB,OAAO,KAAK,QAAQ,SAAW,WAClC,KAAK,OAAO,OAAO,IACd,KAAK,QAAU,CAAC,EACpB,MAAO,KAAK,KACb,CAAC,EAEF,OAAO,KAGR,GAAI,OAAO,KAAK,QAAQ,SAAW,WAClC,KAAK,OAAO,OAAO,KAAK,QAAU,CAAC,CAAC,EAIrC,OAFA,KAAK,QAAU,sBAAsB,IAAI,EAElC,KAGR,OAAS,MAAO,UAAqB,KAAK,MAAM,OAAO,EAOvD,MAAQ,CAAC,UAA6C,CACrD,OAAQ,KAAK,MAAQ,KAAK,OAAO,IAC9B,sBAAsB,IAAI,EAC1B,qBAAqB,IAAI,GAAG,OAAO,GAQ7B,YAAc,MACvB,QAeA,SAMI,CACJ,OAAQ,KAAK,YAAc,KAAK,OAAO,IACpC,oBAAoB,IAAI,EACxB,0BAA0B,IAAI,GAAG,QAAS,MAAK,GAenD,OAAS,CACR,QACA,WACI,CAGJ,GAFA,KAAK,YAAY,OAAO,IAAI,EAAE,QAAS,QAAQ,EAE3C,KAAK,gBAAgB,KAAM,kBAAkB,IAAI,EAMrD,OAJA,KAAK,gBAAgB,KAAK,IAAM,CAC/B,kBAAkB,IAAI,EACtB,EAEM,MA2BR,KAAO,MAAO,yBAAqC,CAClD,IAAK,KAAK,OACT,MAAM,IAAI,MACT,8DACD,EAED,GAAI,KAAK,QAIR,GAHA,KAAK,OAAO,KAAK,sBAAsB,EACvC,KAAK,OAAS,KAEV,KAAK,MAAM,MAAM,OACpB,QAAS,EAAI,EAAG,EAAI,KAAK,MAAM,KAAK,OAAQ,IAC3C,KAAK,MAAM,KAAK,GAAG,GAAG,IAAI,OAO1B,QAAO,EAAG,CACb,OAAO,KAAK,gBAEd",
  "debugId": "7F364F51641AE27C64756E2164756E21",
  "names": []
}